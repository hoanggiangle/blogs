// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: product/product.proto

package product // import "gitlab.sendo.vn/protobuf/internal-apis-go/product"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import types "github.com/gogo/protobuf/types"
import base "gitlab.sendo.vn/protobuf/internal-apis-go/base"
import flashdeal "gitlab.sendo.vn/protobuf/internal-apis-go/product/flashdeal"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ColorType int32

const (
	ColorType_DEFAULT       ColorType = 0
	ColorType_COLOR_TEXT    ColorType = 1
	ColorType_COLOR_HEX     ColorType = 2
	ColorType_COLOR_PATTERN ColorType = 3
	ColorType_COLOR_IMAGE   ColorType = 4
)

var ColorType_name = map[int32]string{
	0: "DEFAULT",
	1: "COLOR_TEXT",
	2: "COLOR_HEX",
	3: "COLOR_PATTERN",
	4: "COLOR_IMAGE",
}
var ColorType_value = map[string]int32{
	"DEFAULT":       0,
	"COLOR_TEXT":    1,
	"COLOR_HEX":     2,
	"COLOR_PATTERN": 3,
	"COLOR_IMAGE":   4,
}

func (x ColorType) String() string {
	return proto.EnumName(ColorType_name, int32(x))
}
func (ColorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{0}
}

type Filters_IsBoolInt int32

const (
	Filters_IS_ALL   Filters_IsBoolInt = 0
	Filters_IS_TRUE  Filters_IsBoolInt = 1
	Filters_IS_FALSE Filters_IsBoolInt = 2
)

var Filters_IsBoolInt_name = map[int32]string{
	0: "IS_ALL",
	1: "IS_TRUE",
	2: "IS_FALSE",
}
var Filters_IsBoolInt_value = map[string]int32{
	"IS_ALL":   0,
	"IS_TRUE":  1,
	"IS_FALSE": 2,
}

func (x Filters_IsBoolInt) String() string {
	return proto.EnumName(Filters_IsBoolInt_name, int32(x))
}
func (Filters_IsBoolInt) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{12, 0}
}

type CountRequest_IsBoolInt int32

const (
	CountRequest_IS_ALL   CountRequest_IsBoolInt = 0
	CountRequest_IS_TRUE  CountRequest_IsBoolInt = 1
	CountRequest_IS_FALSE CountRequest_IsBoolInt = 2
)

var CountRequest_IsBoolInt_name = map[int32]string{
	0: "IS_ALL",
	1: "IS_TRUE",
	2: "IS_FALSE",
}
var CountRequest_IsBoolInt_value = map[string]int32{
	"IS_ALL":   0,
	"IS_TRUE":  1,
	"IS_FALSE": 2,
}

func (x CountRequest_IsBoolInt) String() string {
	return proto.EnumName(CountRequest_IsBoolInt_name, int32(x))
}
func (CountRequest_IsBoolInt) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{26, 0}
}

type ProductDataConfiguration_DataSource int32

const (
	ProductDataConfiguration_DEFAULT ProductDataConfiguration_DataSource = 0
	ProductDataConfiguration_ES      ProductDataConfiguration_DataSource = 1
	ProductDataConfiguration_CORE    ProductDataConfiguration_DataSource = 2
)

var ProductDataConfiguration_DataSource_name = map[int32]string{
	0: "DEFAULT",
	1: "ES",
	2: "CORE",
}
var ProductDataConfiguration_DataSource_value = map[string]int32{
	"DEFAULT": 0,
	"ES":      1,
	"CORE":    2,
}

func (x ProductDataConfiguration_DataSource) String() string {
	return proto.EnumName(ProductDataConfiguration_DataSource_name, int32(x))
}
func (ProductDataConfiguration_DataSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{63, 0}
}

type UpdateByRequest struct {
	UpdateBy             *UpdateBy        `protobuf:"bytes,1,opt,name=update_by,json=updateBy" json:"update_by,omitempty"`
	Product              *UpdateByFields  `protobuf:"bytes,2,opt,name=product" json:"product,omitempty"`
	Fields               *types.FieldMask `protobuf:"bytes,3,opt,name=fields" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpdateByRequest) Reset()         { *m = UpdateByRequest{} }
func (m *UpdateByRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateByRequest) ProtoMessage()    {}
func (*UpdateByRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{0}
}
func (m *UpdateByRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateByRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateByRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateByRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateByRequest.Merge(dst, src)
}
func (m *UpdateByRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateByRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateByRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateByRequest proto.InternalMessageInfo

func (m *UpdateByRequest) GetUpdateBy() *UpdateBy {
	if m != nil {
		return m.UpdateBy
	}
	return nil
}

func (m *UpdateByRequest) GetProduct() *UpdateByFields {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *UpdateByRequest) GetFields() *types.FieldMask {
	if m != nil {
		return m.Fields
	}
	return nil
}

type UpdateTypeShopMallRequest struct {
	UpdateType           uint32   `protobuf:"varint,1,opt,name=update_type,json=updated_type,proto3" json:"update_type,omitempty"`
	UpdatedUser          string   `protobuf:"bytes,2,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	ReasonReject         *Reason  `protobuf:"bytes,3,opt,name=reason_reject" json:"reason_reject,omitempty"`
	ReasonCancel         *Reason  `protobuf:"bytes,4,opt,name=reason_cancel" json:"reason_cancel,omitempty"`
	SellerAdminId        uint32   `protobuf:"varint,5,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTypeShopMallRequest) Reset()         { *m = UpdateTypeShopMallRequest{} }
func (m *UpdateTypeShopMallRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTypeShopMallRequest) ProtoMessage()    {}
func (*UpdateTypeShopMallRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{1}
}
func (m *UpdateTypeShopMallRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTypeShopMallRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTypeShopMallRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateTypeShopMallRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTypeShopMallRequest.Merge(dst, src)
}
func (m *UpdateTypeShopMallRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTypeShopMallRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTypeShopMallRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTypeShopMallRequest proto.InternalMessageInfo

func (m *UpdateTypeShopMallRequest) GetUpdateType() uint32 {
	if m != nil {
		return m.UpdateType
	}
	return 0
}

func (m *UpdateTypeShopMallRequest) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *UpdateTypeShopMallRequest) GetReasonReject() *Reason {
	if m != nil {
		return m.ReasonReject
	}
	return nil
}

func (m *UpdateTypeShopMallRequest) GetReasonCancel() *Reason {
	if m != nil {
		return m.ReasonCancel
	}
	return nil
}

func (m *UpdateTypeShopMallRequest) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

type Reason struct {
	ReasonCode           string   `protobuf:"bytes,1,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonComment        string   `protobuf:"bytes,2,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Reason) Reset()         { *m = Reason{} }
func (m *Reason) String() string { return proto.CompactTextString(m) }
func (*Reason) ProtoMessage()    {}
func (*Reason) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{2}
}
func (m *Reason) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reason) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reason.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Reason) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reason.Merge(dst, src)
}
func (m *Reason) XXX_Size() int {
	return m.Size()
}
func (m *Reason) XXX_DiscardUnknown() {
	xxx_messageInfo_Reason.DiscardUnknown(m)
}

var xxx_messageInfo_Reason proto.InternalMessageInfo

func (m *Reason) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *Reason) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

type UpdateTypeShopMallResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTypeShopMallResponse) Reset()         { *m = UpdateTypeShopMallResponse{} }
func (m *UpdateTypeShopMallResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTypeShopMallResponse) ProtoMessage()    {}
func (*UpdateTypeShopMallResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{3}
}
func (m *UpdateTypeShopMallResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTypeShopMallResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTypeShopMallResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateTypeShopMallResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTypeShopMallResponse.Merge(dst, src)
}
func (m *UpdateTypeShopMallResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTypeShopMallResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTypeShopMallResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTypeShopMallResponse proto.InternalMessageInfo

type UpdateByResponse struct {
	UpdateBy             *UpdateBy `protobuf:"bytes,1,opt,name=update_by,json=updateBy" json:"update_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UpdateByResponse) Reset()         { *m = UpdateByResponse{} }
func (m *UpdateByResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateByResponse) ProtoMessage()    {}
func (*UpdateByResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{4}
}
func (m *UpdateByResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateByResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateByResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateByResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateByResponse.Merge(dst, src)
}
func (m *UpdateByResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateByResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateByResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateByResponse proto.InternalMessageInfo

func (m *UpdateByResponse) GetUpdateBy() *UpdateBy {
	if m != nil {
		return m.UpdateBy
	}
	return nil
}

type UpdatesRequest struct {
	Data                 []*UpdateRequest `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpdatesRequest) Reset()         { *m = UpdatesRequest{} }
func (m *UpdatesRequest) String() string { return proto.CompactTextString(m) }
func (*UpdatesRequest) ProtoMessage()    {}
func (*UpdatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{5}
}
func (m *UpdatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatesRequest.Merge(dst, src)
}
func (m *UpdatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatesRequest proto.InternalMessageInfo

func (m *UpdatesRequest) GetData() []*UpdateRequest {
	if m != nil {
		return m.Data
	}
	return nil
}

type UpdatesResponse struct {
	List                 []*UpdateResponse `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UpdatesResponse) Reset()         { *m = UpdatesResponse{} }
func (m *UpdatesResponse) String() string { return proto.CompactTextString(m) }
func (*UpdatesResponse) ProtoMessage()    {}
func (*UpdatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{6}
}
func (m *UpdatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatesResponse.Merge(dst, src)
}
func (m *UpdatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatesResponse proto.InternalMessageInfo

func (m *UpdatesResponse) GetList() []*UpdateResponse {
	if m != nil {
		return m.List
	}
	return nil
}

type UpdateRequest struct {
	ProductId            uint32           `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Product              *ProductUpdate   `protobuf:"bytes,2,opt,name=product" json:"product,omitempty"`
	Fields               *types.FieldMask `protobuf:"bytes,3,opt,name=fields" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpdateRequest) Reset()         { *m = UpdateRequest{} }
func (m *UpdateRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateRequest) ProtoMessage()    {}
func (*UpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{7}
}
func (m *UpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRequest.Merge(dst, src)
}
func (m *UpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRequest proto.InternalMessageInfo

func (m *UpdateRequest) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *UpdateRequest) GetProduct() *ProductUpdate {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *UpdateRequest) GetFields() *types.FieldMask {
	if m != nil {
		return m.Fields
	}
	return nil
}

type UpdateResponse struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateResponse) Reset()         { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()    {}
func (*UpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{8}
}
func (m *UpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResponse.Merge(dst, src)
}
func (m *UpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResponse proto.InternalMessageInfo

func (m *UpdateResponse) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type AddRequest struct {
	Data                 *ProductAdd `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AddRequest) Reset()         { *m = AddRequest{} }
func (m *AddRequest) String() string { return proto.CompactTextString(m) }
func (*AddRequest) ProtoMessage()    {}
func (*AddRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{9}
}
func (m *AddRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddRequest.Merge(dst, src)
}
func (m *AddRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddRequest proto.InternalMessageInfo

func (m *AddRequest) GetData() *ProductAdd {
	if m != nil {
		return m.Data
	}
	return nil
}

type AddResponse struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddResponse) Reset()         { *m = AddResponse{} }
func (m *AddResponse) String() string { return proto.CompactTextString(m) }
func (*AddResponse) ProtoMessage()    {}
func (*AddResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{10}
}
func (m *AddResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddResponse.Merge(dst, src)
}
func (m *AddResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddResponse proto.InternalMessageInfo

func (m *AddResponse) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type ListRequest struct {
	Sorts                []string         `protobuf:"bytes,1,rep,name=sorts" json:"sorts,omitempty"`
	Filters              *Filters         `protobuf:"bytes,2,opt,name=filters" json:"filters,omitempty"`
	Pagination           *base.Pagination `protobuf:"bytes,3,opt,name=pagination" json:"pagination,omitempty"`
	MetaData             bool             `protobuf:"varint,4,opt,name=meta_data,json=metaData,proto3" json:"meta_data,omitempty"`
	ProductAll           bool             `protobuf:"varint,5,opt,name=product_all,json=productAll,proto3" json:"product_all,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{11}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(dst, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

func (m *ListRequest) GetSorts() []string {
	if m != nil {
		return m.Sorts
	}
	return nil
}

func (m *ListRequest) GetFilters() *Filters {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *ListRequest) GetPagination() *base.Pagination {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *ListRequest) GetMetaData() bool {
	if m != nil {
		return m.MetaData
	}
	return false
}

func (m *ListRequest) GetProductAll() bool {
	if m != nil {
		return m.ProductAll
	}
	return false
}

type Filters struct {
	CategoryId              uint32            `protobuf:"varint,1,opt,name=category_id,proto3" json:"category_id,omitempty"`
	StatusNew               string            `protobuf:"bytes,2,opt,name=status_new,proto3" json:"status_new,omitempty"`
	StockStatus             int32             `protobuf:"varint,3,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	Name                    string            `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Sku                     string            `protobuf:"bytes,5,opt,name=sku,proto3" json:"sku,omitempty"`
	PriceFrom               float64           `protobuf:"fixed64,6,opt,name=price_from,proto3" json:"price_from,omitempty"`
	PriceTo                 float64           `protobuf:"fixed64,7,opt,name=price_to,proto3" json:"price_to,omitempty"`
	IsPromotion             uint32            `protobuf:"varint,8,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	IsOff                   Filters_IsBoolInt `protobuf:"varint,9,opt,name=is_off,proto3,enum=sendo.v1.api.product.Filters_IsBoolInt" json:"is_off,omitempty"`
	UpdatedDateFrom         int64             `protobuf:"varint,10,opt,name=updated_date_from,proto3" json:"updated_date_from,omitempty"`
	UpdatedDateTo           int64             `protobuf:"varint,11,opt,name=updated_date_to,proto3" json:"updated_date_to,omitempty"`
	ProductIds              string            `protobuf:"bytes,12,opt,name=product_ids,proto3" json:"product_ids,omitempty"`
	FilterType              uint32            `protobuf:"varint,13,opt,name=filter_type,proto3" json:"filter_type,omitempty"`
	Assignee                string            `protobuf:"bytes,14,opt,name=assignee,proto3" json:"assignee,omitempty"`
	ReviewFromDate          int64             `protobuf:"varint,15,opt,name=review_from_date,proto3" json:"review_from_date,omitempty"`
	ReviewToDate            int64             `protobuf:"varint,16,opt,name=review_to_date,proto3" json:"review_to_date,omitempty"`
	Quantity                int32             `protobuf:"varint,17,opt,name=quantity,proto3" json:"quantity,omitempty"`
	IsReview                string            `protobuf:"bytes,18,opt,name=is_review,proto3" json:"is_review,omitempty"`
	IsReviewType            uint32            `protobuf:"varint,19,opt,name=is_review_type,proto3" json:"is_review_type,omitempty"`
	BrandId                 uint32            `protobuf:"varint,20,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	ShopType                string            `protobuf:"bytes,21,opt,name=shop_type,proto3" json:"shop_type,omitempty"`
	Status                  uint32            `protobuf:"varint,22,opt,name=status,proto3" json:"status,omitempty"`
	ShopName                string            `protobuf:"bytes,23,opt,name=shop_name,proto3" json:"shop_name,omitempty"`
	RatingFrom              uint32            `protobuf:"varint,24,opt,name=rating_from,proto3" json:"rating_from,omitempty"`
	RatingTo                uint32            `protobuf:"varint,25,opt,name=rating_to,proto3" json:"rating_to,omitempty"`
	PromotionPercentFrom    uint32            `protobuf:"varint,26,opt,name=promotion_percent_from,proto3" json:"promotion_percent_from,omitempty"`
	PromotionPercentTo      uint32            `protobuf:"varint,27,opt,name=promotion_percent_to,proto3" json:"promotion_percent_to,omitempty"`
	PromotionApp            uint32            `protobuf:"varint,28,opt,name=promotion_app,proto3" json:"promotion_app,omitempty"`
	ShopFreeShipping        uint32            `protobuf:"varint,29,opt,name=shop_free_shipping,proto3" json:"shop_free_shipping,omitempty"`
	IsCertified             Filters_IsBoolInt `protobuf:"varint,30,opt,name=is_certified,proto3,enum=sendo.v1.api.product.Filters_IsBoolInt" json:"is_certified,omitempty"`
	SellerAdminId           string            `protobuf:"bytes,31,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	SkuUser                 string            `protobuf:"bytes,32,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	PromotionStartDate      int64             `protobuf:"varint,33,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionToDate         int64             `protobuf:"varint,34,opt,name=promotion_to_date,proto3" json:"promotion_to_date,omitempty"`
	InsideProductType       string            `protobuf:"bytes,35,opt,name=inside_product_type,proto3" json:"inside_product_type,omitempty"`
	FinalPriceFrom          float64           `protobuf:"fixed64,36,opt,name=final_price_from,proto3" json:"final_price_from,omitempty"`
	FinalPriceTo            float64           `protobuf:"fixed64,37,opt,name=final_price_to,proto3" json:"final_price_to,omitempty"`
	OrderComplete_30From    uint32            `protobuf:"varint,38,opt,name=order_complete_30_from,proto3" json:"order_complete_30_from,omitempty"`
	OrderComplete_30To      uint32            `protobuf:"varint,39,opt,name=order_complete_30_to,proto3" json:"order_complete_30_to,omitempty"`
	HasCertificate          int32             `protobuf:"varint,40,opt,name=has_certificate,proto3" json:"has_certificate,omitempty"`
	Keyword                 string            `protobuf:"bytes,41,opt,name=keyword,proto3" json:"keyword,omitempty"`
	ExtendedShippingPackage int64             `protobuf:"varint,42,opt,name=extended_shipping_package,proto3" json:"extended_shipping_package,omitempty"`
	ProductExternalIds      string            `protobuf:"bytes,43,opt,name=product_external_ids,proto3" json:"product_external_ids,omitempty"`
	IsConfigVariant         Filters_IsBoolInt `protobuf:"varint,44,opt,name=is_config_variant,proto3,enum=sendo.v1.api.product.Filters_IsBoolInt" json:"is_config_variant,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}          `json:"-"`
	XXX_unrecognized        []byte            `json:"-"`
	XXX_sizecache           int32             `json:"-"`
}

func (m *Filters) Reset()         { *m = Filters{} }
func (m *Filters) String() string { return proto.CompactTextString(m) }
func (*Filters) ProtoMessage()    {}
func (*Filters) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{12}
}
func (m *Filters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Filters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filters.Merge(dst, src)
}
func (m *Filters) XXX_Size() int {
	return m.Size()
}
func (m *Filters) XXX_DiscardUnknown() {
	xxx_messageInfo_Filters.DiscardUnknown(m)
}

var xxx_messageInfo_Filters proto.InternalMessageInfo

func (m *Filters) GetCategoryId() uint32 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *Filters) GetStatusNew() string {
	if m != nil {
		return m.StatusNew
	}
	return ""
}

func (m *Filters) GetStockStatus() int32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *Filters) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Filters) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *Filters) GetPriceFrom() float64 {
	if m != nil {
		return m.PriceFrom
	}
	return 0
}

func (m *Filters) GetPriceTo() float64 {
	if m != nil {
		return m.PriceTo
	}
	return 0
}

func (m *Filters) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *Filters) GetIsOff() Filters_IsBoolInt {
	if m != nil {
		return m.IsOff
	}
	return Filters_IS_ALL
}

func (m *Filters) GetUpdatedDateFrom() int64 {
	if m != nil {
		return m.UpdatedDateFrom
	}
	return 0
}

func (m *Filters) GetUpdatedDateTo() int64 {
	if m != nil {
		return m.UpdatedDateTo
	}
	return 0
}

func (m *Filters) GetProductIds() string {
	if m != nil {
		return m.ProductIds
	}
	return ""
}

func (m *Filters) GetFilterType() uint32 {
	if m != nil {
		return m.FilterType
	}
	return 0
}

func (m *Filters) GetAssignee() string {
	if m != nil {
		return m.Assignee
	}
	return ""
}

func (m *Filters) GetReviewFromDate() int64 {
	if m != nil {
		return m.ReviewFromDate
	}
	return 0
}

func (m *Filters) GetReviewToDate() int64 {
	if m != nil {
		return m.ReviewToDate
	}
	return 0
}

func (m *Filters) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Filters) GetIsReview() string {
	if m != nil {
		return m.IsReview
	}
	return ""
}

func (m *Filters) GetIsReviewType() uint32 {
	if m != nil {
		return m.IsReviewType
	}
	return 0
}

func (m *Filters) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *Filters) GetShopType() string {
	if m != nil {
		return m.ShopType
	}
	return ""
}

func (m *Filters) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Filters) GetShopName() string {
	if m != nil {
		return m.ShopName
	}
	return ""
}

func (m *Filters) GetRatingFrom() uint32 {
	if m != nil {
		return m.RatingFrom
	}
	return 0
}

func (m *Filters) GetRatingTo() uint32 {
	if m != nil {
		return m.RatingTo
	}
	return 0
}

func (m *Filters) GetPromotionPercentFrom() uint32 {
	if m != nil {
		return m.PromotionPercentFrom
	}
	return 0
}

func (m *Filters) GetPromotionPercentTo() uint32 {
	if m != nil {
		return m.PromotionPercentTo
	}
	return 0
}

func (m *Filters) GetPromotionApp() uint32 {
	if m != nil {
		return m.PromotionApp
	}
	return 0
}

func (m *Filters) GetShopFreeShipping() uint32 {
	if m != nil {
		return m.ShopFreeShipping
	}
	return 0
}

func (m *Filters) GetIsCertified() Filters_IsBoolInt {
	if m != nil {
		return m.IsCertified
	}
	return Filters_IS_ALL
}

func (m *Filters) GetSellerAdminId() string {
	if m != nil {
		return m.SellerAdminId
	}
	return ""
}

func (m *Filters) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *Filters) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *Filters) GetPromotionToDate() int64 {
	if m != nil {
		return m.PromotionToDate
	}
	return 0
}

func (m *Filters) GetInsideProductType() string {
	if m != nil {
		return m.InsideProductType
	}
	return ""
}

func (m *Filters) GetFinalPriceFrom() float64 {
	if m != nil {
		return m.FinalPriceFrom
	}
	return 0
}

func (m *Filters) GetFinalPriceTo() float64 {
	if m != nil {
		return m.FinalPriceTo
	}
	return 0
}

func (m *Filters) GetOrderComplete_30From() uint32 {
	if m != nil {
		return m.OrderComplete_30From
	}
	return 0
}

func (m *Filters) GetOrderComplete_30To() uint32 {
	if m != nil {
		return m.OrderComplete_30To
	}
	return 0
}

func (m *Filters) GetHasCertificate() int32 {
	if m != nil {
		return m.HasCertificate
	}
	return 0
}

func (m *Filters) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Filters) GetExtendedShippingPackage() int64 {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return 0
}

func (m *Filters) GetProductExternalIds() string {
	if m != nil {
		return m.ProductExternalIds
	}
	return ""
}

func (m *Filters) GetIsConfigVariant() Filters_IsBoolInt {
	if m != nil {
		return m.IsConfigVariant
	}
	return Filters_IS_ALL
}

type ListResponse struct {
	// subset of products, based on pagination
	List                 []*Product `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	MetaData             *MetaData  `protobuf:"bytes,2,opt,name=meta_data" json:"meta_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{13}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(dst, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

func (m *ListResponse) GetList() []*Product {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ListResponse) GetMetaData() *MetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

type Product struct {
	ProductId               uint32                   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Name                    string                   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sku                     string                   `protobuf:"bytes,3,opt,name=sku,proto3" json:"sku,omitempty"`
	Rating                  float32                  `protobuf:"fixed32,4,opt,name=rating,proto3" json:"rating,omitempty"`
	ProductImages           []string                 `protobuf:"bytes,5,rep,name=product_images" json:"product_images,omitempty"`
	Price                   float64                  `protobuf:"fixed64,6,opt,name=price,proto3" json:"price,omitempty"`
	StatusNew               uint32                   `protobuf:"varint,8,opt,name=status_new,proto3" json:"status_new,omitempty"`
	StatusName              string                   `protobuf:"bytes,9,opt,name=status_name,proto3" json:"status_name,omitempty"`
	UpdatedAt               int64                    `protobuf:"varint,10,opt,name=updated_at,proto3" json:"updated_at,omitempty"`
	Attributes              []*Attribute             `protobuf:"bytes,11,rep,name=attributes" json:"attributes,omitempty"`
	StockStatus             uint32                   `protobuf:"varint,12,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	CatPath                 string                   `protobuf:"bytes,13,opt,name=cat_path,proto3" json:"cat_path,omitempty"`
	UpdatedUser             string                   `protobuf:"bytes,14,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	IsReview                bool                     `protobuf:"varint,15,opt,name=is_review,proto3" json:"is_review,omitempty"`
	ReviewDate              int64                    `protobuf:"varint,16,opt,name=review_date,proto3" json:"review_date,omitempty"`
	Assignee                string                   `protobuf:"bytes,17,opt,name=assignee,proto3" json:"assignee,omitempty"`
	ReasonCode              string                   `protobuf:"bytes,18,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ProductCertificate      []*ProductCertificate    `protobuf:"bytes,19,rep,name=product_certificate" json:"product_certificate,omitempty"`
	SellerAdminId           uint32                   `protobuf:"varint,20,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	BrandName               string                   `protobuf:"bytes,21,opt,name=brand_name,proto3" json:"brand_name,omitempty"`
	CategoryName            string                   `protobuf:"bytes,22,opt,name=category_name,proto3" json:"category_name,omitempty"`
	UrlPath                 string                   `protobuf:"bytes,23,opt,name=url_path,proto3" json:"url_path,omitempty"`
	ShopName                string                   `protobuf:"bytes,24,opt,name=shop_name,proto3" json:"shop_name,omitempty"`
	CategoryId              string                   `protobuf:"bytes,25,opt,name=category_id,proto3" json:"category_id,omitempty"`
	FinalPrice              float64                  `protobuf:"fixed64,26,opt,name=final_price,proto3" json:"final_price,omitempty"`
	PromotionPercent        uint32                   `protobuf:"varint,27,opt,name=promotion_percent,proto3" json:"promotion_percent,omitempty"`
	BrandId                 uint32                   `protobuf:"varint,28,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	VersionNo               int64                    `protobuf:"varint,29,opt,name=version_no,proto3" json:"version_no,omitempty"`
	SkuUser                 string                   `protobuf:"bytes,30,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	Weight                  float32                  `protobuf:"fixed32,31,opt,name=weight,proto3" json:"weight,omitempty"`
	IsCertified             uint32                   `protobuf:"varint,32,opt,name=is_certified,proto3" json:"is_certified,omitempty"`
	ShopFreeShipping        uint32                   `protobuf:"varint,33,opt,name=shop_free_shipping,proto3" json:"shop_free_shipping,omitempty"`
	PromotionApp            uint32                   `protobuf:"varint,34,opt,name=promotion_app,proto3" json:"promotion_app,omitempty"`
	OrderComplete_30        uint32                   `protobuf:"varint,35,opt,name=order_complete_30,proto3" json:"order_complete_30,omitempty"`
	ReasonComment           string                   `protobuf:"bytes,36,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	Quantity                uint32                   `protobuf:"varint,37,opt,name=quantity,proto3" json:"quantity,omitempty"`
	IsEnable                bool                     `protobuf:"varint,38,opt,name=is_enable,proto3" json:"is_enable,omitempty"`
	ShopType                uint32                   `protobuf:"varint,39,opt,name=shop_type,proto3" json:"shop_type,omitempty"`
	IsUpdated               uint32                   `protobuf:"varint,40,opt,name=is_updated,proto3" json:"is_updated,omitempty"`
	IsPromotion             uint32                   `protobuf:"varint,41,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	PromotionStartDate      int64                    `protobuf:"varint,42,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionToDate         int64                    `protobuf:"varint,43,opt,name=promotion_to_date,proto3" json:"promotion_to_date,omitempty"`
	SpecialPrice            float64                  `protobuf:"fixed64,44,opt,name=special_price,proto3" json:"special_price,omitempty"`
	RatingPercent           float32                  `protobuf:"fixed32,45,opt,name=rating_percent,proto3" json:"rating_percent,omitempty"`
	CategoryLevels          *CategoryLevels          `protobuf:"bytes,46,opt,name=category_levels" json:"category_levels,omitempty"`
	PromotionNote           string                   `protobuf:"bytes,47,opt,name=promotion_note,proto3" json:"promotion_note,omitempty"`
	UnitType                uint32                   `protobuf:"varint,48,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	CreatedAt               int64                    `protobuf:"varint,49,opt,name=created_at,proto3" json:"created_at,omitempty"`
	IsOff                   bool                     `protobuf:"varint,50,opt,name=is_off,proto3" json:"is_off,omitempty"`
	Vasup                   int64                    `protobuf:"varint,51,opt,name=vasup,proto3" json:"vasup,omitempty"`
	AdminId                 uint32                   `protobuf:"varint,52,opt,name=admin_id,proto3" json:"admin_id,omitempty"`
	LengthProduct           float32                  `protobuf:"fixed32,53,opt,name=length_product,proto3" json:"length_product,omitempty"`
	HeightProduct           float32                  `protobuf:"fixed32,54,opt,name=height_product,proto3" json:"height_product,omitempty"`
	WitdhProduct            float32                  `protobuf:"fixed32,55,opt,name=witdh_product,proto3" json:"witdh_product,omitempty"`
	ProductExternalId       uint32                   `protobuf:"varint,56,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	ShippingImages          string                   `protobuf:"bytes,57,opt,name=shipping_images,proto3" json:"shipping_images,omitempty"`
	ExtendedShippingPackage *ExtendedShippingPackage `protobuf:"bytes,58,opt,name=extended_shipping_package" json:"extended_shipping_package,omitempty"`
	IsConfigVariant         bool                     `protobuf:"varint,59,opt,name=is_config_variant,proto3" json:"is_config_variant,omitempty"`
	PriceMax                float64                  `protobuf:"fixed64,60,opt,name=price_max,proto3" json:"price_max,omitempty"`
	FinalPriceMax           float64                  `protobuf:"fixed64,61,opt,name=final_price_max,proto3" json:"final_price_max,omitempty"`
	TotalVariant            uint32                   `protobuf:"varint,62,opt,name=total_variant,proto3" json:"total_variant,omitempty"`
	IsInvalidVariant        bool                     `protobuf:"varint,63,opt,name=is_invalid_variant,proto3" json:"is_invalid_variant,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{14}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(dst, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *Product) GetRating() float32 {
	if m != nil {
		return m.Rating
	}
	return 0
}

func (m *Product) GetProductImages() []string {
	if m != nil {
		return m.ProductImages
	}
	return nil
}

func (m *Product) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Product) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *Product) GetStatusName() string {
	if m != nil {
		return m.StatusName
	}
	return ""
}

func (m *Product) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *Product) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Product) GetStockStatus() uint32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *Product) GetCatPath() string {
	if m != nil {
		return m.CatPath
	}
	return ""
}

func (m *Product) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *Product) GetIsReview() bool {
	if m != nil {
		return m.IsReview
	}
	return false
}

func (m *Product) GetReviewDate() int64 {
	if m != nil {
		return m.ReviewDate
	}
	return 0
}

func (m *Product) GetAssignee() string {
	if m != nil {
		return m.Assignee
	}
	return ""
}

func (m *Product) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *Product) GetProductCertificate() []*ProductCertificate {
	if m != nil {
		return m.ProductCertificate
	}
	return nil
}

func (m *Product) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *Product) GetBrandName() string {
	if m != nil {
		return m.BrandName
	}
	return ""
}

func (m *Product) GetCategoryName() string {
	if m != nil {
		return m.CategoryName
	}
	return ""
}

func (m *Product) GetUrlPath() string {
	if m != nil {
		return m.UrlPath
	}
	return ""
}

func (m *Product) GetShopName() string {
	if m != nil {
		return m.ShopName
	}
	return ""
}

func (m *Product) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *Product) GetFinalPrice() float64 {
	if m != nil {
		return m.FinalPrice
	}
	return 0
}

func (m *Product) GetPromotionPercent() uint32 {
	if m != nil {
		return m.PromotionPercent
	}
	return 0
}

func (m *Product) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *Product) GetVersionNo() int64 {
	if m != nil {
		return m.VersionNo
	}
	return 0
}

func (m *Product) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *Product) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Product) GetIsCertified() uint32 {
	if m != nil {
		return m.IsCertified
	}
	return 0
}

func (m *Product) GetShopFreeShipping() uint32 {
	if m != nil {
		return m.ShopFreeShipping
	}
	return 0
}

func (m *Product) GetPromotionApp() uint32 {
	if m != nil {
		return m.PromotionApp
	}
	return 0
}

func (m *Product) GetOrderComplete_30() uint32 {
	if m != nil {
		return m.OrderComplete_30
	}
	return 0
}

func (m *Product) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *Product) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Product) GetIsEnable() bool {
	if m != nil {
		return m.IsEnable
	}
	return false
}

func (m *Product) GetShopType() uint32 {
	if m != nil {
		return m.ShopType
	}
	return 0
}

func (m *Product) GetIsUpdated() uint32 {
	if m != nil {
		return m.IsUpdated
	}
	return 0
}

func (m *Product) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *Product) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *Product) GetPromotionToDate() int64 {
	if m != nil {
		return m.PromotionToDate
	}
	return 0
}

func (m *Product) GetSpecialPrice() float64 {
	if m != nil {
		return m.SpecialPrice
	}
	return 0
}

func (m *Product) GetRatingPercent() float32 {
	if m != nil {
		return m.RatingPercent
	}
	return 0
}

func (m *Product) GetCategoryLevels() *CategoryLevels {
	if m != nil {
		return m.CategoryLevels
	}
	return nil
}

func (m *Product) GetPromotionNote() string {
	if m != nil {
		return m.PromotionNote
	}
	return ""
}

func (m *Product) GetUnitType() uint32 {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *Product) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Product) GetIsOff() bool {
	if m != nil {
		return m.IsOff
	}
	return false
}

func (m *Product) GetVasup() int64 {
	if m != nil {
		return m.Vasup
	}
	return 0
}

func (m *Product) GetAdminId() uint32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *Product) GetLengthProduct() float32 {
	if m != nil {
		return m.LengthProduct
	}
	return 0
}

func (m *Product) GetHeightProduct() float32 {
	if m != nil {
		return m.HeightProduct
	}
	return 0
}

func (m *Product) GetWitdhProduct() float32 {
	if m != nil {
		return m.WitdhProduct
	}
	return 0
}

func (m *Product) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

func (m *Product) GetShippingImages() string {
	if m != nil {
		return m.ShippingImages
	}
	return ""
}

func (m *Product) GetExtendedShippingPackage() *ExtendedShippingPackage {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return nil
}

func (m *Product) GetIsConfigVariant() bool {
	if m != nil {
		return m.IsConfigVariant
	}
	return false
}

func (m *Product) GetPriceMax() float64 {
	if m != nil {
		return m.PriceMax
	}
	return 0
}

func (m *Product) GetFinalPriceMax() float64 {
	if m != nil {
		return m.FinalPriceMax
	}
	return 0
}

func (m *Product) GetTotalVariant() uint32 {
	if m != nil {
		return m.TotalVariant
	}
	return 0
}

func (m *Product) GetIsInvalidVariant() bool {
	if m != nil {
		return m.IsInvalidVariant
	}
	return false
}

type ProductAdd struct {
	SellerAdminId           uint32                   `protobuf:"varint,1,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	CategoryIds             []uint32                 `protobuf:"varint,2,rep,packed,name=category_ids" json:"category_ids,omitempty"`
	Name                    string                   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description             string                   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	DescriptionScore        float32                  `protobuf:"fixed32,5,opt,name=description_score,proto3" json:"description_score,omitempty"`
	ShortDescription        string                   `protobuf:"bytes,6,opt,name=short_description,proto3" json:"short_description,omitempty"`
	Weight                  float32                  `protobuf:"fixed32,7,opt,name=weight,proto3" json:"weight,omitempty"`
	LengthProduct           float32                  `protobuf:"fixed32,8,opt,name=length_product,proto3" json:"length_product,omitempty"`
	HeightProduct           float32                  `protobuf:"fixed32,9,opt,name=height_product,proto3" json:"height_product,omitempty"`
	WitdhProduct            float32                  `protobuf:"fixed32,10,opt,name=witdh_product,proto3" json:"witdh_product,omitempty"`
	IsEnable                bool                     `protobuf:"varint,11,opt,name=is_enable,proto3" json:"is_enable,omitempty"`
	SkuUser                 string                   `protobuf:"bytes,12,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	UnitType                uint32                   `protobuf:"varint,13,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	CategoryId              uint32                   `protobuf:"varint,14,opt,name=category_id,proto3" json:"category_id,omitempty"`
	StatusNew               uint32                   `protobuf:"varint,15,opt,name=status_new,proto3" json:"status_new,omitempty"`
	HasOptions              bool                     `protobuf:"varint,16,opt,name=has_options,proto3" json:"has_options,omitempty"`
	StockStatus             uint32                   `protobuf:"varint,17,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	TypeProduct             uint32                   `protobuf:"varint,18,opt,name=type_product,proto3" json:"type_product,omitempty"`
	Quantity                uint32                   `protobuf:"varint,19,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Price                   float64                  `protobuf:"fixed64,20,opt,name=price,proto3" json:"price,omitempty"`
	ProductImages           []string                 `protobuf:"bytes,21,rep,name=product_images" json:"product_images,omitempty"`
	MetaTitle               string                   `protobuf:"bytes,22,opt,name=meta_title,proto3" json:"meta_title,omitempty"`
	MetaKeyword             string                   `protobuf:"bytes,23,opt,name=meta_keyword,proto3" json:"meta_keyword,omitempty"`
	MetaDescription         string                   `protobuf:"bytes,24,opt,name=meta_description,proto3" json:"meta_description,omitempty"`
	TagsKey                 string                   `protobuf:"bytes,25,opt,name=tags_key,proto3" json:"tags_key,omitempty"`
	ProductRelateds         string                   `protobuf:"bytes,26,opt,name=product_relateds,proto3" json:"product_relateds,omitempty"`
	BrandId                 uint32                   `protobuf:"varint,27,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	IsBrand                 uint32                   `protobuf:"varint,28,opt,name=is_brand,proto3" json:"is_brand,omitempty"`
	AdditionalAttributes    *AttributeOptions        `protobuf:"bytes,29,opt,name=additional_attributes" json:"additional_attributes,omitempty"`
	SeoTitle                string                   `protobuf:"bytes,30,opt,name=seo_title,proto3" json:"seo_title,omitempty"`
	SeoKeyword              string                   `protobuf:"bytes,31,opt,name=seo_keyword,proto3" json:"seo_keyword,omitempty"`
	SeoDescription          string                   `protobuf:"bytes,32,opt,name=seo_description,proto3" json:"seo_description,omitempty"`
	SeoScore                uint32                   `protobuf:"varint,33,opt,name=seo_score,proto3" json:"seo_score,omitempty"`
	VideoLink               string                   `protobuf:"bytes,34,opt,name=video_link,proto3" json:"video_link,omitempty"`
	CertificateFile         []*ProductCertificate    `protobuf:"bytes,35,rep,name=certificate_file" json:"certificate_file,omitempty"`
	ShopType                uint32                   `protobuf:"varint,36,opt,name=shop_type,proto3" json:"shop_type,omitempty"`
	CreatedUser             string                   `protobuf:"bytes,37,opt,name=created_user,proto3" json:"created_user,omitempty"`
	Assignee                string                   `protobuf:"bytes,38,opt,name=assignee,proto3" json:"assignee,omitempty"`
	StatusDate              uint64                   `protobuf:"varint,39,opt,name=status_date,proto3" json:"status_date,omitempty"`
	IsReview                bool                     `protobuf:"varint,40,opt,name=is_review,proto3" json:"is_review,omitempty"`
	IsReviewType            uint32                   `protobuf:"varint,41,opt,name=is_review_type,proto3" json:"is_review_type,omitempty"`
	Score                   uint32                   `protobuf:"varint,42,opt,name=score,proto3" json:"score,omitempty"`
	ReasonCode              string                   `protobuf:"bytes,43,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonComment           string                   `protobuf:"bytes,44,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	FilterType              uint32                   `protobuf:"varint,45,opt,name=filter_type,proto3" json:"filter_type,omitempty"`
	IsUpdated               uint32                   `protobuf:"varint,46,opt,name=is_updated,proto3" json:"is_updated,omitempty"`
	IsPromotion             uint32                   `protobuf:"varint,47,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	PromotionStartDate      int64                    `protobuf:"varint,48,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionToDate         int64                    `protobuf:"varint,49,opt,name=promotion_to_date,proto3" json:"promotion_to_date,omitempty"`
	SpecialPrice            float64                  `protobuf:"fixed64,50,opt,name=special_price,proto3" json:"special_price,omitempty"`
	PromotionNote           string                   `protobuf:"bytes,51,opt,name=promotion_note,proto3" json:"promotion_note,omitempty"`
	ExtendedShippingPackage *ExtendedShippingPackage `protobuf:"bytes,52,opt,name=extended_shipping_package" json:"extended_shipping_package,omitempty"`
	Variants                []*Variant               `protobuf:"bytes,53,rep,name=variants" json:"variants,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *ProductAdd) Reset()         { *m = ProductAdd{} }
func (m *ProductAdd) String() string { return proto.CompactTextString(m) }
func (*ProductAdd) ProtoMessage()    {}
func (*ProductAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{15}
}
func (m *ProductAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductAdd.Merge(dst, src)
}
func (m *ProductAdd) XXX_Size() int {
	return m.Size()
}
func (m *ProductAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductAdd.DiscardUnknown(m)
}

var xxx_messageInfo_ProductAdd proto.InternalMessageInfo

func (m *ProductAdd) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *ProductAdd) GetCategoryIds() []uint32 {
	if m != nil {
		return m.CategoryIds
	}
	return nil
}

func (m *ProductAdd) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductAdd) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ProductAdd) GetDescriptionScore() float32 {
	if m != nil {
		return m.DescriptionScore
	}
	return 0
}

func (m *ProductAdd) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *ProductAdd) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *ProductAdd) GetLengthProduct() float32 {
	if m != nil {
		return m.LengthProduct
	}
	return 0
}

func (m *ProductAdd) GetHeightProduct() float32 {
	if m != nil {
		return m.HeightProduct
	}
	return 0
}

func (m *ProductAdd) GetWitdhProduct() float32 {
	if m != nil {
		return m.WitdhProduct
	}
	return 0
}

func (m *ProductAdd) GetIsEnable() bool {
	if m != nil {
		return m.IsEnable
	}
	return false
}

func (m *ProductAdd) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *ProductAdd) GetUnitType() uint32 {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *ProductAdd) GetCategoryId() uint32 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *ProductAdd) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *ProductAdd) GetHasOptions() bool {
	if m != nil {
		return m.HasOptions
	}
	return false
}

func (m *ProductAdd) GetStockStatus() uint32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *ProductAdd) GetTypeProduct() uint32 {
	if m != nil {
		return m.TypeProduct
	}
	return 0
}

func (m *ProductAdd) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *ProductAdd) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductAdd) GetProductImages() []string {
	if m != nil {
		return m.ProductImages
	}
	return nil
}

func (m *ProductAdd) GetMetaTitle() string {
	if m != nil {
		return m.MetaTitle
	}
	return ""
}

func (m *ProductAdd) GetMetaKeyword() string {
	if m != nil {
		return m.MetaKeyword
	}
	return ""
}

func (m *ProductAdd) GetMetaDescription() string {
	if m != nil {
		return m.MetaDescription
	}
	return ""
}

func (m *ProductAdd) GetTagsKey() string {
	if m != nil {
		return m.TagsKey
	}
	return ""
}

func (m *ProductAdd) GetProductRelateds() string {
	if m != nil {
		return m.ProductRelateds
	}
	return ""
}

func (m *ProductAdd) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *ProductAdd) GetIsBrand() uint32 {
	if m != nil {
		return m.IsBrand
	}
	return 0
}

func (m *ProductAdd) GetAdditionalAttributes() *AttributeOptions {
	if m != nil {
		return m.AdditionalAttributes
	}
	return nil
}

func (m *ProductAdd) GetSeoTitle() string {
	if m != nil {
		return m.SeoTitle
	}
	return ""
}

func (m *ProductAdd) GetSeoKeyword() string {
	if m != nil {
		return m.SeoKeyword
	}
	return ""
}

func (m *ProductAdd) GetSeoDescription() string {
	if m != nil {
		return m.SeoDescription
	}
	return ""
}

func (m *ProductAdd) GetSeoScore() uint32 {
	if m != nil {
		return m.SeoScore
	}
	return 0
}

func (m *ProductAdd) GetVideoLink() string {
	if m != nil {
		return m.VideoLink
	}
	return ""
}

func (m *ProductAdd) GetCertificateFile() []*ProductCertificate {
	if m != nil {
		return m.CertificateFile
	}
	return nil
}

func (m *ProductAdd) GetShopType() uint32 {
	if m != nil {
		return m.ShopType
	}
	return 0
}

func (m *ProductAdd) GetCreatedUser() string {
	if m != nil {
		return m.CreatedUser
	}
	return ""
}

func (m *ProductAdd) GetAssignee() string {
	if m != nil {
		return m.Assignee
	}
	return ""
}

func (m *ProductAdd) GetStatusDate() uint64 {
	if m != nil {
		return m.StatusDate
	}
	return 0
}

func (m *ProductAdd) GetIsReview() bool {
	if m != nil {
		return m.IsReview
	}
	return false
}

func (m *ProductAdd) GetIsReviewType() uint32 {
	if m != nil {
		return m.IsReviewType
	}
	return 0
}

func (m *ProductAdd) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ProductAdd) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *ProductAdd) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *ProductAdd) GetFilterType() uint32 {
	if m != nil {
		return m.FilterType
	}
	return 0
}

func (m *ProductAdd) GetIsUpdated() uint32 {
	if m != nil {
		return m.IsUpdated
	}
	return 0
}

func (m *ProductAdd) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *ProductAdd) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *ProductAdd) GetPromotionToDate() int64 {
	if m != nil {
		return m.PromotionToDate
	}
	return 0
}

func (m *ProductAdd) GetSpecialPrice() float64 {
	if m != nil {
		return m.SpecialPrice
	}
	return 0
}

func (m *ProductAdd) GetPromotionNote() string {
	if m != nil {
		return m.PromotionNote
	}
	return ""
}

func (m *ProductAdd) GetExtendedShippingPackage() *ExtendedShippingPackage {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return nil
}

func (m *ProductAdd) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

type ProductUpdate struct {
	Name                    string                   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description             string                   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	DescriptionScore        float32                  `protobuf:"fixed32,5,opt,name=description_score,proto3" json:"description_score,omitempty"`
	ShortDescription        string                   `protobuf:"bytes,6,opt,name=short_description,proto3" json:"short_description,omitempty"`
	Weight                  float32                  `protobuf:"fixed32,7,opt,name=weight,proto3" json:"weight,omitempty"`
	LengthProduct           float32                  `protobuf:"fixed32,8,opt,name=length_product,proto3" json:"length_product,omitempty"`
	HeightProduct           float32                  `protobuf:"fixed32,9,opt,name=height_product,proto3" json:"height_product,omitempty"`
	WitdhProduct            float32                  `protobuf:"fixed32,10,opt,name=witdh_product,proto3" json:"witdh_product,omitempty"`
	SkuUser                 string                   `protobuf:"bytes,12,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	UnitType                uint32                   `protobuf:"varint,13,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	CategoryId              uint32                   `protobuf:"varint,14,opt,name=category_id,proto3" json:"category_id,omitempty"`
	StatusNew               uint32                   `protobuf:"varint,15,opt,name=status_new,proto3" json:"status_new,omitempty"`
	HasOptions              bool                     `protobuf:"varint,16,opt,name=has_options,proto3" json:"has_options,omitempty"`
	StockStatus             uint32                   `protobuf:"varint,17,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	TypeProduct             uint32                   `protobuf:"varint,18,opt,name=type_product,proto3" json:"type_product,omitempty"`
	Quantity                uint32                   `protobuf:"varint,19,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Price                   float64                  `protobuf:"fixed64,20,opt,name=price,proto3" json:"price,omitempty"`
	ProductImages           []string                 `protobuf:"bytes,21,rep,name=product_images" json:"product_images,omitempty"`
	MetaTitle               string                   `protobuf:"bytes,22,opt,name=meta_title,proto3" json:"meta_title,omitempty"`
	MetaKeyword             string                   `protobuf:"bytes,23,opt,name=meta_keyword,proto3" json:"meta_keyword,omitempty"`
	MetaDescription         string                   `protobuf:"bytes,24,opt,name=meta_description,proto3" json:"meta_description,omitempty"`
	TagsKey                 string                   `protobuf:"bytes,25,opt,name=tags_key,proto3" json:"tags_key,omitempty"`
	ProductRelateds         string                   `protobuf:"bytes,26,opt,name=product_relateds,proto3" json:"product_relateds,omitempty"`
	BrandId                 uint32                   `protobuf:"varint,27,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	IsBrand                 uint32                   `protobuf:"varint,28,opt,name=is_brand,proto3" json:"is_brand,omitempty"`
	AdditionalAttributes    *AttributeOptions        `protobuf:"bytes,29,opt,name=additional_attributes" json:"additional_attributes,omitempty"`
	SeoTitle                string                   `protobuf:"bytes,30,opt,name=seo_title,proto3" json:"seo_title,omitempty"`
	SeoKeyword              string                   `protobuf:"bytes,31,opt,name=seo_keyword,proto3" json:"seo_keyword,omitempty"`
	SeoDescription          string                   `protobuf:"bytes,32,opt,name=seo_description,proto3" json:"seo_description,omitempty"`
	SeoScore                uint32                   `protobuf:"varint,33,opt,name=seo_score,proto3" json:"seo_score,omitempty"`
	VideoLink               string                   `protobuf:"bytes,34,opt,name=video_link,proto3" json:"video_link,omitempty"`
	CertificateFile         []*ProductCertificate    `protobuf:"bytes,35,rep,name=certificate_file" json:"certificate_file,omitempty"`
	CreatedUser             string                   `protobuf:"bytes,36,opt,name=created_user,proto3" json:"created_user,omitempty"`
	UpdatedUser             string                   `protobuf:"bytes,37,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	StatusDate              int64                    `protobuf:"varint,38,opt,name=status_date,proto3" json:"status_date,omitempty"`
	IsReview                bool                     `protobuf:"varint,39,opt,name=is_review,proto3" json:"is_review,omitempty"`
	IsReviewType            uint32                   `protobuf:"varint,40,opt,name=is_review_type,proto3" json:"is_review_type,omitempty"`
	Score                   uint32                   `protobuf:"varint,41,opt,name=score,proto3" json:"score,omitempty"`
	ReasonCode              string                   `protobuf:"bytes,42,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonComment           string                   `protobuf:"bytes,43,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	FilterType              uint32                   `protobuf:"varint,44,opt,name=filter_type,proto3" json:"filter_type,omitempty"`
	IsEnable                bool                     `protobuf:"varint,45,opt,name=is_enable,proto3" json:"is_enable,omitempty"`
	Assignee                string                   `protobuf:"bytes,46,opt,name=assignee,proto3" json:"assignee,omitempty"`
	ReviewDate              int64                    `protobuf:"varint,47,opt,name=review_date,proto3" json:"review_date,omitempty"`
	ReasonDescription       string                   `protobuf:"bytes,48,opt,name=reason_description,proto3" json:"reason_description,omitempty"`
	SpecialPrice            float64                  `protobuf:"fixed64,49,opt,name=special_price,proto3" json:"special_price,omitempty"`
	IsPromotion             uint32                   `protobuf:"varint,50,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	IsUpdated               uint32                   `protobuf:"varint,51,opt,name=is_updated,proto3" json:"is_updated,omitempty"`
	PromotionStartDate      int64                    `protobuf:"varint,52,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionToDate         int64                    `protobuf:"varint,53,opt,name=promotion_to_date,proto3" json:"promotion_to_date,omitempty"`
	PromotionNote           string                   `protobuf:"bytes,54,opt,name=promotion_note,proto3" json:"promotion_note,omitempty"`
	CabinetList             []uint32                 `protobuf:"varint,55,rep,packed,name=cabinet_list" json:"cabinet_list,omitempty"`
	ExtendedShippingPackage *ExtendedShippingPackage `protobuf:"bytes,56,opt,name=extended_shipping_package" json:"extended_shipping_package,omitempty"`
	Variants                []*Variant               `protobuf:"bytes,57,rep,name=variants" json:"variants,omitempty"`
	IsShopUpdate            bool                     `protobuf:"varint,58,opt,name=is_shop_update,proto3" json:"is_shop_update,omitempty"`
	IsEvent                 uint32                   `protobuf:"varint,59,opt,name=is_event,proto3" json:"is_event,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *ProductUpdate) Reset()         { *m = ProductUpdate{} }
func (m *ProductUpdate) String() string { return proto.CompactTextString(m) }
func (*ProductUpdate) ProtoMessage()    {}
func (*ProductUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{16}
}
func (m *ProductUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductUpdate.Merge(dst, src)
}
func (m *ProductUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ProductUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ProductUpdate proto.InternalMessageInfo

func (m *ProductUpdate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductUpdate) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ProductUpdate) GetDescriptionScore() float32 {
	if m != nil {
		return m.DescriptionScore
	}
	return 0
}

func (m *ProductUpdate) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *ProductUpdate) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *ProductUpdate) GetLengthProduct() float32 {
	if m != nil {
		return m.LengthProduct
	}
	return 0
}

func (m *ProductUpdate) GetHeightProduct() float32 {
	if m != nil {
		return m.HeightProduct
	}
	return 0
}

func (m *ProductUpdate) GetWitdhProduct() float32 {
	if m != nil {
		return m.WitdhProduct
	}
	return 0
}

func (m *ProductUpdate) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *ProductUpdate) GetUnitType() uint32 {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *ProductUpdate) GetCategoryId() uint32 {
	if m != nil {
		return m.CategoryId
	}
	return 0
}

func (m *ProductUpdate) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *ProductUpdate) GetHasOptions() bool {
	if m != nil {
		return m.HasOptions
	}
	return false
}

func (m *ProductUpdate) GetStockStatus() uint32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *ProductUpdate) GetTypeProduct() uint32 {
	if m != nil {
		return m.TypeProduct
	}
	return 0
}

func (m *ProductUpdate) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *ProductUpdate) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductUpdate) GetProductImages() []string {
	if m != nil {
		return m.ProductImages
	}
	return nil
}

func (m *ProductUpdate) GetMetaTitle() string {
	if m != nil {
		return m.MetaTitle
	}
	return ""
}

func (m *ProductUpdate) GetMetaKeyword() string {
	if m != nil {
		return m.MetaKeyword
	}
	return ""
}

func (m *ProductUpdate) GetMetaDescription() string {
	if m != nil {
		return m.MetaDescription
	}
	return ""
}

func (m *ProductUpdate) GetTagsKey() string {
	if m != nil {
		return m.TagsKey
	}
	return ""
}

func (m *ProductUpdate) GetProductRelateds() string {
	if m != nil {
		return m.ProductRelateds
	}
	return ""
}

func (m *ProductUpdate) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *ProductUpdate) GetIsBrand() uint32 {
	if m != nil {
		return m.IsBrand
	}
	return 0
}

func (m *ProductUpdate) GetAdditionalAttributes() *AttributeOptions {
	if m != nil {
		return m.AdditionalAttributes
	}
	return nil
}

func (m *ProductUpdate) GetSeoTitle() string {
	if m != nil {
		return m.SeoTitle
	}
	return ""
}

func (m *ProductUpdate) GetSeoKeyword() string {
	if m != nil {
		return m.SeoKeyword
	}
	return ""
}

func (m *ProductUpdate) GetSeoDescription() string {
	if m != nil {
		return m.SeoDescription
	}
	return ""
}

func (m *ProductUpdate) GetSeoScore() uint32 {
	if m != nil {
		return m.SeoScore
	}
	return 0
}

func (m *ProductUpdate) GetVideoLink() string {
	if m != nil {
		return m.VideoLink
	}
	return ""
}

func (m *ProductUpdate) GetCertificateFile() []*ProductCertificate {
	if m != nil {
		return m.CertificateFile
	}
	return nil
}

func (m *ProductUpdate) GetCreatedUser() string {
	if m != nil {
		return m.CreatedUser
	}
	return ""
}

func (m *ProductUpdate) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *ProductUpdate) GetStatusDate() int64 {
	if m != nil {
		return m.StatusDate
	}
	return 0
}

func (m *ProductUpdate) GetIsReview() bool {
	if m != nil {
		return m.IsReview
	}
	return false
}

func (m *ProductUpdate) GetIsReviewType() uint32 {
	if m != nil {
		return m.IsReviewType
	}
	return 0
}

func (m *ProductUpdate) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ProductUpdate) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *ProductUpdate) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *ProductUpdate) GetFilterType() uint32 {
	if m != nil {
		return m.FilterType
	}
	return 0
}

func (m *ProductUpdate) GetIsEnable() bool {
	if m != nil {
		return m.IsEnable
	}
	return false
}

func (m *ProductUpdate) GetAssignee() string {
	if m != nil {
		return m.Assignee
	}
	return ""
}

func (m *ProductUpdate) GetReviewDate() int64 {
	if m != nil {
		return m.ReviewDate
	}
	return 0
}

func (m *ProductUpdate) GetReasonDescription() string {
	if m != nil {
		return m.ReasonDescription
	}
	return ""
}

func (m *ProductUpdate) GetSpecialPrice() float64 {
	if m != nil {
		return m.SpecialPrice
	}
	return 0
}

func (m *ProductUpdate) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *ProductUpdate) GetIsUpdated() uint32 {
	if m != nil {
		return m.IsUpdated
	}
	return 0
}

func (m *ProductUpdate) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *ProductUpdate) GetPromotionToDate() int64 {
	if m != nil {
		return m.PromotionToDate
	}
	return 0
}

func (m *ProductUpdate) GetPromotionNote() string {
	if m != nil {
		return m.PromotionNote
	}
	return ""
}

func (m *ProductUpdate) GetCabinetList() []uint32 {
	if m != nil {
		return m.CabinetList
	}
	return nil
}

func (m *ProductUpdate) GetExtendedShippingPackage() *ExtendedShippingPackage {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return nil
}

func (m *ProductUpdate) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *ProductUpdate) GetIsShopUpdate() bool {
	if m != nil {
		return m.IsShopUpdate
	}
	return false
}

func (m *ProductUpdate) GetIsEvent() uint32 {
	if m != nil {
		return m.IsEvent
	}
	return 0
}

type AttributeOptions struct {
	MultiData            []*AttributeOption `protobuf:"bytes,1,rep,name=multi_data" json:"multi_data,omitempty"`
	SingleData           []*AttributeOption `protobuf:"bytes,2,rep,name=single_data" json:"single_data,omitempty"`
	TextData             []*AttributeOption `protobuf:"bytes,3,rep,name=text_data" json:"text_data,omitempty"`
	CustomData           []*CustomAttribute `protobuf:"bytes,4,rep,name=custom_data" json:"custom_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AttributeOptions) Reset()         { *m = AttributeOptions{} }
func (m *AttributeOptions) String() string { return proto.CompactTextString(m) }
func (*AttributeOptions) ProtoMessage()    {}
func (*AttributeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{17}
}
func (m *AttributeOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttributeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeOptions.Merge(dst, src)
}
func (m *AttributeOptions) XXX_Size() int {
	return m.Size()
}
func (m *AttributeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeOptions proto.InternalMessageInfo

func (m *AttributeOptions) GetMultiData() []*AttributeOption {
	if m != nil {
		return m.MultiData
	}
	return nil
}

func (m *AttributeOptions) GetSingleData() []*AttributeOption {
	if m != nil {
		return m.SingleData
	}
	return nil
}

func (m *AttributeOptions) GetTextData() []*AttributeOption {
	if m != nil {
		return m.TextData
	}
	return nil
}

func (m *AttributeOptions) GetCustomData() []*CustomAttribute {
	if m != nil {
		return m.CustomData
	}
	return nil
}

type AttributeOption struct {
	Key                  string            `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []string          `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	Images               map[string]string `protobuf:"bytes,3,rep,name=images" json:"images,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ValueCustom          []*ValueCustom    `protobuf:"bytes,4,rep,name=value_custom" json:"value_custom,omitempty"`
	AttributeId          int64             `protobuf:"varint,5,opt,name=attribute_id,proto3" json:"attribute_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AttributeOption) Reset()         { *m = AttributeOption{} }
func (m *AttributeOption) String() string { return proto.CompactTextString(m) }
func (*AttributeOption) ProtoMessage()    {}
func (*AttributeOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{18}
}
func (m *AttributeOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttributeOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeOption.Merge(dst, src)
}
func (m *AttributeOption) XXX_Size() int {
	return m.Size()
}
func (m *AttributeOption) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeOption.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeOption proto.InternalMessageInfo

func (m *AttributeOption) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AttributeOption) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AttributeOption) GetImages() map[string]string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *AttributeOption) GetValueCustom() []*ValueCustom {
	if m != nil {
		return m.ValueCustom
	}
	return nil
}

func (m *AttributeOption) GetAttributeId() int64 {
	if m != nil {
		return m.AttributeId
	}
	return 0
}

type Attribute struct {
	AttributeId          int64             `protobuf:"varint,1,opt,name=attribute_id,proto3" json:"attribute_id,omitempty"`
	AttributeType        int32             `protobuf:"varint,2,opt,name=attribute_type,proto3" json:"attribute_type,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	ProductOption        string            `protobuf:"bytes,4,opt,name=product_option,proto3" json:"product_option,omitempty"`
	ShowRequired         int32             `protobuf:"varint,5,opt,name=show_required,proto3" json:"show_required,omitempty"`
	Type                 string            `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	AttributeValue       []*AttributeValue `protobuf:"bytes,7,rep,name=attribute_value" json:"attribute_value,omitempty"`
	Code                 string            `protobuf:"bytes,8,opt,name=code,proto3" json:"code,omitempty"`
	IsCustom             bool              `protobuf:"varint,9,opt,name=is_custom,proto3" json:"is_custom,omitempty"`
	IsCheckout           bool              `protobuf:"varint,10,opt,name=is_checkout,proto3" json:"is_checkout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Attribute) Reset()         { *m = Attribute{} }
func (m *Attribute) String() string { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()    {}
func (*Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{19}
}
func (m *Attribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attribute.Merge(dst, src)
}
func (m *Attribute) XXX_Size() int {
	return m.Size()
}
func (m *Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_Attribute proto.InternalMessageInfo

func (m *Attribute) GetAttributeId() int64 {
	if m != nil {
		return m.AttributeId
	}
	return 0
}

func (m *Attribute) GetAttributeType() int32 {
	if m != nil {
		return m.AttributeType
	}
	return 0
}

func (m *Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Attribute) GetProductOption() string {
	if m != nil {
		return m.ProductOption
	}
	return ""
}

func (m *Attribute) GetShowRequired() int32 {
	if m != nil {
		return m.ShowRequired
	}
	return 0
}

func (m *Attribute) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Attribute) GetAttributeValue() []*AttributeValue {
	if m != nil {
		return m.AttributeValue
	}
	return nil
}

func (m *Attribute) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Attribute) GetIsCustom() bool {
	if m != nil {
		return m.IsCustom
	}
	return false
}

func (m *Attribute) GetIsCheckout() bool {
	if m != nil {
		return m.IsCheckout
	}
	return false
}

type CustomAttribute struct {
	IdTemp               int32             `protobuf:"varint,1,opt,name=id_temp,proto3" json:"id_temp,omitempty"`
	Key                  string            `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Name                 string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Value                []*ValueCustom    `protobuf:"bytes,4,rep,name=value" json:"value,omitempty"`
	Images               map[string]string `protobuf:"bytes,5,rep,name=images" json:"images,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Code                 string            `protobuf:"bytes,6,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CustomAttribute) Reset()         { *m = CustomAttribute{} }
func (m *CustomAttribute) String() string { return proto.CompactTextString(m) }
func (*CustomAttribute) ProtoMessage()    {}
func (*CustomAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{20}
}
func (m *CustomAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CustomAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomAttribute.Merge(dst, src)
}
func (m *CustomAttribute) XXX_Size() int {
	return m.Size()
}
func (m *CustomAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_CustomAttribute proto.InternalMessageInfo

func (m *CustomAttribute) GetIdTemp() int32 {
	if m != nil {
		return m.IdTemp
	}
	return 0
}

func (m *CustomAttribute) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CustomAttribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CustomAttribute) GetValue() []*ValueCustom {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CustomAttribute) GetImages() map[string]string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *CustomAttribute) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type ValueCustom struct {
	OptionIdTemp         int32    `protobuf:"varint,1,opt,name=option_id_temp,proto3" json:"option_id_temp,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValueCustom) Reset()         { *m = ValueCustom{} }
func (m *ValueCustom) String() string { return proto.CompactTextString(m) }
func (*ValueCustom) ProtoMessage()    {}
func (*ValueCustom) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{21}
}
func (m *ValueCustom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueCustom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueCustom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValueCustom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueCustom.Merge(dst, src)
}
func (m *ValueCustom) XXX_Size() int {
	return m.Size()
}
func (m *ValueCustom) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueCustom.DiscardUnknown(m)
}

var xxx_messageInfo_ValueCustom proto.InternalMessageInfo

func (m *ValueCustom) GetOptionIdTemp() int32 {
	if m != nil {
		return m.OptionIdTemp
	}
	return 0
}

func (m *ValueCustom) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AttributeValue struct {
	Background           string    `protobuf:"bytes,1,opt,name=background,proto3" json:"background,omitempty"`
	ColorHexRgb          string    `protobuf:"bytes,2,opt,name=color_hex_rgb,proto3" json:"color_hex_rgb,omitempty"`
	Value                string    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Image                string    `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Image_50X50          string    `protobuf:"bytes,5,opt,name=image_50x50,proto3" json:"image_50x50,omitempty"`
	Image_500X500        string    `protobuf:"bytes,6,opt,name=image_500x500,proto3" json:"image_500x500,omitempty"`
	OptionId             int32     `protobuf:"varint,7,opt,name=option_id,proto3" json:"option_id,omitempty"`
	ColorType            ColorType `protobuf:"varint,8,opt,name=color_type,proto3,enum=sendo.v1.api.product.ColorType" json:"color_type,omitempty"`
	IsCustom             bool      `protobuf:"varint,9,opt,name=is_custom,proto3" json:"is_custom,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AttributeValue) Reset()         { *m = AttributeValue{} }
func (m *AttributeValue) String() string { return proto.CompactTextString(m) }
func (*AttributeValue) ProtoMessage()    {}
func (*AttributeValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{22}
}
func (m *AttributeValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttributeValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeValue.Merge(dst, src)
}
func (m *AttributeValue) XXX_Size() int {
	return m.Size()
}
func (m *AttributeValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeValue.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeValue proto.InternalMessageInfo

func (m *AttributeValue) GetBackground() string {
	if m != nil {
		return m.Background
	}
	return ""
}

func (m *AttributeValue) GetColorHexRgb() string {
	if m != nil {
		return m.ColorHexRgb
	}
	return ""
}

func (m *AttributeValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *AttributeValue) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *AttributeValue) GetImage_50X50() string {
	if m != nil {
		return m.Image_50X50
	}
	return ""
}

func (m *AttributeValue) GetImage_500X500() string {
	if m != nil {
		return m.Image_500X500
	}
	return ""
}

func (m *AttributeValue) GetOptionId() int32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

func (m *AttributeValue) GetColorType() ColorType {
	if m != nil {
		return m.ColorType
	}
	return ColorType_DEFAULT
}

func (m *AttributeValue) GetIsCustom() bool {
	if m != nil {
		return m.IsCustom
	}
	return false
}

type ProductCertificate struct {
	FileName             string   `protobuf:"bytes,1,opt,name=file_name,proto3" json:"file_name,omitempty"`
	AttachmentUrl        string   `protobuf:"bytes,2,opt,name=attachment_url,proto3" json:"attachment_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductCertificate) Reset()         { *m = ProductCertificate{} }
func (m *ProductCertificate) String() string { return proto.CompactTextString(m) }
func (*ProductCertificate) ProtoMessage()    {}
func (*ProductCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{23}
}
func (m *ProductCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductCertificate.Merge(dst, src)
}
func (m *ProductCertificate) XXX_Size() int {
	return m.Size()
}
func (m *ProductCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_ProductCertificate proto.InternalMessageInfo

func (m *ProductCertificate) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *ProductCertificate) GetAttachmentUrl() string {
	if m != nil {
		return m.AttachmentUrl
	}
	return ""
}

type UpdateBy struct {
	SellerAdminId        uint32   `protobuf:"varint,1,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	BrandId              uint32   `protobuf:"varint,2,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	CategoryId           []uint32 `protobuf:"varint,3,rep,packed,name=category_id" json:"category_id,omitempty"`
	StatusNew            []uint32 `protobuf:"varint,4,rep,packed,name=status_new" json:"status_new,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateBy) Reset()         { *m = UpdateBy{} }
func (m *UpdateBy) String() string { return proto.CompactTextString(m) }
func (*UpdateBy) ProtoMessage()    {}
func (*UpdateBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{24}
}
func (m *UpdateBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBy.Merge(dst, src)
}
func (m *UpdateBy) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBy) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBy.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBy proto.InternalMessageInfo

func (m *UpdateBy) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *UpdateBy) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *UpdateBy) GetCategoryId() []uint32 {
	if m != nil {
		return m.CategoryId
	}
	return nil
}

func (m *UpdateBy) GetStatusNew() []uint32 {
	if m != nil {
		return m.StatusNew
	}
	return nil
}

type UpdateByFields struct {
	StatusNew            uint32   `protobuf:"varint,1,opt,name=status_new,proto3" json:"status_new,omitempty"`
	ReasonCode           string   `protobuf:"bytes,2,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonComment        string   `protobuf:"bytes,3,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	BrandId              int32    `protobuf:"varint,4,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	UpdatedUser          string   `protobuf:"bytes,5,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateByFields) Reset()         { *m = UpdateByFields{} }
func (m *UpdateByFields) String() string { return proto.CompactTextString(m) }
func (*UpdateByFields) ProtoMessage()    {}
func (*UpdateByFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{25}
}
func (m *UpdateByFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateByFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateByFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateByFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateByFields.Merge(dst, src)
}
func (m *UpdateByFields) XXX_Size() int {
	return m.Size()
}
func (m *UpdateByFields) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateByFields.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateByFields proto.InternalMessageInfo

func (m *UpdateByFields) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *UpdateByFields) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *UpdateByFields) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *UpdateByFields) GetBrandId() int32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *UpdateByFields) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

type CountRequest struct {
	SellerAdminId        uint32                 `protobuf:"varint,1,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	StatusNew            string                 `protobuf:"bytes,2,opt,name=status_new,proto3" json:"status_new,omitempty"`
	IsOff                CountRequest_IsBoolInt `protobuf:"varint,3,opt,name=is_off,proto3,enum=sendo.v1.api.product.CountRequest_IsBoolInt" json:"is_off,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CountRequest) Reset()         { *m = CountRequest{} }
func (m *CountRequest) String() string { return proto.CompactTextString(m) }
func (*CountRequest) ProtoMessage()    {}
func (*CountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{26}
}
func (m *CountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountRequest.Merge(dst, src)
}
func (m *CountRequest) XXX_Size() int {
	return m.Size()
}
func (m *CountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CountRequest proto.InternalMessageInfo

func (m *CountRequest) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *CountRequest) GetStatusNew() string {
	if m != nil {
		return m.StatusNew
	}
	return ""
}

func (m *CountRequest) GetIsOff() CountRequest_IsBoolInt {
	if m != nil {
		return m.IsOff
	}
	return CountRequest_IS_ALL
}

type CountResponse struct {
	Total                int32    `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CountResponse) Reset()         { *m = CountResponse{} }
func (m *CountResponse) String() string { return proto.CompactTextString(m) }
func (*CountResponse) ProtoMessage()    {}
func (*CountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{27}
}
func (m *CountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountResponse.Merge(dst, src)
}
func (m *CountResponse) XXX_Size() int {
	return m.Size()
}
func (m *CountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CountResponse proto.InternalMessageInfo

func (m *CountResponse) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type MetaData struct {
	Total                int32    `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaData) Reset()         { *m = MetaData{} }
func (m *MetaData) String() string { return proto.CompactTextString(m) }
func (*MetaData) ProtoMessage()    {}
func (*MetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{28}
}
func (m *MetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaData.Merge(dst, src)
}
func (m *MetaData) XXX_Size() int {
	return m.Size()
}
func (m *MetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaData.DiscardUnknown(m)
}

var xxx_messageInfo_MetaData proto.InternalMessageInfo

func (m *MetaData) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type GetRequest struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	SellerAdminId        uint32   `protobuf:"varint,2,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	ResetCache           uint32   `protobuf:"varint,3,opt,name=reset_cache,proto3" json:"reset_cache,omitempty"`
	SkuUser              string   `protobuf:"bytes,4,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	ProductExternalId    uint32   `protobuf:"varint,5,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{29}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(dst, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *GetRequest) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *GetRequest) GetResetCache() uint32 {
	if m != nil {
		return m.ResetCache
	}
	return 0
}

func (m *GetRequest) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *GetRequest) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

type GetVariantRequest struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	AttributeHash        string   `protobuf:"bytes,2,opt,name=attribute_hash,proto3" json:"attribute_hash,omitempty"`
	SkuUser              string   `protobuf:"bytes,3,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	Include              string   `protobuf:"bytes,4,opt,name=include,proto3" json:"include,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVariantRequest) Reset()         { *m = GetVariantRequest{} }
func (m *GetVariantRequest) String() string { return proto.CompactTextString(m) }
func (*GetVariantRequest) ProtoMessage()    {}
func (*GetVariantRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{30}
}
func (m *GetVariantRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVariantRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVariantRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetVariantRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVariantRequest.Merge(dst, src)
}
func (m *GetVariantRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVariantRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVariantRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVariantRequest proto.InternalMessageInfo

func (m *GetVariantRequest) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *GetVariantRequest) GetAttributeHash() string {
	if m != nil {
		return m.AttributeHash
	}
	return ""
}

func (m *GetVariantRequest) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *GetVariantRequest) GetInclude() string {
	if m != nil {
		return m.Include
	}
	return ""
}

type UpdateVariantsRequest struct {
	ProductId            uint32           `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	UpdatedUser          string           `protobuf:"bytes,2,opt,name=updated_user,json=updatedUser,proto3" json:"updated_user,omitempty"`
	VersionNo            uint64           `protobuf:"varint,3,opt,name=version_no,json=versionNo,proto3" json:"version_no,omitempty"`
	Fields               *types.FieldMask `protobuf:"bytes,4,opt,name=fields" json:"fields,omitempty"`
	Variants             []*Variant       `protobuf:"bytes,5,rep,name=variants" json:"variants,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpdateVariantsRequest) Reset()         { *m = UpdateVariantsRequest{} }
func (m *UpdateVariantsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateVariantsRequest) ProtoMessage()    {}
func (*UpdateVariantsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{31}
}
func (m *UpdateVariantsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVariantsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVariantsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateVariantsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVariantsRequest.Merge(dst, src)
}
func (m *UpdateVariantsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVariantsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVariantsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVariantsRequest proto.InternalMessageInfo

func (m *UpdateVariantsRequest) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *UpdateVariantsRequest) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *UpdateVariantsRequest) GetVersionNo() uint64 {
	if m != nil {
		return m.VersionNo
	}
	return 0
}

func (m *UpdateVariantsRequest) GetFields() *types.FieldMask {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *UpdateVariantsRequest) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

type UpdateVariantsResponse struct {
	Variants             []*UpdateVariantResponse `protobuf:"bytes,1,rep,name=variants" json:"variants,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UpdateVariantsResponse) Reset()         { *m = UpdateVariantsResponse{} }
func (m *UpdateVariantsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateVariantsResponse) ProtoMessage()    {}
func (*UpdateVariantsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{32}
}
func (m *UpdateVariantsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVariantsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVariantsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateVariantsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVariantsResponse.Merge(dst, src)
}
func (m *UpdateVariantsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVariantsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVariantsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVariantsResponse proto.InternalMessageInfo

func (m *UpdateVariantsResponse) GetVariants() []*UpdateVariantResponse {
	if m != nil {
		return m.Variants
	}
	return nil
}

type UpdateVariantResponse struct {
	AttributeHash        string   `protobuf:"bytes,1,opt,name=attribute_hash,proto3" json:"attribute_hash,omitempty"`
	Error                bool     `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateVariantResponse) Reset()         { *m = UpdateVariantResponse{} }
func (m *UpdateVariantResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateVariantResponse) ProtoMessage()    {}
func (*UpdateVariantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{33}
}
func (m *UpdateVariantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVariantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVariantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateVariantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVariantResponse.Merge(dst, src)
}
func (m *UpdateVariantResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVariantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVariantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVariantResponse proto.InternalMessageInfo

func (m *UpdateVariantResponse) GetAttributeHash() string {
	if m != nil {
		return m.AttributeHash
	}
	return ""
}

func (m *UpdateVariantResponse) GetError() bool {
	if m != nil {
		return m.Error
	}
	return false
}

func (m *UpdateVariantResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type CategoryLevels struct {
	Cat1Id               int32    `protobuf:"varint,1,opt,name=cat1_id,proto3" json:"cat1_id,omitempty"`
	Cat2Id               int32    `protobuf:"varint,2,opt,name=cat2_id,proto3" json:"cat2_id,omitempty"`
	Cat3Id               int32    `protobuf:"varint,3,opt,name=cat3_id,proto3" json:"cat3_id,omitempty"`
	Cat4Id               int32    `protobuf:"varint,4,opt,name=cat4_id,proto3" json:"cat4_id,omitempty"`
	Cat2Name             string   `protobuf:"bytes,5,opt,name=cat2_name,proto3" json:"cat2_name,omitempty"`
	Cat3Name             string   `protobuf:"bytes,6,opt,name=cat3_name,proto3" json:"cat3_name,omitempty"`
	Cat4Name             string   `protobuf:"bytes,7,opt,name=cat4_name,proto3" json:"cat4_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CategoryLevels) Reset()         { *m = CategoryLevels{} }
func (m *CategoryLevels) String() string { return proto.CompactTextString(m) }
func (*CategoryLevels) ProtoMessage()    {}
func (*CategoryLevels) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{34}
}
func (m *CategoryLevels) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryLevels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryLevels.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CategoryLevels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryLevels.Merge(dst, src)
}
func (m *CategoryLevels) XXX_Size() int {
	return m.Size()
}
func (m *CategoryLevels) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryLevels.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryLevels proto.InternalMessageInfo

func (m *CategoryLevels) GetCat1Id() int32 {
	if m != nil {
		return m.Cat1Id
	}
	return 0
}

func (m *CategoryLevels) GetCat2Id() int32 {
	if m != nil {
		return m.Cat2Id
	}
	return 0
}

func (m *CategoryLevels) GetCat3Id() int32 {
	if m != nil {
		return m.Cat3Id
	}
	return 0
}

func (m *CategoryLevels) GetCat4Id() int32 {
	if m != nil {
		return m.Cat4Id
	}
	return 0
}

func (m *CategoryLevels) GetCat2Name() string {
	if m != nil {
		return m.Cat2Name
	}
	return ""
}

func (m *CategoryLevels) GetCat3Name() string {
	if m != nil {
		return m.Cat3Name
	}
	return ""
}

func (m *CategoryLevels) GetCat4Name() string {
	if m != nil {
		return m.Cat4Name
	}
	return ""
}

type ProductVideo struct {
	Link                 string   `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Thumbnail            string   `protobuf:"bytes,2,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductVideo) Reset()         { *m = ProductVideo{} }
func (m *ProductVideo) String() string { return proto.CompactTextString(m) }
func (*ProductVideo) ProtoMessage()    {}
func (*ProductVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{35}
}
func (m *ProductVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductVideo.Merge(dst, src)
}
func (m *ProductVideo) XXX_Size() int {
	return m.Size()
}
func (m *ProductVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductVideo.DiscardUnknown(m)
}

var xxx_messageInfo_ProductVideo proto.InternalMessageInfo

func (m *ProductVideo) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *ProductVideo) GetThumbnail() string {
	if m != nil {
		return m.Thumbnail
	}
	return ""
}

type ProductRelated struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	ProductName          string   `protobuf:"bytes,2,opt,name=product_name,proto3" json:"product_name,omitempty"`
	ProductImage         string   `protobuf:"bytes,3,opt,name=product_image,proto3" json:"product_image,omitempty"`
	SkuUser              string   `protobuf:"bytes,4,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	CategoryName         string   `protobuf:"bytes,5,opt,name=category_name,proto3" json:"category_name,omitempty"`
	SellerAdminId        uint32   `protobuf:"varint,6,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	Price                float32  `protobuf:"fixed32,7,opt,name=price,proto3" json:"price,omitempty"`
	StatusNew            uint32   `protobuf:"varint,8,opt,name=status_new,proto3" json:"status_new,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductRelated) Reset()         { *m = ProductRelated{} }
func (m *ProductRelated) String() string { return proto.CompactTextString(m) }
func (*ProductRelated) ProtoMessage()    {}
func (*ProductRelated) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{36}
}
func (m *ProductRelated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductRelated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductRelated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductRelated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductRelated.Merge(dst, src)
}
func (m *ProductRelated) XXX_Size() int {
	return m.Size()
}
func (m *ProductRelated) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductRelated.DiscardUnknown(m)
}

var xxx_messageInfo_ProductRelated proto.InternalMessageInfo

func (m *ProductRelated) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductRelated) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ProductRelated) GetProductImage() string {
	if m != nil {
		return m.ProductImage
	}
	return ""
}

func (m *ProductRelated) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *ProductRelated) GetCategoryName() string {
	if m != nil {
		return m.CategoryName
	}
	return ""
}

func (m *ProductRelated) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *ProductRelated) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductRelated) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

type ProductDetail struct {
	ProductId               uint32                   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Name                    string                   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	SkuUser                 string                   `protobuf:"bytes,3,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	Price                   float64                  `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	UnitType                uint32                   `protobuf:"varint,5,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	Weight                  float32                  `protobuf:"fixed32,6,opt,name=weight,proto3" json:"weight,omitempty"`
	StockStatus             uint32                   `protobuf:"varint,7,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	Description             string                   `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	VersionNo               int64                    `protobuf:"varint,9,opt,name=version_no,proto3" json:"version_no,omitempty"`
	CategoryId              string                   `protobuf:"bytes,10,opt,name=category_id,proto3" json:"category_id,omitempty"`
	CategoryLevels          *CategoryLevels          `protobuf:"bytes,11,opt,name=category_levels" json:"category_levels,omitempty"`
	StatusNew               uint32                   `protobuf:"varint,12,opt,name=status_new,proto3" json:"status_new,omitempty"`
	ProductImages           []string                 `protobuf:"bytes,13,rep,name=product_images" json:"product_images,omitempty"`
	ReasonComment           string                   `protobuf:"bytes,14,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	TagsKey                 string                   `protobuf:"bytes,15,opt,name=tags_key,proto3" json:"tags_key,omitempty"`
	IsPromotion             uint32                   `protobuf:"varint,16,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	UpdatedAt               int64                    `protobuf:"varint,17,opt,name=updated_at,proto3" json:"updated_at,omitempty"`
	CreatedAt               int64                    `protobuf:"varint,18,opt,name=created_at,proto3" json:"created_at,omitempty"`
	BrandId                 uint32                   `protobuf:"varint,19,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	Quantity                uint32                   `protobuf:"varint,20,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Seo                     string                   `protobuf:"bytes,21,opt,name=seo,proto3" json:"seo,omitempty"`
	SeoTitle                string                   `protobuf:"bytes,22,opt,name=seo_title,proto3" json:"seo_title,omitempty"`
	SeoDescription          string                   `protobuf:"bytes,23,opt,name=seo_description,proto3" json:"seo_description,omitempty"`
	SeoKeyword              string                   `protobuf:"bytes,24,opt,name=seo_keyword,proto3" json:"seo_keyword,omitempty"`
	SeoScore                uint32                   `protobuf:"varint,25,opt,name=seo_score,proto3" json:"seo_score,omitempty"`
	ProductLink             string                   `protobuf:"bytes,26,opt,name=product_link,proto3" json:"product_link,omitempty"`
	HeightProduct           float32                  `protobuf:"fixed32,27,opt,name=height_product,proto3" json:"height_product,omitempty"`
	WitdhProduct            float32                  `protobuf:"fixed32,28,opt,name=witdh_product,proto3" json:"witdh_product,omitempty"`
	LengthProduct           float32                  `protobuf:"fixed32,29,opt,name=length_product,proto3" json:"length_product,omitempty"`
	VideoLink               string                   `protobuf:"bytes,30,opt,name=video_link,proto3" json:"video_link,omitempty"`
	VideoInfo               []*ProductVideo          `protobuf:"bytes,31,rep,name=video_info" json:"video_info,omitempty"`
	ShopType                uint32                   `protobuf:"varint,32,opt,name=shop_type,proto3" json:"shop_type,omitempty"`
	ProductRelateds         []*ProductRelated        `protobuf:"bytes,33,rep,name=product_relateds" json:"product_relateds,omitempty"`
	Cprice                  float64                  `protobuf:"fixed64,34,opt,name=cprice,proto3" json:"cprice,omitempty"`
	SellerAdminId           uint32                   `protobuf:"varint,35,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	Sku                     string                   `protobuf:"bytes,36,opt,name=sku,proto3" json:"sku,omitempty"`
	ProductImage            string                   `protobuf:"bytes,37,opt,name=product_image,proto3" json:"product_image,omitempty"`
	CategoryName            string                   `protobuf:"bytes,38,opt,name=category_name,proto3" json:"category_name,omitempty"`
	SpecialPrice            uint32                   `protobuf:"varint,39,opt,name=special_price,proto3" json:"special_price,omitempty"`
	IsEnable                bool                     `protobuf:"varint,40,opt,name=is_enable,proto3" json:"is_enable,omitempty"`
	ReasonCode              string                   `protobuf:"bytes,41,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonDescription       string                   `protobuf:"bytes,42,opt,name=reason_description,proto3" json:"reason_description,omitempty"`
	BrandName               string                   `protobuf:"bytes,44,opt,name=brand_name,proto3" json:"brand_name,omitempty"`
	IsReview                bool                     `protobuf:"varint,45,opt,name=is_review,proto3" json:"is_review,omitempty"`
	ReviewDate              int64                    `protobuf:"varint,46,opt,name=review_date,proto3" json:"review_date,omitempty"`
	ProductCertificate      []*ProductCertificate    `protobuf:"bytes,47,rep,name=product_certificate" json:"product_certificate,omitempty"`
	UrlPath                 string                   `protobuf:"bytes,48,opt,name=url_path,proto3" json:"url_path,omitempty"`
	UpdatedUser             string                   `protobuf:"bytes,49,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	Assignee                string                   `protobuf:"bytes,50,opt,name=assignee,proto3" json:"assignee,omitempty"`
	Attributes              []*Attribute             `protobuf:"bytes,51,rep,name=attributes" json:"attributes,omitempty"`
	IsOff                   bool                     `protobuf:"varint,52,opt,name=is_off,proto3" json:"is_off,omitempty"`
	PromotionStartDate      int64                    `protobuf:"varint,53,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionToDate         int64                    `protobuf:"varint,54,opt,name=promotion_to_date,proto3" json:"promotion_to_date,omitempty"`
	PromotionNote           string                   `protobuf:"bytes,55,opt,name=promotion_note,proto3" json:"promotion_note,omitempty"`
	ExtendedShippingPackage *ExtendedShippingPackage `protobuf:"bytes,56,opt,name=extended_shipping_package" json:"extended_shipping_package,omitempty"`
	IsConfigVariant         bool                     `protobuf:"varint,57,opt,name=is_config_variant,proto3" json:"is_config_variant,omitempty"`
	Variants                []*Variant               `protobuf:"bytes,58,rep,name=variants" json:"variants,omitempty"`
	ProductExternalId       uint32                   `protobuf:"varint,59,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	RatingPercent           float32                  `protobuf:"fixed32,60,opt,name=rating_percent,proto3" json:"rating_percent,omitempty"`
	FinalPrice              float64                  `protobuf:"fixed64,61,opt,name=final_price,proto3" json:"final_price,omitempty"`
	PriceMax                float64                  `protobuf:"fixed64,62,opt,name=price_max,proto3" json:"price_max,omitempty"`
	FinalPriceMax           float64                  `protobuf:"fixed64,63,opt,name=final_price_max,proto3" json:"final_price_max,omitempty"`
	IsInvalidVariant        bool                     `protobuf:"varint,64,opt,name=is_invalid_variant,proto3" json:"is_invalid_variant,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *ProductDetail) Reset()         { *m = ProductDetail{} }
func (m *ProductDetail) String() string { return proto.CompactTextString(m) }
func (*ProductDetail) ProtoMessage()    {}
func (*ProductDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{37}
}
func (m *ProductDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductDetail.Merge(dst, src)
}
func (m *ProductDetail) XXX_Size() int {
	return m.Size()
}
func (m *ProductDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ProductDetail proto.InternalMessageInfo

func (m *ProductDetail) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductDetail) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductDetail) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *ProductDetail) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductDetail) GetUnitType() uint32 {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *ProductDetail) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *ProductDetail) GetStockStatus() uint32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *ProductDetail) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ProductDetail) GetVersionNo() int64 {
	if m != nil {
		return m.VersionNo
	}
	return 0
}

func (m *ProductDetail) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *ProductDetail) GetCategoryLevels() *CategoryLevels {
	if m != nil {
		return m.CategoryLevels
	}
	return nil
}

func (m *ProductDetail) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *ProductDetail) GetProductImages() []string {
	if m != nil {
		return m.ProductImages
	}
	return nil
}

func (m *ProductDetail) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *ProductDetail) GetTagsKey() string {
	if m != nil {
		return m.TagsKey
	}
	return ""
}

func (m *ProductDetail) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *ProductDetail) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *ProductDetail) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *ProductDetail) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *ProductDetail) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *ProductDetail) GetSeo() string {
	if m != nil {
		return m.Seo
	}
	return ""
}

func (m *ProductDetail) GetSeoTitle() string {
	if m != nil {
		return m.SeoTitle
	}
	return ""
}

func (m *ProductDetail) GetSeoDescription() string {
	if m != nil {
		return m.SeoDescription
	}
	return ""
}

func (m *ProductDetail) GetSeoKeyword() string {
	if m != nil {
		return m.SeoKeyword
	}
	return ""
}

func (m *ProductDetail) GetSeoScore() uint32 {
	if m != nil {
		return m.SeoScore
	}
	return 0
}

func (m *ProductDetail) GetProductLink() string {
	if m != nil {
		return m.ProductLink
	}
	return ""
}

func (m *ProductDetail) GetHeightProduct() float32 {
	if m != nil {
		return m.HeightProduct
	}
	return 0
}

func (m *ProductDetail) GetWitdhProduct() float32 {
	if m != nil {
		return m.WitdhProduct
	}
	return 0
}

func (m *ProductDetail) GetLengthProduct() float32 {
	if m != nil {
		return m.LengthProduct
	}
	return 0
}

func (m *ProductDetail) GetVideoLink() string {
	if m != nil {
		return m.VideoLink
	}
	return ""
}

func (m *ProductDetail) GetVideoInfo() []*ProductVideo {
	if m != nil {
		return m.VideoInfo
	}
	return nil
}

func (m *ProductDetail) GetShopType() uint32 {
	if m != nil {
		return m.ShopType
	}
	return 0
}

func (m *ProductDetail) GetProductRelateds() []*ProductRelated {
	if m != nil {
		return m.ProductRelateds
	}
	return nil
}

func (m *ProductDetail) GetCprice() float64 {
	if m != nil {
		return m.Cprice
	}
	return 0
}

func (m *ProductDetail) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *ProductDetail) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *ProductDetail) GetProductImage() string {
	if m != nil {
		return m.ProductImage
	}
	return ""
}

func (m *ProductDetail) GetCategoryName() string {
	if m != nil {
		return m.CategoryName
	}
	return ""
}

func (m *ProductDetail) GetSpecialPrice() uint32 {
	if m != nil {
		return m.SpecialPrice
	}
	return 0
}

func (m *ProductDetail) GetIsEnable() bool {
	if m != nil {
		return m.IsEnable
	}
	return false
}

func (m *ProductDetail) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *ProductDetail) GetReasonDescription() string {
	if m != nil {
		return m.ReasonDescription
	}
	return ""
}

func (m *ProductDetail) GetBrandName() string {
	if m != nil {
		return m.BrandName
	}
	return ""
}

func (m *ProductDetail) GetIsReview() bool {
	if m != nil {
		return m.IsReview
	}
	return false
}

func (m *ProductDetail) GetReviewDate() int64 {
	if m != nil {
		return m.ReviewDate
	}
	return 0
}

func (m *ProductDetail) GetProductCertificate() []*ProductCertificate {
	if m != nil {
		return m.ProductCertificate
	}
	return nil
}

func (m *ProductDetail) GetUrlPath() string {
	if m != nil {
		return m.UrlPath
	}
	return ""
}

func (m *ProductDetail) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *ProductDetail) GetAssignee() string {
	if m != nil {
		return m.Assignee
	}
	return ""
}

func (m *ProductDetail) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ProductDetail) GetIsOff() bool {
	if m != nil {
		return m.IsOff
	}
	return false
}

func (m *ProductDetail) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *ProductDetail) GetPromotionToDate() int64 {
	if m != nil {
		return m.PromotionToDate
	}
	return 0
}

func (m *ProductDetail) GetPromotionNote() string {
	if m != nil {
		return m.PromotionNote
	}
	return ""
}

func (m *ProductDetail) GetExtendedShippingPackage() *ExtendedShippingPackage {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return nil
}

func (m *ProductDetail) GetIsConfigVariant() bool {
	if m != nil {
		return m.IsConfigVariant
	}
	return false
}

func (m *ProductDetail) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *ProductDetail) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

func (m *ProductDetail) GetRatingPercent() float32 {
	if m != nil {
		return m.RatingPercent
	}
	return 0
}

func (m *ProductDetail) GetFinalPrice() float64 {
	if m != nil {
		return m.FinalPrice
	}
	return 0
}

func (m *ProductDetail) GetPriceMax() float64 {
	if m != nil {
		return m.PriceMax
	}
	return 0
}

func (m *ProductDetail) GetFinalPriceMax() float64 {
	if m != nil {
		return m.FinalPriceMax
	}
	return 0
}

func (m *ProductDetail) GetIsInvalidVariant() bool {
	if m != nil {
		return m.IsInvalidVariant
	}
	return false
}

type ProductVariants struct {
	ProductId            uint32       `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Variants             []*Variant   `protobuf:"bytes,2,rep,name=variants" json:"variants,omitempty"`
	Attributes           []*Attribute `protobuf:"bytes,3,rep,name=attributes" json:"attributes,omitempty"`
	SellerAdminId        uint32       `protobuf:"varint,4,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	AdminId              uint32       `protobuf:"varint,5,opt,name=admin_id,proto3" json:"admin_id,omitempty"`
	VersionNo            int64        `protobuf:"varint,6,opt,name=version_no,proto3" json:"version_no,omitempty"`
	IsInvalidVariant     bool         `protobuf:"varint,7,opt,name=is_invalid_variant,proto3" json:"is_invalid_variant,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ProductVariants) Reset()         { *m = ProductVariants{} }
func (m *ProductVariants) String() string { return proto.CompactTextString(m) }
func (*ProductVariants) ProtoMessage()    {}
func (*ProductVariants) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{38}
}
func (m *ProductVariants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductVariants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductVariants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductVariants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductVariants.Merge(dst, src)
}
func (m *ProductVariants) XXX_Size() int {
	return m.Size()
}
func (m *ProductVariants) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductVariants.DiscardUnknown(m)
}

var xxx_messageInfo_ProductVariants proto.InternalMessageInfo

func (m *ProductVariants) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductVariants) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *ProductVariants) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ProductVariants) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *ProductVariants) GetAdminId() uint32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *ProductVariants) GetVersionNo() int64 {
	if m != nil {
		return m.VersionNo
	}
	return 0
}

func (m *ProductVariants) GetIsInvalidVariant() bool {
	if m != nil {
		return m.IsInvalidVariant
	}
	return false
}

type CertificateFilesFilters struct {
	SellerAdminId        uint32   `protobuf:"varint,1,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	CategoryId           string   `protobuf:"bytes,2,opt,name=category_id,proto3" json:"category_id,omitempty"`
	BrandId              uint32   `protobuf:"varint,3,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertificateFilesFilters) Reset()         { *m = CertificateFilesFilters{} }
func (m *CertificateFilesFilters) String() string { return proto.CompactTextString(m) }
func (*CertificateFilesFilters) ProtoMessage()    {}
func (*CertificateFilesFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{39}
}
func (m *CertificateFilesFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateFilesFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateFilesFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CertificateFilesFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateFilesFilters.Merge(dst, src)
}
func (m *CertificateFilesFilters) XXX_Size() int {
	return m.Size()
}
func (m *CertificateFilesFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateFilesFilters.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateFilesFilters proto.InternalMessageInfo

func (m *CertificateFilesFilters) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *CertificateFilesFilters) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *CertificateFilesFilters) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

type GetCertificateRequest struct {
	Filters              *CertificateFilesFilters `protobuf:"bytes,1,opt,name=filters" json:"filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetCertificateRequest) Reset()         { *m = GetCertificateRequest{} }
func (m *GetCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*GetCertificateRequest) ProtoMessage()    {}
func (*GetCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{40}
}
func (m *GetCertificateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCertificateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCertificateRequest.Merge(dst, src)
}
func (m *GetCertificateRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCertificateRequest proto.InternalMessageInfo

func (m *GetCertificateRequest) GetFilters() *CertificateFilesFilters {
	if m != nil {
		return m.Filters
	}
	return nil
}

type CertificateFiles struct {
	List                 []*ProductCertificate `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	ProductId            int32                 `protobuf:"varint,2,opt,name=product_id,proto3" json:"product_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CertificateFiles) Reset()         { *m = CertificateFiles{} }
func (m *CertificateFiles) String() string { return proto.CompactTextString(m) }
func (*CertificateFiles) ProtoMessage()    {}
func (*CertificateFiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{41}
}
func (m *CertificateFiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateFiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateFiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CertificateFiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateFiles.Merge(dst, src)
}
func (m *CertificateFiles) XXX_Size() int {
	return m.Size()
}
func (m *CertificateFiles) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateFiles.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateFiles proto.InternalMessageInfo

func (m *CertificateFiles) GetList() []*ProductCertificate {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *CertificateFiles) GetProductId() int32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type ListHistoryRequest struct {
	ProductId            int32            `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Pagination           *base.Pagination `protobuf:"bytes,2,opt,name=pagination" json:"pagination,omitempty"`
	Status               []int32          `protobuf:"varint,3,rep,packed,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListHistoryRequest) Reset()         { *m = ListHistoryRequest{} }
func (m *ListHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*ListHistoryRequest) ProtoMessage()    {}
func (*ListHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{42}
}
func (m *ListHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHistoryRequest.Merge(dst, src)
}
func (m *ListHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHistoryRequest proto.InternalMessageInfo

func (m *ListHistoryRequest) GetProductId() int32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ListHistoryRequest) GetPagination() *base.Pagination {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *ListHistoryRequest) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

type ListHistoryResponse struct {
	List                 []*ProductHistory `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	MetaData             *MetaData         `protobuf:"bytes,2,opt,name=meta_data" json:"meta_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListHistoryResponse) Reset()         { *m = ListHistoryResponse{} }
func (m *ListHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*ListHistoryResponse) ProtoMessage()    {}
func (*ListHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{43}
}
func (m *ListHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHistoryResponse.Merge(dst, src)
}
func (m *ListHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListHistoryResponse proto.InternalMessageInfo

func (m *ListHistoryResponse) GetList() []*ProductHistory {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ListHistoryResponse) GetMetaData() *MetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

type ProductHistory struct {
	Action                     int32    `protobuf:"varint,1,opt,name=action,proto3" json:"action,omitempty"`
	ProductId                  int32    `protobuf:"varint,2,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Sku                        string   `protobuf:"bytes,3,opt,name=sku,proto3" json:"sku,omitempty"`
	ProductName                string   `protobuf:"bytes,4,opt,name=product_name,proto3" json:"product_name,omitempty"`
	StoreCode                  string   `protobuf:"bytes,5,opt,name=store_code,proto3" json:"store_code,omitempty"`
	StoreName                  string   `protobuf:"bytes,6,opt,name=store_name,proto3" json:"store_name,omitempty"`
	Status                     int32    `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	UpdatedStatus              int32    `protobuf:"varint,8,opt,name=updated_status,proto3" json:"updated_status,omitempty"`
	ReasonCode                 string   `protobuf:"bytes,9,opt,name=reason_code,proto3" json:"reason_code,omitempty"`
	ReasonComment              string   `protobuf:"bytes,10,opt,name=reason_comment,proto3" json:"reason_comment,omitempty"`
	UpdatedUser                string   `protobuf:"bytes,11,opt,name=updated_user,proto3" json:"updated_user,omitempty"`
	UpdatedDate                int64    `protobuf:"varint,12,opt,name=updated_date,proto3" json:"updated_date,omitempty"`
	ReasonName                 string   `protobuf:"bytes,13,opt,name=reason_name,proto3" json:"reason_name,omitempty"`
	DiscountPercent            int32    `protobuf:"varint,14,opt,name=discount_percent,proto3" json:"discount_percent,omitempty"`
	UpdatedDiscountPercent     int32    `protobuf:"varint,15,opt,name=updated_discount_percent,proto3" json:"updated_discount_percent,omitempty"`
	StockAvailability          bool     `protobuf:"varint,16,opt,name=stock_availability,proto3" json:"stock_availability,omitempty"`
	UpdatedStockAvailability   bool     `protobuf:"varint,17,opt,name=updated_stock_availability,proto3" json:"updated_stock_availability,omitempty"`
	Weight                     float32  `protobuf:"fixed32,18,opt,name=weight,proto3" json:"weight,omitempty"`
	UpdatedWeight              float32  `protobuf:"fixed32,20,opt,name=updated_weight,proto3" json:"updated_weight,omitempty"`
	Price                      int64    `protobuf:"varint,21,opt,name=price,proto3" json:"price,omitempty"`
	UpdatedPrice               int64    `protobuf:"varint,22,opt,name=updated_price,proto3" json:"updated_price,omitempty"`
	IsStatusUpdated            bool     `protobuf:"varint,23,opt,name=is_status_updated,proto3" json:"is_status_updated,omitempty"`
	IsDiscountPercentUpdated   bool     `protobuf:"varint,24,opt,name=is_discount_percent_updated,proto3" json:"is_discount_percent_updated,omitempty"`
	IsStockAvailabilityUpdated bool     `protobuf:"varint,25,opt,name=is_stock_availability_updated,proto3" json:"is_stock_availability_updated,omitempty"`
	IsWeightUpdated            bool     `protobuf:"varint,26,opt,name=is_weight_updated,proto3" json:"is_weight_updated,omitempty"`
	IsPriceUpdated             bool     `protobuf:"varint,27,opt,name=is_price_updated,proto3" json:"is_price_updated,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ProductHistory) Reset()         { *m = ProductHistory{} }
func (m *ProductHistory) String() string { return proto.CompactTextString(m) }
func (*ProductHistory) ProtoMessage()    {}
func (*ProductHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{44}
}
func (m *ProductHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductHistory.Merge(dst, src)
}
func (m *ProductHistory) XXX_Size() int {
	return m.Size()
}
func (m *ProductHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ProductHistory proto.InternalMessageInfo

func (m *ProductHistory) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *ProductHistory) GetProductId() int32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductHistory) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *ProductHistory) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ProductHistory) GetStoreCode() string {
	if m != nil {
		return m.StoreCode
	}
	return ""
}

func (m *ProductHistory) GetStoreName() string {
	if m != nil {
		return m.StoreName
	}
	return ""
}

func (m *ProductHistory) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ProductHistory) GetUpdatedStatus() int32 {
	if m != nil {
		return m.UpdatedStatus
	}
	return 0
}

func (m *ProductHistory) GetReasonCode() string {
	if m != nil {
		return m.ReasonCode
	}
	return ""
}

func (m *ProductHistory) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

func (m *ProductHistory) GetUpdatedUser() string {
	if m != nil {
		return m.UpdatedUser
	}
	return ""
}

func (m *ProductHistory) GetUpdatedDate() int64 {
	if m != nil {
		return m.UpdatedDate
	}
	return 0
}

func (m *ProductHistory) GetReasonName() string {
	if m != nil {
		return m.ReasonName
	}
	return ""
}

func (m *ProductHistory) GetDiscountPercent() int32 {
	if m != nil {
		return m.DiscountPercent
	}
	return 0
}

func (m *ProductHistory) GetUpdatedDiscountPercent() int32 {
	if m != nil {
		return m.UpdatedDiscountPercent
	}
	return 0
}

func (m *ProductHistory) GetStockAvailability() bool {
	if m != nil {
		return m.StockAvailability
	}
	return false
}

func (m *ProductHistory) GetUpdatedStockAvailability() bool {
	if m != nil {
		return m.UpdatedStockAvailability
	}
	return false
}

func (m *ProductHistory) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *ProductHistory) GetUpdatedWeight() float32 {
	if m != nil {
		return m.UpdatedWeight
	}
	return 0
}

func (m *ProductHistory) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductHistory) GetUpdatedPrice() int64 {
	if m != nil {
		return m.UpdatedPrice
	}
	return 0
}

func (m *ProductHistory) GetIsStatusUpdated() bool {
	if m != nil {
		return m.IsStatusUpdated
	}
	return false
}

func (m *ProductHistory) GetIsDiscountPercentUpdated() bool {
	if m != nil {
		return m.IsDiscountPercentUpdated
	}
	return false
}

func (m *ProductHistory) GetIsStockAvailabilityUpdated() bool {
	if m != nil {
		return m.IsStockAvailabilityUpdated
	}
	return false
}

func (m *ProductHistory) GetIsWeightUpdated() bool {
	if m != nil {
		return m.IsWeightUpdated
	}
	return false
}

func (m *ProductHistory) GetIsPriceUpdated() bool {
	if m != nil {
		return m.IsPriceUpdated
	}
	return false
}

type UpRequest struct {
	Data                 []*VasUp `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpRequest) Reset()         { *m = UpRequest{} }
func (m *UpRequest) String() string { return proto.CompactTextString(m) }
func (*UpRequest) ProtoMessage()    {}
func (*UpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{45}
}
func (m *UpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpRequest.Merge(dst, src)
}
func (m *UpRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpRequest proto.InternalMessageInfo

func (m *UpRequest) GetData() []*VasUp {
	if m != nil {
		return m.Data
	}
	return nil
}

type UpResponse struct {
	Data                 []*VasUpResponse `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UpResponse) Reset()         { *m = UpResponse{} }
func (m *UpResponse) String() string { return proto.CompactTextString(m) }
func (*UpResponse) ProtoMessage()    {}
func (*UpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{46}
}
func (m *UpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpResponse.Merge(dst, src)
}
func (m *UpResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpResponse proto.InternalMessageInfo

func (m *UpResponse) GetData() []*VasUpResponse {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetRedisByKeyRequest struct {
	Command              string   `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Params               []string `protobuf:"bytes,3,rep,name=params" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRedisByKeyRequest) Reset()         { *m = GetRedisByKeyRequest{} }
func (m *GetRedisByKeyRequest) String() string { return proto.CompactTextString(m) }
func (*GetRedisByKeyRequest) ProtoMessage()    {}
func (*GetRedisByKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{47}
}
func (m *GetRedisByKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRedisByKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRedisByKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRedisByKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRedisByKeyRequest.Merge(dst, src)
}
func (m *GetRedisByKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRedisByKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRedisByKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRedisByKeyRequest proto.InternalMessageInfo

func (m *GetRedisByKeyRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *GetRedisByKeyRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GetRedisByKeyRequest) GetParams() []string {
	if m != nil {
		return m.Params
	}
	return nil
}

type GetRedisByKeyResponse struct {
	Data                 string   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRedisByKeyResponse) Reset()         { *m = GetRedisByKeyResponse{} }
func (m *GetRedisByKeyResponse) String() string { return proto.CompactTextString(m) }
func (*GetRedisByKeyResponse) ProtoMessage()    {}
func (*GetRedisByKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{48}
}
func (m *GetRedisByKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRedisByKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRedisByKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRedisByKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRedisByKeyResponse.Merge(dst, src)
}
func (m *GetRedisByKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRedisByKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRedisByKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRedisByKeyResponse proto.InternalMessageInfo

func (m *GetRedisByKeyResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *GetRedisByKeyResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type VasUp struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	CategoryId           string   `protobuf:"bytes,3,opt,name=category_id,proto3" json:"category_id,omitempty"`
	Position             uint32   `protobuf:"varint,4,opt,name=position,proto3" json:"position,omitempty"`
	TypeUp               uint32   `protobuf:"varint,5,opt,name=type_up,proto3" json:"type_up,omitempty"`
	ProductExternalId    uint32   `protobuf:"varint,6,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VasUp) Reset()         { *m = VasUp{} }
func (m *VasUp) String() string { return proto.CompactTextString(m) }
func (*VasUp) ProtoMessage()    {}
func (*VasUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{49}
}
func (m *VasUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VasUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VasUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VasUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VasUp.Merge(dst, src)
}
func (m *VasUp) XXX_Size() int {
	return m.Size()
}
func (m *VasUp) XXX_DiscardUnknown() {
	xxx_messageInfo_VasUp.DiscardUnknown(m)
}

var xxx_messageInfo_VasUp proto.InternalMessageInfo

func (m *VasUp) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *VasUp) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *VasUp) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *VasUp) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *VasUp) GetTypeUp() uint32 {
	if m != nil {
		return m.TypeUp
	}
	return 0
}

func (m *VasUp) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

type VasUpResponse struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	ProductExternalId    uint32   `protobuf:"varint,3,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VasUpResponse) Reset()         { *m = VasUpResponse{} }
func (m *VasUpResponse) String() string { return proto.CompactTextString(m) }
func (*VasUpResponse) ProtoMessage()    {}
func (*VasUpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{50}
}
func (m *VasUpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VasUpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VasUpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VasUpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VasUpResponse.Merge(dst, src)
}
func (m *VasUpResponse) XXX_Size() int {
	return m.Size()
}
func (m *VasUpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VasUpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VasUpResponse proto.InternalMessageInfo

func (m *VasUpResponse) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *VasUpResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *VasUpResponse) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

type RepushRequest struct {
	ProductIds           []uint32 `protobuf:"varint,1,rep,packed,name=product_ids" json:"product_ids,omitempty"`
	RepushEs             bool     `protobuf:"varint,2,opt,name=repush_es,proto3" json:"repush_es,omitempty"`
	RepushRedis          bool     `protobuf:"varint,3,opt,name=repush_redis,proto3" json:"repush_redis,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepushRequest) Reset()         { *m = RepushRequest{} }
func (m *RepushRequest) String() string { return proto.CompactTextString(m) }
func (*RepushRequest) ProtoMessage()    {}
func (*RepushRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{51}
}
func (m *RepushRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepushRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepushRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepushRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepushRequest.Merge(dst, src)
}
func (m *RepushRequest) XXX_Size() int {
	return m.Size()
}
func (m *RepushRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RepushRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RepushRequest proto.InternalMessageInfo

func (m *RepushRequest) GetProductIds() []uint32 {
	if m != nil {
		return m.ProductIds
	}
	return nil
}

func (m *RepushRequest) GetRepushEs() bool {
	if m != nil {
		return m.RepushEs
	}
	return false
}

func (m *RepushRequest) GetRepushRedis() bool {
	if m != nil {
		return m.RepushRedis
	}
	return false
}

type RepushResponse struct {
	Messages             []string `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepushResponse) Reset()         { *m = RepushResponse{} }
func (m *RepushResponse) String() string { return proto.CompactTextString(m) }
func (*RepushResponse) ProtoMessage()    {}
func (*RepushResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{52}
}
func (m *RepushResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepushResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepushResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepushResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepushResponse.Merge(dst, src)
}
func (m *RepushResponse) XXX_Size() int {
	return m.Size()
}
func (m *RepushResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RepushResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RepushResponse proto.InternalMessageInfo

func (m *RepushResponse) GetMessages() []string {
	if m != nil {
		return m.Messages
	}
	return nil
}

type ExtendedShippingPackage struct {
	IsUsingInstant       bool     `protobuf:"varint,1,opt,name=is_using_instant,proto3" json:"is_using_instant,omitempty"`
	IsUsingInDay         bool     `protobuf:"varint,2,opt,name=is_using_in_day,proto3" json:"is_using_in_day,omitempty"`
	IsSelfShipping       bool     `protobuf:"varint,3,opt,name=is_self_shipping,proto3" json:"is_self_shipping,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtendedShippingPackage) Reset()         { *m = ExtendedShippingPackage{} }
func (m *ExtendedShippingPackage) String() string { return proto.CompactTextString(m) }
func (*ExtendedShippingPackage) ProtoMessage()    {}
func (*ExtendedShippingPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{53}
}
func (m *ExtendedShippingPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendedShippingPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtendedShippingPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExtendedShippingPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendedShippingPackage.Merge(dst, src)
}
func (m *ExtendedShippingPackage) XXX_Size() int {
	return m.Size()
}
func (m *ExtendedShippingPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendedShippingPackage.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendedShippingPackage proto.InternalMessageInfo

func (m *ExtendedShippingPackage) GetIsUsingInstant() bool {
	if m != nil {
		return m.IsUsingInstant
	}
	return false
}

func (m *ExtendedShippingPackage) GetIsUsingInDay() bool {
	if m != nil {
		return m.IsUsingInDay
	}
	return false
}

func (m *ExtendedShippingPackage) GetIsSelfShipping() bool {
	if m != nil {
		return m.IsSelfShipping
	}
	return false
}

type Variant struct {
	Attributes           []*VariantAttribute `protobuf:"bytes,1,rep,name=attributes" json:"attributes,omitempty"`
	AttributeHash        string              `protobuf:"bytes,2,opt,name=attribute_hash,proto3" json:"attribute_hash,omitempty"`
	PromotionStartDate   int64               `protobuf:"varint,3,opt,name=promotion_start_date,proto3" json:"promotion_start_date,omitempty"`
	PromotionEndDate     int64               `protobuf:"varint,4,opt,name=promotion_end_date,proto3" json:"promotion_end_date,omitempty"`
	PromotionPercent     float32             `protobuf:"fixed32,5,opt,name=promotion_percent,proto3" json:"promotion_percent,omitempty"`
	IsPromotion          uint32              `protobuf:"varint,6,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	SkuUser              string              `protobuf:"bytes,7,opt,name=sku_user,proto3" json:"sku_user,omitempty"`
	Price                float64             `protobuf:"fixed64,8,opt,name=price,proto3" json:"price,omitempty"`
	SpecialPrice         float64             `protobuf:"fixed64,9,opt,name=special_price,proto3" json:"special_price,omitempty"`
	FinalPrice           float64             `protobuf:"fixed64,10,opt,name=final_price,proto3" json:"final_price,omitempty"`
	Quantity             int32               `protobuf:"varint,11,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Order                uint32              `protobuf:"varint,12,opt,name=order,proto3" json:"order,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Variant) Reset()         { *m = Variant{} }
func (m *Variant) String() string { return proto.CompactTextString(m) }
func (*Variant) ProtoMessage()    {}
func (*Variant) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{54}
}
func (m *Variant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Variant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Variant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Variant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Variant.Merge(dst, src)
}
func (m *Variant) XXX_Size() int {
	return m.Size()
}
func (m *Variant) XXX_DiscardUnknown() {
	xxx_messageInfo_Variant.DiscardUnknown(m)
}

var xxx_messageInfo_Variant proto.InternalMessageInfo

func (m *Variant) GetAttributes() []*VariantAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Variant) GetAttributeHash() string {
	if m != nil {
		return m.AttributeHash
	}
	return ""
}

func (m *Variant) GetPromotionStartDate() int64 {
	if m != nil {
		return m.PromotionStartDate
	}
	return 0
}

func (m *Variant) GetPromotionEndDate() int64 {
	if m != nil {
		return m.PromotionEndDate
	}
	return 0
}

func (m *Variant) GetPromotionPercent() float32 {
	if m != nil {
		return m.PromotionPercent
	}
	return 0
}

func (m *Variant) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *Variant) GetSkuUser() string {
	if m != nil {
		return m.SkuUser
	}
	return ""
}

func (m *Variant) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Variant) GetSpecialPrice() float64 {
	if m != nil {
		return m.SpecialPrice
	}
	return 0
}

func (m *Variant) GetFinalPrice() float64 {
	if m != nil {
		return m.FinalPrice
	}
	return 0
}

func (m *Variant) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Variant) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

type VariantAttribute struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OptionId             int32    `protobuf:"varint,2,opt,name=option_id,proto3" json:"option_id,omitempty"`
	Code                 string   `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VariantAttribute) Reset()         { *m = VariantAttribute{} }
func (m *VariantAttribute) String() string { return proto.CompactTextString(m) }
func (*VariantAttribute) ProtoMessage()    {}
func (*VariantAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{55}
}
func (m *VariantAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VariantAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VariantAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VariantAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VariantAttribute.Merge(dst, src)
}
func (m *VariantAttribute) XXX_Size() int {
	return m.Size()
}
func (m *VariantAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_VariantAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_VariantAttribute proto.InternalMessageInfo

func (m *VariantAttribute) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *VariantAttribute) GetOptionId() int32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

func (m *VariantAttribute) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type AdsService struct {
	ShopAds              uint32   `protobuf:"varint,1,opt,name=shop_ads,proto3" json:"shop_ads,omitempty"`
	AdPlus               uint32   `protobuf:"varint,2,opt,name=ad_plus,proto3" json:"ad_plus,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdsService) Reset()         { *m = AdsService{} }
func (m *AdsService) String() string { return proto.CompactTextString(m) }
func (*AdsService) ProtoMessage()    {}
func (*AdsService) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{56}
}
func (m *AdsService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdsService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdsService.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AdsService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdsService.Merge(dst, src)
}
func (m *AdsService) XXX_Size() int {
	return m.Size()
}
func (m *AdsService) XXX_DiscardUnknown() {
	xxx_messageInfo_AdsService.DiscardUnknown(m)
}

var xxx_messageInfo_AdsService proto.InternalMessageInfo

func (m *AdsService) GetShopAds() uint32 {
	if m != nil {
		return m.ShopAds
	}
	return 0
}

func (m *AdsService) GetAdPlus() uint32 {
	if m != nil {
		return m.AdPlus
	}
	return 0
}

type GetProductsRequest struct {
	ProductSkus          []*ProductSkuFilters      `protobuf:"bytes,1,rep,name=product_skus" json:"product_skus,omitempty"`
	DataConfig           *ProductDataConfiguration `protobuf:"bytes,2,opt,name=data_config" json:"data_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *GetProductsRequest) Reset()         { *m = GetProductsRequest{} }
func (m *GetProductsRequest) String() string { return proto.CompactTextString(m) }
func (*GetProductsRequest) ProtoMessage()    {}
func (*GetProductsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{57}
}
func (m *GetProductsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProductsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProductsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetProductsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProductsRequest.Merge(dst, src)
}
func (m *GetProductsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetProductsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProductsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetProductsRequest proto.InternalMessageInfo

func (m *GetProductsRequest) GetProductSkus() []*ProductSkuFilters {
	if m != nil {
		return m.ProductSkus
	}
	return nil
}

func (m *GetProductsRequest) GetDataConfig() *ProductDataConfiguration {
	if m != nil {
		return m.DataConfig
	}
	return nil
}

type GetProductsResponse struct {
	Products             []*ProductDetailSku `protobuf:"bytes,8,rep,name=products" json:"products,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetProductsResponse) Reset()         { *m = GetProductsResponse{} }
func (m *GetProductsResponse) String() string { return proto.CompactTextString(m) }
func (*GetProductsResponse) ProtoMessage()    {}
func (*GetProductsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{58}
}
func (m *GetProductsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetProductsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetProductsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetProductsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetProductsResponse.Merge(dst, src)
}
func (m *GetProductsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetProductsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetProductsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetProductsResponse proto.InternalMessageInfo

func (m *GetProductsResponse) GetProducts() []*ProductDetailSku {
	if m != nil {
		return m.Products
	}
	return nil
}

type ProductDetailSku struct {
	ProductId               uint32                        `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	ProductExternalId       uint32                        `protobuf:"varint,2,opt,name=product_external_id,proto3" json:"product_external_id,omitempty"`
	AdminId                 uint32                        `protobuf:"varint,3,opt,name=admin_id,proto3" json:"admin_id,omitempty"`
	SellerAdminId           uint32                        `protobuf:"varint,4,opt,name=seller_admin_id,proto3" json:"seller_admin_id,omitempty"`
	Name                    string                        `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Image                   string                        `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	CatPath                 string                        `protobuf:"bytes,7,opt,name=cat_path,proto3" json:"cat_path,omitempty"`
	CategoryId              string                        `protobuf:"bytes,8,opt,name=category_id,proto3" json:"category_id,omitempty"`
	BrandId                 uint32                        `protobuf:"varint,9,opt,name=brand_id,proto3" json:"brand_id,omitempty"`
	StockStatus             uint32                        `protobuf:"varint,10,opt,name=stock_status,proto3" json:"stock_status,omitempty"`
	StatusNew               uint32                        `protobuf:"varint,11,opt,name=status_new,proto3" json:"status_new,omitempty"`
	Price                   float64                       `protobuf:"fixed64,12,opt,name=price,proto3" json:"price,omitempty"`
	FinalPrice              float64                       `protobuf:"fixed64,13,opt,name=final_price,proto3" json:"final_price,omitempty"`
	IsPromotion             uint32                        `protobuf:"varint,14,opt,name=is_promotion,proto3" json:"is_promotion,omitempty"`
	PromotionPercent        float32                       `protobuf:"fixed32,15,opt,name=promotion_percent,proto3" json:"promotion_percent,omitempty"`
	UnitType                string                        `protobuf:"bytes,16,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	Quantity                uint32                        `protobuf:"varint,17,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Weight                  float32                       `protobuf:"fixed32,18,opt,name=weight,proto3" json:"weight,omitempty"`
	HeightProduct           float32                       `protobuf:"fixed32,19,opt,name=height_product,proto3" json:"height_product,omitempty"`
	WitdhProduct            float32                       `protobuf:"fixed32,20,opt,name=witdh_product,proto3" json:"witdh_product,omitempty"`
	LengthProduct           float32                       `protobuf:"fixed32,21,opt,name=length_product,proto3" json:"length_product,omitempty"`
	Sku                     string                        `protobuf:"bytes,22,opt,name=sku,proto3" json:"sku,omitempty"`
	ProductSkuUser          string                        `protobuf:"bytes,23,opt,name=product_sku_user,proto3" json:"product_sku_user,omitempty"`
	VariantSkuUser          string                        `protobuf:"bytes,24,opt,name=variant_sku_user,proto3" json:"variant_sku_user,omitempty"`
	AttributeHash           string                        `protobuf:"bytes,25,opt,name=attribute_hash,proto3" json:"attribute_hash,omitempty"`
	IsConfigVariant         bool                          `protobuf:"varint,26,opt,name=is_config_variant,proto3" json:"is_config_variant,omitempty"`
	IsValidAttributeHash    bool                          `protobuf:"varint,27,opt,name=is_valid_attribute_hash,proto3" json:"is_valid_attribute_hash,omitempty"`
	Attributes              []*ProductVariationAttributes `protobuf:"bytes,28,rep,name=attributes" json:"attributes,omitempty"`
	ExtendedShippingPackage *ExtendedShippingPackage      `protobuf:"bytes,29,opt,name=extended_shipping_package" json:"extended_shipping_package,omitempty"`
	Promotion               *flashdeal.FlashDeal          `protobuf:"bytes,30,opt,name=promotion" json:"promotion,omitempty"`
	ProductAttributes       []*Attribute                  `protobuf:"bytes,31,rep,name=product_attributes" json:"product_attributes,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                      `json:"-"`
	XXX_unrecognized        []byte                        `json:"-"`
	XXX_sizecache           int32                         `json:"-"`
}

func (m *ProductDetailSku) Reset()         { *m = ProductDetailSku{} }
func (m *ProductDetailSku) String() string { return proto.CompactTextString(m) }
func (*ProductDetailSku) ProtoMessage()    {}
func (*ProductDetailSku) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{59}
}
func (m *ProductDetailSku) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductDetailSku) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductDetailSku.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductDetailSku) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductDetailSku.Merge(dst, src)
}
func (m *ProductDetailSku) XXX_Size() int {
	return m.Size()
}
func (m *ProductDetailSku) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductDetailSku.DiscardUnknown(m)
}

var xxx_messageInfo_ProductDetailSku proto.InternalMessageInfo

func (m *ProductDetailSku) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductDetailSku) GetProductExternalId() uint32 {
	if m != nil {
		return m.ProductExternalId
	}
	return 0
}

func (m *ProductDetailSku) GetAdminId() uint32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *ProductDetailSku) GetSellerAdminId() uint32 {
	if m != nil {
		return m.SellerAdminId
	}
	return 0
}

func (m *ProductDetailSku) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductDetailSku) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ProductDetailSku) GetCatPath() string {
	if m != nil {
		return m.CatPath
	}
	return ""
}

func (m *ProductDetailSku) GetCategoryId() string {
	if m != nil {
		return m.CategoryId
	}
	return ""
}

func (m *ProductDetailSku) GetBrandId() uint32 {
	if m != nil {
		return m.BrandId
	}
	return 0
}

func (m *ProductDetailSku) GetStockStatus() uint32 {
	if m != nil {
		return m.StockStatus
	}
	return 0
}

func (m *ProductDetailSku) GetStatusNew() uint32 {
	if m != nil {
		return m.StatusNew
	}
	return 0
}

func (m *ProductDetailSku) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ProductDetailSku) GetFinalPrice() float64 {
	if m != nil {
		return m.FinalPrice
	}
	return 0
}

func (m *ProductDetailSku) GetIsPromotion() uint32 {
	if m != nil {
		return m.IsPromotion
	}
	return 0
}

func (m *ProductDetailSku) GetPromotionPercent() float32 {
	if m != nil {
		return m.PromotionPercent
	}
	return 0
}

func (m *ProductDetailSku) GetUnitType() string {
	if m != nil {
		return m.UnitType
	}
	return ""
}

func (m *ProductDetailSku) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *ProductDetailSku) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *ProductDetailSku) GetHeightProduct() float32 {
	if m != nil {
		return m.HeightProduct
	}
	return 0
}

func (m *ProductDetailSku) GetWitdhProduct() float32 {
	if m != nil {
		return m.WitdhProduct
	}
	return 0
}

func (m *ProductDetailSku) GetLengthProduct() float32 {
	if m != nil {
		return m.LengthProduct
	}
	return 0
}

func (m *ProductDetailSku) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *ProductDetailSku) GetProductSkuUser() string {
	if m != nil {
		return m.ProductSkuUser
	}
	return ""
}

func (m *ProductDetailSku) GetVariantSkuUser() string {
	if m != nil {
		return m.VariantSkuUser
	}
	return ""
}

func (m *ProductDetailSku) GetAttributeHash() string {
	if m != nil {
		return m.AttributeHash
	}
	return ""
}

func (m *ProductDetailSku) GetIsConfigVariant() bool {
	if m != nil {
		return m.IsConfigVariant
	}
	return false
}

func (m *ProductDetailSku) GetIsValidAttributeHash() bool {
	if m != nil {
		return m.IsValidAttributeHash
	}
	return false
}

func (m *ProductDetailSku) GetAttributes() []*ProductVariationAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ProductDetailSku) GetExtendedShippingPackage() *ExtendedShippingPackage {
	if m != nil {
		return m.ExtendedShippingPackage
	}
	return nil
}

func (m *ProductDetailSku) GetPromotion() *flashdeal.FlashDeal {
	if m != nil {
		return m.Promotion
	}
	return nil
}

func (m *ProductDetailSku) GetProductAttributes() []*Attribute {
	if m != nil {
		return m.ProductAttributes
	}
	return nil
}

type SkuAttributeOption struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,json=attribute_id,proto3" json:"id,omitempty"`
	OptionId             uint32   `protobuf:"varint,2,opt,name=option_id,proto3" json:"option_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkuAttributeOption) Reset()         { *m = SkuAttributeOption{} }
func (m *SkuAttributeOption) String() string { return proto.CompactTextString(m) }
func (*SkuAttributeOption) ProtoMessage()    {}
func (*SkuAttributeOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{60}
}
func (m *SkuAttributeOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkuAttributeOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkuAttributeOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkuAttributeOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkuAttributeOption.Merge(dst, src)
}
func (m *SkuAttributeOption) XXX_Size() int {
	return m.Size()
}
func (m *SkuAttributeOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SkuAttributeOption.DiscardUnknown(m)
}

var xxx_messageInfo_SkuAttributeOption proto.InternalMessageInfo

func (m *SkuAttributeOption) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SkuAttributeOption) GetOptionId() uint32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

type ProductSkuFilters struct {
	ProductId            uint32   `protobuf:"varint,1,opt,name=product_id,proto3" json:"product_id,omitempty"`
	AttributeHash        string   `protobuf:"bytes,2,opt,name=attribute_hash,proto3" json:"attribute_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductSkuFilters) Reset()         { *m = ProductSkuFilters{} }
func (m *ProductSkuFilters) String() string { return proto.CompactTextString(m) }
func (*ProductSkuFilters) ProtoMessage()    {}
func (*ProductSkuFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{61}
}
func (m *ProductSkuFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductSkuFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductSkuFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductSkuFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductSkuFilters.Merge(dst, src)
}
func (m *ProductSkuFilters) XXX_Size() int {
	return m.Size()
}
func (m *ProductSkuFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductSkuFilters.DiscardUnknown(m)
}

var xxx_messageInfo_ProductSkuFilters proto.InternalMessageInfo

func (m *ProductSkuFilters) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *ProductSkuFilters) GetAttributeHash() string {
	if m != nil {
		return m.AttributeHash
	}
	return ""
}

type ProductsFilters struct {
	ProductSkus          []*ProductSkuFilters `protobuf:"bytes,1,rep,name=product_skus" json:"product_skus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ProductsFilters) Reset()         { *m = ProductsFilters{} }
func (m *ProductsFilters) String() string { return proto.CompactTextString(m) }
func (*ProductsFilters) ProtoMessage()    {}
func (*ProductsFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{62}
}
func (m *ProductsFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductsFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductsFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductsFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductsFilters.Merge(dst, src)
}
func (m *ProductsFilters) XXX_Size() int {
	return m.Size()
}
func (m *ProductsFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductsFilters.DiscardUnknown(m)
}

var xxx_messageInfo_ProductsFilters proto.InternalMessageInfo

func (m *ProductsFilters) GetProductSkus() []*ProductSkuFilters {
	if m != nil {
		return m.ProductSkus
	}
	return nil
}

type ProductDataConfiguration struct {
	Source               ProductDataConfiguration_DataSource `protobuf:"varint,1,opt,name=source,proto3,enum=sendo.v1.api.product.ProductDataConfiguration_DataSource" json:"source,omitempty"`
	CheckPromotion       bool                                `protobuf:"varint,2,opt,name=check_promotion,proto3" json:"check_promotion,omitempty"`
	GetProductAttributes bool                                `protobuf:"varint,3,opt,name=get_product_attributes,proto3" json:"get_product_attributes,omitempty"`
	GetFuturePromotion   bool                                `protobuf:"varint,4,opt,name=get_future_promotion,proto3" json:"get_future_promotion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ProductDataConfiguration) Reset()         { *m = ProductDataConfiguration{} }
func (m *ProductDataConfiguration) String() string { return proto.CompactTextString(m) }
func (*ProductDataConfiguration) ProtoMessage()    {}
func (*ProductDataConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{63}
}
func (m *ProductDataConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductDataConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductDataConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductDataConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductDataConfiguration.Merge(dst, src)
}
func (m *ProductDataConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *ProductDataConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductDataConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ProductDataConfiguration proto.InternalMessageInfo

func (m *ProductDataConfiguration) GetSource() ProductDataConfiguration_DataSource {
	if m != nil {
		return m.Source
	}
	return ProductDataConfiguration_DEFAULT
}

func (m *ProductDataConfiguration) GetCheckPromotion() bool {
	if m != nil {
		return m.CheckPromotion
	}
	return false
}

func (m *ProductDataConfiguration) GetGetProductAttributes() bool {
	if m != nil {
		return m.GetProductAttributes
	}
	return false
}

func (m *ProductDataConfiguration) GetGetFuturePromotion() bool {
	if m != nil {
		return m.GetFuturePromotion
	}
	return false
}

type ProductVariationAttributes struct {
	Id                   uint32    `protobuf:"varint,1,opt,name=id,json=attribute_id,proto3" json:"id,omitempty"`
	Name                 string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Code                 string    `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	OptionId             uint32    `protobuf:"varint,4,opt,name=option_id,proto3" json:"option_id,omitempty"`
	OptionValue          string    `protobuf:"bytes,5,opt,name=option_value,proto3" json:"option_value,omitempty"`
	ColorType            ColorType `protobuf:"varint,6,opt,name=color_type,proto3,enum=sendo.v1.api.product.ColorType" json:"color_type,omitempty"`
	ColorValue           string    `protobuf:"bytes,7,opt,name=color_value,proto3" json:"color_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ProductVariationAttributes) Reset()         { *m = ProductVariationAttributes{} }
func (m *ProductVariationAttributes) String() string { return proto.CompactTextString(m) }
func (*ProductVariationAttributes) ProtoMessage()    {}
func (*ProductVariationAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{64}
}
func (m *ProductVariationAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductVariationAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductVariationAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProductVariationAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductVariationAttributes.Merge(dst, src)
}
func (m *ProductVariationAttributes) XXX_Size() int {
	return m.Size()
}
func (m *ProductVariationAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductVariationAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_ProductVariationAttributes proto.InternalMessageInfo

func (m *ProductVariationAttributes) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductVariationAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProductVariationAttributes) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *ProductVariationAttributes) GetOptionId() uint32 {
	if m != nil {
		return m.OptionId
	}
	return 0
}

func (m *ProductVariationAttributes) GetOptionValue() string {
	if m != nil {
		return m.OptionValue
	}
	return ""
}

func (m *ProductVariationAttributes) GetColorType() ColorType {
	if m != nil {
		return m.ColorType
	}
	return ColorType_DEFAULT
}

func (m *ProductVariationAttributes) GetColorValue() string {
	if m != nil {
		return m.ColorValue
	}
	return ""
}

type EsErrorResponse struct {
	RetryNumber          int32    `protobuf:"varint,1,opt,name=retry_number,proto3" json:"retry_number,omitempty"`
	TimeStamp            int64    `protobuf:"varint,2,opt,name=time_stamp,proto3" json:"time_stamp,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	StatusCode           int32    `protobuf:"varint,4,opt,name=status_code,proto3" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EsErrorResponse) Reset()         { *m = EsErrorResponse{} }
func (m *EsErrorResponse) String() string { return proto.CompactTextString(m) }
func (*EsErrorResponse) ProtoMessage()    {}
func (*EsErrorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{65}
}
func (m *EsErrorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EsErrorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EsErrorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EsErrorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EsErrorResponse.Merge(dst, src)
}
func (m *EsErrorResponse) XXX_Size() int {
	return m.Size()
}
func (m *EsErrorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EsErrorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EsErrorResponse proto.InternalMessageInfo

func (m *EsErrorResponse) GetRetryNumber() int32 {
	if m != nil {
		return m.RetryNumber
	}
	return 0
}

func (m *EsErrorResponse) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *EsErrorResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *EsErrorResponse) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type EsReindexLog struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ProductId            uint32             `protobuf:"varint,2,opt,name=product_id,proto3" json:"product_id,omitempty"`
	Error                string             `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	ErrorResponses       []*EsErrorResponse `protobuf:"bytes,4,rep,name=error_responses" json:"error_responses,omitempty"`
	Status               int32              `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	StatusCode           int32              `protobuf:"varint,6,opt,name=status_code,proto3" json:"status_code,omitempty"`
	UpdatedAt            int64              `protobuf:"varint,7,opt,name=updated_at,proto3" json:"updated_at,omitempty"`
	CreatedAt            int64              `protobuf:"varint,8,opt,name=created_at,proto3" json:"created_at,omitempty"`
	RetryCount           uint32             `protobuf:"varint,9,opt,name=retry_count,proto3" json:"retry_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EsReindexLog) Reset()         { *m = EsReindexLog{} }
func (m *EsReindexLog) String() string { return proto.CompactTextString(m) }
func (*EsReindexLog) ProtoMessage()    {}
func (*EsReindexLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{66}
}
func (m *EsReindexLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EsReindexLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EsReindexLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EsReindexLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EsReindexLog.Merge(dst, src)
}
func (m *EsReindexLog) XXX_Size() int {
	return m.Size()
}
func (m *EsReindexLog) XXX_DiscardUnknown() {
	xxx_messageInfo_EsReindexLog.DiscardUnknown(m)
}

var xxx_messageInfo_EsReindexLog proto.InternalMessageInfo

func (m *EsReindexLog) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EsReindexLog) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *EsReindexLog) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *EsReindexLog) GetErrorResponses() []*EsErrorResponse {
	if m != nil {
		return m.ErrorResponses
	}
	return nil
}

func (m *EsReindexLog) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *EsReindexLog) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *EsReindexLog) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *EsReindexLog) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *EsReindexLog) GetRetryCount() uint32 {
	if m != nil {
		return m.RetryCount
	}
	return 0
}

type RepeatedFilter struct {
	Value                []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepeatedFilter) Reset()         { *m = RepeatedFilter{} }
func (m *RepeatedFilter) String() string { return proto.CompactTextString(m) }
func (*RepeatedFilter) ProtoMessage()    {}
func (*RepeatedFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{67}
}
func (m *RepeatedFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepeatedFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepeatedFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepeatedFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepeatedFilter.Merge(dst, src)
}
func (m *RepeatedFilter) XXX_Size() int {
	return m.Size()
}
func (m *RepeatedFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_RepeatedFilter.DiscardUnknown(m)
}

var xxx_messageInfo_RepeatedFilter proto.InternalMessageInfo

func (m *RepeatedFilter) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type EsReindexLogListRequest struct {
	Page                 int32                      `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	Limit                int32                      `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	SortBy               string                     `protobuf:"bytes,3,opt,name=sortBy,proto3" json:"sortBy,omitempty"`
	OrderBy              string                     `protobuf:"bytes,4,opt,name=orderBy,proto3" json:"orderBy,omitempty"`
	Filters              map[string]*RepeatedFilter `protobuf:"bytes,5,rep,name=filters" json:"filters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *EsReindexLogListRequest) Reset()         { *m = EsReindexLogListRequest{} }
func (m *EsReindexLogListRequest) String() string { return proto.CompactTextString(m) }
func (*EsReindexLogListRequest) ProtoMessage()    {}
func (*EsReindexLogListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{68}
}
func (m *EsReindexLogListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EsReindexLogListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EsReindexLogListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EsReindexLogListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EsReindexLogListRequest.Merge(dst, src)
}
func (m *EsReindexLogListRequest) XXX_Size() int {
	return m.Size()
}
func (m *EsReindexLogListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EsReindexLogListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EsReindexLogListRequest proto.InternalMessageInfo

func (m *EsReindexLogListRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *EsReindexLogListRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *EsReindexLogListRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

func (m *EsReindexLogListRequest) GetOrderBy() string {
	if m != nil {
		return m.OrderBy
	}
	return ""
}

func (m *EsReindexLogListRequest) GetFilters() map[string]*RepeatedFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type EsReindexLogListResponse struct {
	Total                int32           `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	TotalPage            int32           `protobuf:"varint,2,opt,name=totalPage,proto3" json:"totalPage,omitempty"`
	CurrentPage          int32           `protobuf:"varint,3,opt,name=currentPage,proto3" json:"currentPage,omitempty"`
	Data                 []*EsReindexLog `protobuf:"bytes,4,rep,name=data" json:"data,omitempty"`
	Size_                int32           `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	NextPage             int32           `protobuf:"varint,6,opt,name=nextPage,proto3" json:"nextPage,omitempty"`
	PrevPage             int32           `protobuf:"varint,7,opt,name=prevPage,proto3" json:"prevPage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EsReindexLogListResponse) Reset()         { *m = EsReindexLogListResponse{} }
func (m *EsReindexLogListResponse) String() string { return proto.CompactTextString(m) }
func (*EsReindexLogListResponse) ProtoMessage()    {}
func (*EsReindexLogListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_product_e20d6eceb1f56627, []int{69}
}
func (m *EsReindexLogListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EsReindexLogListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EsReindexLogListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EsReindexLogListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EsReindexLogListResponse.Merge(dst, src)
}
func (m *EsReindexLogListResponse) XXX_Size() int {
	return m.Size()
}
func (m *EsReindexLogListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EsReindexLogListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EsReindexLogListResponse proto.InternalMessageInfo

func (m *EsReindexLogListResponse) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *EsReindexLogListResponse) GetTotalPage() int32 {
	if m != nil {
		return m.TotalPage
	}
	return 0
}

func (m *EsReindexLogListResponse) GetCurrentPage() int32 {
	if m != nil {
		return m.CurrentPage
	}
	return 0
}

func (m *EsReindexLogListResponse) GetData() []*EsReindexLog {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EsReindexLogListResponse) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *EsReindexLogListResponse) GetNextPage() int32 {
	if m != nil {
		return m.NextPage
	}
	return 0
}

func (m *EsReindexLogListResponse) GetPrevPage() int32 {
	if m != nil {
		return m.PrevPage
	}
	return 0
}

func init() {
	proto.RegisterType((*UpdateByRequest)(nil), "sendo.v1.api.product.UpdateByRequest")
	proto.RegisterType((*UpdateTypeShopMallRequest)(nil), "sendo.v1.api.product.UpdateTypeShopMallRequest")
	proto.RegisterType((*Reason)(nil), "sendo.v1.api.product.Reason")
	proto.RegisterType((*UpdateTypeShopMallResponse)(nil), "sendo.v1.api.product.UpdateTypeShopMallResponse")
	proto.RegisterType((*UpdateByResponse)(nil), "sendo.v1.api.product.UpdateByResponse")
	proto.RegisterType((*UpdatesRequest)(nil), "sendo.v1.api.product.UpdatesRequest")
	proto.RegisterType((*UpdatesResponse)(nil), "sendo.v1.api.product.UpdatesResponse")
	proto.RegisterType((*UpdateRequest)(nil), "sendo.v1.api.product.UpdateRequest")
	proto.RegisterType((*UpdateResponse)(nil), "sendo.v1.api.product.UpdateResponse")
	proto.RegisterType((*AddRequest)(nil), "sendo.v1.api.product.AddRequest")
	proto.RegisterType((*AddResponse)(nil), "sendo.v1.api.product.AddResponse")
	proto.RegisterType((*ListRequest)(nil), "sendo.v1.api.product.ListRequest")
	proto.RegisterType((*Filters)(nil), "sendo.v1.api.product.Filters")
	proto.RegisterType((*ListResponse)(nil), "sendo.v1.api.product.ListResponse")
	proto.RegisterType((*Product)(nil), "sendo.v1.api.product.Product")
	proto.RegisterType((*ProductAdd)(nil), "sendo.v1.api.product.ProductAdd")
	proto.RegisterType((*ProductUpdate)(nil), "sendo.v1.api.product.ProductUpdate")
	proto.RegisterType((*AttributeOptions)(nil), "sendo.v1.api.product.AttributeOptions")
	proto.RegisterType((*AttributeOption)(nil), "sendo.v1.api.product.AttributeOption")
	proto.RegisterMapType((map[string]string)(nil), "sendo.v1.api.product.AttributeOption.ImagesEntry")
	proto.RegisterType((*Attribute)(nil), "sendo.v1.api.product.Attribute")
	proto.RegisterType((*CustomAttribute)(nil), "sendo.v1.api.product.CustomAttribute")
	proto.RegisterMapType((map[string]string)(nil), "sendo.v1.api.product.CustomAttribute.ImagesEntry")
	proto.RegisterType((*ValueCustom)(nil), "sendo.v1.api.product.ValueCustom")
	proto.RegisterType((*AttributeValue)(nil), "sendo.v1.api.product.AttributeValue")
	proto.RegisterType((*ProductCertificate)(nil), "sendo.v1.api.product.Product_certificate")
	proto.RegisterType((*UpdateBy)(nil), "sendo.v1.api.product.UpdateBy")
	proto.RegisterType((*UpdateByFields)(nil), "sendo.v1.api.product.UpdateByFields")
	proto.RegisterType((*CountRequest)(nil), "sendo.v1.api.product.CountRequest")
	proto.RegisterType((*CountResponse)(nil), "sendo.v1.api.product.CountResponse")
	proto.RegisterType((*MetaData)(nil), "sendo.v1.api.product.MetaData")
	proto.RegisterType((*GetRequest)(nil), "sendo.v1.api.product.GetRequest")
	proto.RegisterType((*GetVariantRequest)(nil), "sendo.v1.api.product.GetVariantRequest")
	proto.RegisterType((*UpdateVariantsRequest)(nil), "sendo.v1.api.product.UpdateVariantsRequest")
	proto.RegisterType((*UpdateVariantsResponse)(nil), "sendo.v1.api.product.UpdateVariantsResponse")
	proto.RegisterType((*UpdateVariantResponse)(nil), "sendo.v1.api.product.UpdateVariantResponse")
	proto.RegisterType((*CategoryLevels)(nil), "sendo.v1.api.product.CategoryLevels")
	proto.RegisterType((*ProductVideo)(nil), "sendo.v1.api.product.ProductVideo")
	proto.RegisterType((*ProductRelated)(nil), "sendo.v1.api.product.ProductRelated")
	proto.RegisterType((*ProductDetail)(nil), "sendo.v1.api.product.ProductDetail")
	proto.RegisterType((*ProductVariants)(nil), "sendo.v1.api.product.ProductVariants")
	proto.RegisterType((*CertificateFilesFilters)(nil), "sendo.v1.api.product.CertificateFilesFilters")
	proto.RegisterType((*GetCertificateRequest)(nil), "sendo.v1.api.product.GetCertificateRequest")
	proto.RegisterType((*CertificateFiles)(nil), "sendo.v1.api.product.CertificateFiles")
	proto.RegisterType((*ListHistoryRequest)(nil), "sendo.v1.api.product.ListHistoryRequest")
	proto.RegisterType((*ListHistoryResponse)(nil), "sendo.v1.api.product.ListHistoryResponse")
	proto.RegisterType((*ProductHistory)(nil), "sendo.v1.api.product.ProductHistory")
	proto.RegisterType((*UpRequest)(nil), "sendo.v1.api.product.UpRequest")
	proto.RegisterType((*UpResponse)(nil), "sendo.v1.api.product.UpResponse")
	proto.RegisterType((*GetRedisByKeyRequest)(nil), "sendo.v1.api.product.GetRedisByKeyRequest")
	proto.RegisterType((*GetRedisByKeyResponse)(nil), "sendo.v1.api.product.GetRedisByKeyResponse")
	proto.RegisterType((*VasUp)(nil), "sendo.v1.api.product.VasUp")
	proto.RegisterType((*VasUpResponse)(nil), "sendo.v1.api.product.VasUpResponse")
	proto.RegisterType((*RepushRequest)(nil), "sendo.v1.api.product.RepushRequest")
	proto.RegisterType((*RepushResponse)(nil), "sendo.v1.api.product.RepushResponse")
	proto.RegisterType((*ExtendedShippingPackage)(nil), "sendo.v1.api.product.ExtendedShippingPackage")
	proto.RegisterType((*Variant)(nil), "sendo.v1.api.product.Variant")
	proto.RegisterType((*VariantAttribute)(nil), "sendo.v1.api.product.VariantAttribute")
	proto.RegisterType((*AdsService)(nil), "sendo.v1.api.product.AdsService")
	proto.RegisterType((*GetProductsRequest)(nil), "sendo.v1.api.product.GetProductsRequest")
	proto.RegisterType((*GetProductsResponse)(nil), "sendo.v1.api.product.GetProductsResponse")
	proto.RegisterType((*ProductDetailSku)(nil), "sendo.v1.api.product.ProductDetailSku")
	proto.RegisterType((*SkuAttributeOption)(nil), "sendo.v1.api.product.SkuAttributeOption")
	proto.RegisterType((*ProductSkuFilters)(nil), "sendo.v1.api.product.ProductSkuFilters")
	proto.RegisterType((*ProductsFilters)(nil), "sendo.v1.api.product.ProductsFilters")
	proto.RegisterType((*ProductDataConfiguration)(nil), "sendo.v1.api.product.ProductDataConfiguration")
	proto.RegisterType((*ProductVariationAttributes)(nil), "sendo.v1.api.product.ProductVariationAttributes")
	proto.RegisterType((*EsErrorResponse)(nil), "sendo.v1.api.product.EsErrorResponse")
	proto.RegisterType((*EsReindexLog)(nil), "sendo.v1.api.product.EsReindexLog")
	proto.RegisterType((*RepeatedFilter)(nil), "sendo.v1.api.product.RepeatedFilter")
	proto.RegisterType((*EsReindexLogListRequest)(nil), "sendo.v1.api.product.EsReindexLogListRequest")
	proto.RegisterMapType((map[string]*RepeatedFilter)(nil), "sendo.v1.api.product.EsReindexLogListRequest.FiltersEntry")
	proto.RegisterType((*EsReindexLogListResponse)(nil), "sendo.v1.api.product.EsReindexLogListResponse")
	proto.RegisterEnum("sendo.v1.api.product.ColorType", ColorType_name, ColorType_value)
	proto.RegisterEnum("sendo.v1.api.product.Filters_IsBoolInt", Filters_IsBoolInt_name, Filters_IsBoolInt_value)
	proto.RegisterEnum("sendo.v1.api.product.CountRequest_IsBoolInt", CountRequest_IsBoolInt_name, CountRequest_IsBoolInt_value)
	proto.RegisterEnum("sendo.v1.api.product.ProductDataConfiguration_DataSource", ProductDataConfiguration_DataSource_name, ProductDataConfiguration_DataSource_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ProductServiceClient is the client API for ProductService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProductServiceClient interface {
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error)
	GetEsReindexLogList(ctx context.Context, in *EsReindexLogListRequest, opts ...grpc.CallOption) (*EsReindexLogListResponse, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ProductDetail, error)
	GetVariants(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*ProductVariants, error)
	GetVariant(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*Variant, error)
	UpdateVariants(ctx context.Context, in *UpdateVariantsRequest, opts ...grpc.CallOption) (*UpdateVariantsResponse, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	Updates(ctx context.Context, in *UpdatesRequest, opts ...grpc.CallOption) (*UpdatesResponse, error)
	UpdateBy(ctx context.Context, in *UpdateByRequest, opts ...grpc.CallOption) (*UpdateByResponse, error)
	UpdateTypeShopMall(ctx context.Context, in *UpdateTypeShopMallRequest, opts ...grpc.CallOption) (*UpdateTypeShopMallResponse, error)
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error)
	GetCertificateFiles(ctx context.Context, in *GetCertificateRequest, opts ...grpc.CallOption) (*CertificateFiles, error)
	ListHistory(ctx context.Context, in *ListHistoryRequest, opts ...grpc.CallOption) (*ListHistoryResponse, error)
	Up(ctx context.Context, in *UpRequest, opts ...grpc.CallOption) (*UpResponse, error)
	GetRedisByKey(ctx context.Context, in *GetRedisByKeyRequest, opts ...grpc.CallOption) (*GetRedisByKeyResponse, error)
	RepushProducts(ctx context.Context, in *RepushRequest, opts ...grpc.CallOption) (*RepushResponse, error)
	GetProducts(ctx context.Context, in *GetProductsRequest, opts ...grpc.CallOption) (*GetProductsResponse, error)
}

type productServiceClient struct {
	cc *grpc.ClientConn
}

func NewProductServiceClient(cc *grpc.ClientConn) ProductServiceClient {
	return &productServiceClient{cc}
}

func (c *productServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddResponse, error) {
	out := new(AddResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetEsReindexLogList(ctx context.Context, in *EsReindexLogListRequest, opts ...grpc.CallOption) (*EsReindexLogListResponse, error) {
	out := new(EsReindexLogListResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetEsReindexLogList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ProductDetail, error) {
	out := new(ProductDetail)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetVariants(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*ProductVariants, error) {
	out := new(ProductVariants)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetVariants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetVariant(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*Variant, error) {
	out := new(Variant)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetVariant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) UpdateVariants(ctx context.Context, in *UpdateVariantsRequest, opts ...grpc.CallOption) (*UpdateVariantsResponse, error) {
	out := new(UpdateVariantsResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/UpdateVariants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Updates(ctx context.Context, in *UpdatesRequest, opts ...grpc.CallOption) (*UpdatesResponse, error) {
	out := new(UpdatesResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Updates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) UpdateBy(ctx context.Context, in *UpdateByRequest, opts ...grpc.CallOption) (*UpdateByResponse, error) {
	out := new(UpdateByResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/UpdateBy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) UpdateTypeShopMall(ctx context.Context, in *UpdateTypeShopMallRequest, opts ...grpc.CallOption) (*UpdateTypeShopMallResponse, error) {
	out := new(UpdateTypeShopMallResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/UpdateTypeShopMall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Count", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetCertificateFiles(ctx context.Context, in *GetCertificateRequest, opts ...grpc.CallOption) (*CertificateFiles, error) {
	out := new(CertificateFiles)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetCertificateFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) ListHistory(ctx context.Context, in *ListHistoryRequest, opts ...grpc.CallOption) (*ListHistoryResponse, error) {
	out := new(ListHistoryResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/ListHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) Up(ctx context.Context, in *UpRequest, opts ...grpc.CallOption) (*UpResponse, error) {
	out := new(UpResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/Up", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetRedisByKey(ctx context.Context, in *GetRedisByKeyRequest, opts ...grpc.CallOption) (*GetRedisByKeyResponse, error) {
	out := new(GetRedisByKeyResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetRedisByKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) RepushProducts(ctx context.Context, in *RepushRequest, opts ...grpc.CallOption) (*RepushResponse, error) {
	out := new(RepushResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/RepushProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) GetProducts(ctx context.Context, in *GetProductsRequest, opts ...grpc.CallOption) (*GetProductsResponse, error) {
	out := new(GetProductsResponse)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.product.ProductService/GetProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServiceServer is the server API for ProductService service.
type ProductServiceServer interface {
	List(context.Context, *ListRequest) (*ListResponse, error)
	Add(context.Context, *AddRequest) (*AddResponse, error)
	GetEsReindexLogList(context.Context, *EsReindexLogListRequest) (*EsReindexLogListResponse, error)
	Get(context.Context, *GetRequest) (*ProductDetail, error)
	GetVariants(context.Context, *GetVariantRequest) (*ProductVariants, error)
	GetVariant(context.Context, *GetVariantRequest) (*Variant, error)
	UpdateVariants(context.Context, *UpdateVariantsRequest) (*UpdateVariantsResponse, error)
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	Updates(context.Context, *UpdatesRequest) (*UpdatesResponse, error)
	UpdateBy(context.Context, *UpdateByRequest) (*UpdateByResponse, error)
	UpdateTypeShopMall(context.Context, *UpdateTypeShopMallRequest) (*UpdateTypeShopMallResponse, error)
	Count(context.Context, *CountRequest) (*CountResponse, error)
	GetCertificateFiles(context.Context, *GetCertificateRequest) (*CertificateFiles, error)
	ListHistory(context.Context, *ListHistoryRequest) (*ListHistoryResponse, error)
	Up(context.Context, *UpRequest) (*UpResponse, error)
	GetRedisByKey(context.Context, *GetRedisByKeyRequest) (*GetRedisByKeyResponse, error)
	RepushProducts(context.Context, *RepushRequest) (*RepushResponse, error)
	GetProducts(context.Context, *GetProductsRequest) (*GetProductsResponse, error)
}

func RegisterProductServiceServer(s *grpc.Server, srv ProductServiceServer) {
	s.RegisterService(&_ProductService_serviceDesc, srv)
}

func _ProductService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Add(ctx, req.(*AddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetEsReindexLogList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EsReindexLogListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetEsReindexLogList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetEsReindexLogList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetEsReindexLogList(ctx, req.(*EsReindexLogListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetVariants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetVariants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetVariants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetVariants(ctx, req.(*GetVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetVariant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetVariant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetVariant(ctx, req.(*GetVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_UpdateVariants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVariantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).UpdateVariants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/UpdateVariants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).UpdateVariants(ctx, req.(*UpdateVariantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Updates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Updates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Updates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Updates(ctx, req.(*UpdatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_UpdateBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).UpdateBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/UpdateBy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).UpdateBy(ctx, req.(*UpdateByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_UpdateTypeShopMall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTypeShopMallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).UpdateTypeShopMall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/UpdateTypeShopMall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).UpdateTypeShopMall(ctx, req.(*UpdateTypeShopMallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Count",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetCertificateFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetCertificateFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetCertificateFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetCertificateFiles(ctx, req.(*GetCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_ListHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).ListHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/ListHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).ListHistory(ctx, req.(*ListHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_Up_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).Up(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/Up",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).Up(ctx, req.(*UpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetRedisByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRedisByKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetRedisByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetRedisByKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetRedisByKey(ctx, req.(*GetRedisByKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_RepushProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).RepushProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/RepushProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).RepushProducts(ctx, req.(*RepushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_GetProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).GetProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.product.ProductService/GetProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).GetProducts(ctx, req.(*GetProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProductService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sendo.v1.api.product.ProductService",
	HandlerType: (*ProductServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ProductService_List_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _ProductService_Add_Handler,
		},
		{
			MethodName: "GetEsReindexLogList",
			Handler:    _ProductService_GetEsReindexLogList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ProductService_Get_Handler,
		},
		{
			MethodName: "GetVariants",
			Handler:    _ProductService_GetVariants_Handler,
		},
		{
			MethodName: "GetVariant",
			Handler:    _ProductService_GetVariant_Handler,
		},
		{
			MethodName: "UpdateVariants",
			Handler:    _ProductService_UpdateVariants_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ProductService_Update_Handler,
		},
		{
			MethodName: "Updates",
			Handler:    _ProductService_Updates_Handler,
		},
		{
			MethodName: "UpdateBy",
			Handler:    _ProductService_UpdateBy_Handler,
		},
		{
			MethodName: "UpdateTypeShopMall",
			Handler:    _ProductService_UpdateTypeShopMall_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _ProductService_Count_Handler,
		},
		{
			MethodName: "GetCertificateFiles",
			Handler:    _ProductService_GetCertificateFiles_Handler,
		},
		{
			MethodName: "ListHistory",
			Handler:    _ProductService_ListHistory_Handler,
		},
		{
			MethodName: "Up",
			Handler:    _ProductService_Up_Handler,
		},
		{
			MethodName: "GetRedisByKey",
			Handler:    _ProductService_GetRedisByKey_Handler,
		},
		{
			MethodName: "RepushProducts",
			Handler:    _ProductService_RepushProducts_Handler,
		},
		{
			MethodName: "GetProducts",
			Handler:    _ProductService_GetProducts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "product/product.proto",
}

func (m *UpdateByRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateByRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateBy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdateBy.Size()))
		n1, err := m.UpdateBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Product != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Product.Size()))
		n2, err := m.Product.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Fields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Fields.Size()))
		n3, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTypeShopMallRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTypeShopMallRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdateType))
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.ReasonReject != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReasonReject.Size()))
		n4, err := m.ReasonReject.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ReasonCancel != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReasonCancel.Size()))
		n5, err := m.ReasonCancel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Reason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTypeShopMallResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTypeShopMallResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateByResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateByResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateBy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdateBy.Size()))
		n6, err := m.UpdateBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.Product != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Product.Size()))
		n7, err := m.Product.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Fields != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Fields.Size()))
		n8, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Data.Size()))
		n9, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sorts) > 0 {
		for _, s := range m.Sorts {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Filters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Filters.Size()))
		n10, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Pagination != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Pagination.Size()))
		n11, err := m.Pagination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.MetaData {
		dAtA[i] = 0x20
		i++
		if m.MetaData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProductAll {
		dAtA[i] = 0x28
		i++
		if m.ProductAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Filters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CategoryId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CategoryId))
	}
	if len(m.StatusNew) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.StatusNew)))
		i += copy(dAtA[i:], m.StatusNew)
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if m.PriceFrom != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriceFrom))))
		i += 8
	}
	if m.PriceTo != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriceTo))))
		i += 8
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.IsOff != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsOff))
	}
	if m.UpdatedDateFrom != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedDateFrom))
	}
	if m.UpdatedDateTo != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedDateTo))
	}
	if len(m.ProductIds) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductIds)))
		i += copy(dAtA[i:], m.ProductIds)
	}
	if m.FilterType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.FilterType))
	}
	if len(m.Assignee) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Assignee)))
		i += copy(dAtA[i:], m.Assignee)
	}
	if m.ReviewFromDate != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReviewFromDate))
	}
	if m.ReviewToDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReviewToDate))
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if len(m.IsReview) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.IsReview)))
		i += copy(dAtA[i:], m.IsReview)
	}
	if m.IsReviewType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsReviewType))
	}
	if m.BrandId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if len(m.ShopType) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShopType)))
		i += copy(dAtA[i:], m.ShopType)
	}
	if m.Status != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Status))
	}
	if len(m.ShopName) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShopName)))
		i += copy(dAtA[i:], m.ShopName)
	}
	if m.RatingFrom != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.RatingFrom))
	}
	if m.RatingTo != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.RatingTo))
	}
	if m.PromotionPercentFrom != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionPercentFrom))
	}
	if m.PromotionPercentTo != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionPercentTo))
	}
	if m.PromotionApp != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionApp))
	}
	if m.ShopFreeShipping != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopFreeShipping))
	}
	if m.IsCertified != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsCertified))
	}
	if len(m.SellerAdminId) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SellerAdminId)))
		i += copy(dAtA[i:], m.SellerAdminId)
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionToDate))
	}
	if len(m.InsideProductType) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.InsideProductType)))
		i += copy(dAtA[i:], m.InsideProductType)
	}
	if m.FinalPriceFrom != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPriceFrom))))
		i += 8
	}
	if m.FinalPriceTo != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPriceTo))))
		i += 8
	}
	if m.OrderComplete_30From != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OrderComplete_30From))
	}
	if m.OrderComplete_30To != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OrderComplete_30To))
	}
	if m.HasCertificate != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.HasCertificate))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.ExtendedShippingPackage != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage))
	}
	if len(m.ProductExternalIds) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductExternalIds)))
		i += copy(dAtA[i:], m.ProductExternalIds)
	}
	if m.IsConfigVariant != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsConfigVariant))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MetaData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.MetaData.Size()))
		n12, err := m.MetaData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if m.Rating != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rating))))
		i += 4
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Price != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if len(m.StatusName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.StatusName)))
		i += copy(dAtA[i:], m.StatusName)
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedAt))
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if len(m.CatPath) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CatPath)))
		i += copy(dAtA[i:], m.CatPath)
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.IsReview {
		dAtA[i] = 0x78
		i++
		if m.IsReview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReviewDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReviewDate))
	}
	if len(m.Assignee) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Assignee)))
		i += copy(dAtA[i:], m.Assignee)
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ProductCertificate) > 0 {
		for _, msg := range m.ProductCertificate {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.BrandName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.BrandName)))
		i += copy(dAtA[i:], m.BrandName)
	}
	if len(m.CategoryName) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryName)))
		i += copy(dAtA[i:], m.CategoryName)
	}
	if len(m.UrlPath) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UrlPath)))
		i += copy(dAtA[i:], m.UrlPath)
	}
	if len(m.ShopName) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShopName)))
		i += copy(dAtA[i:], m.ShopName)
	}
	if len(m.CategoryId) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryId)))
		i += copy(dAtA[i:], m.CategoryId)
	}
	if m.FinalPrice != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPrice))))
		i += 8
	}
	if m.PromotionPercent != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionPercent))
	}
	if m.BrandId != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.VersionNo != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.VersionNo))
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.Weight != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.IsCertified != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsCertified))
	}
	if m.ShopFreeShipping != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopFreeShipping))
	}
	if m.PromotionApp != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionApp))
	}
	if m.OrderComplete_30 != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OrderComplete_30))
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if m.Quantity != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if m.IsEnable {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShopType != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopType))
	}
	if m.IsUpdated != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsUpdated))
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionToDate))
	}
	if m.SpecialPrice != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SpecialPrice))))
		i += 8
	}
	if m.RatingPercent != 0 {
		dAtA[i] = 0xed
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RatingPercent))))
		i += 4
	}
	if m.CategoryLevels != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CategoryLevels.Size()))
		n13, err := m.CategoryLevels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.PromotionNote) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.PromotionNote)))
		i += copy(dAtA[i:], m.PromotionNote)
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UnitType))
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CreatedAt))
	}
	if m.IsOff {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		if m.IsOff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Vasup != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Vasup))
	}
	if m.AdminId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdminId))
	}
	if m.LengthProduct != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LengthProduct))))
		i += 4
	}
	if m.HeightProduct != 0 {
		dAtA[i] = 0xb5
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeightProduct))))
		i += 4
	}
	if m.WitdhProduct != 0 {
		dAtA[i] = 0xbd
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WitdhProduct))))
		i += 4
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if len(m.ShippingImages) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShippingImages)))
		i += copy(dAtA[i:], m.ShippingImages)
	}
	if m.ExtendedShippingPackage != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage.Size()))
		n14, err := m.ExtendedShippingPackage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.IsConfigVariant {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		if m.IsConfigVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PriceMax != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriceMax))))
		i += 8
	}
	if m.FinalPriceMax != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPriceMax))))
		i += 8
	}
	if m.TotalVariant != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TotalVariant))
	}
	if m.IsInvalidVariant {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		if m.IsInvalidVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.CategoryIds) > 0 {
		dAtA16 := make([]byte, len(m.CategoryIds)*10)
		var j15 int
		for _, num := range m.CategoryIds {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DescriptionScore != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DescriptionScore))))
		i += 4
	}
	if len(m.ShortDescription) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShortDescription)))
		i += copy(dAtA[i:], m.ShortDescription)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.LengthProduct != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LengthProduct))))
		i += 4
	}
	if m.HeightProduct != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeightProduct))))
		i += 4
	}
	if m.WitdhProduct != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WitdhProduct))))
		i += 4
	}
	if m.IsEnable {
		dAtA[i] = 0x58
		i++
		if m.IsEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UnitType))
	}
	if m.CategoryId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CategoryId))
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if m.HasOptions {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.HasOptions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if m.TypeProduct != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TypeProduct))
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if m.Price != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MetaTitle) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaTitle)))
		i += copy(dAtA[i:], m.MetaTitle)
	}
	if len(m.MetaKeyword) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaKeyword)))
		i += copy(dAtA[i:], m.MetaKeyword)
	}
	if len(m.MetaDescription) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaDescription)))
		i += copy(dAtA[i:], m.MetaDescription)
	}
	if len(m.TagsKey) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.TagsKey)))
		i += copy(dAtA[i:], m.TagsKey)
	}
	if len(m.ProductRelateds) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductRelateds)))
		i += copy(dAtA[i:], m.ProductRelateds)
	}
	if m.BrandId != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.IsBrand != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsBrand))
	}
	if m.AdditionalAttributes != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdditionalAttributes.Size()))
		n17, err := m.AdditionalAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.SeoTitle) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoTitle)))
		i += copy(dAtA[i:], m.SeoTitle)
	}
	if len(m.SeoKeyword) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoKeyword)))
		i += copy(dAtA[i:], m.SeoKeyword)
	}
	if len(m.SeoDescription) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoDescription)))
		i += copy(dAtA[i:], m.SeoDescription)
	}
	if m.SeoScore != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SeoScore))
	}
	if len(m.VideoLink) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.VideoLink)))
		i += copy(dAtA[i:], m.VideoLink)
	}
	if len(m.CertificateFile) > 0 {
		for _, msg := range m.CertificateFile {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShopType != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopType))
	}
	if len(m.CreatedUser) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CreatedUser)))
		i += copy(dAtA[i:], m.CreatedUser)
	}
	if len(m.Assignee) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Assignee)))
		i += copy(dAtA[i:], m.Assignee)
	}
	if m.StatusDate != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusDate))
	}
	if m.IsReview {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsReview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsReviewType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsReviewType))
	}
	if m.Score != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Score))
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if m.FilterType != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.FilterType))
	}
	if m.IsUpdated != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsUpdated))
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionToDate))
	}
	if m.SpecialPrice != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SpecialPrice))))
		i += 8
	}
	if len(m.PromotionNote) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.PromotionNote)))
		i += copy(dAtA[i:], m.PromotionNote)
	}
	if m.ExtendedShippingPackage != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage.Size()))
		n18, err := m.ExtendedShippingPackage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DescriptionScore != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DescriptionScore))))
		i += 4
	}
	if len(m.ShortDescription) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ShortDescription)))
		i += copy(dAtA[i:], m.ShortDescription)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.LengthProduct != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LengthProduct))))
		i += 4
	}
	if m.HeightProduct != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeightProduct))))
		i += 4
	}
	if m.WitdhProduct != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WitdhProduct))))
		i += 4
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UnitType))
	}
	if m.CategoryId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CategoryId))
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if m.HasOptions {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.HasOptions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if m.TypeProduct != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TypeProduct))
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if m.Price != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MetaTitle) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaTitle)))
		i += copy(dAtA[i:], m.MetaTitle)
	}
	if len(m.MetaKeyword) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaKeyword)))
		i += copy(dAtA[i:], m.MetaKeyword)
	}
	if len(m.MetaDescription) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.MetaDescription)))
		i += copy(dAtA[i:], m.MetaDescription)
	}
	if len(m.TagsKey) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.TagsKey)))
		i += copy(dAtA[i:], m.TagsKey)
	}
	if len(m.ProductRelateds) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductRelateds)))
		i += copy(dAtA[i:], m.ProductRelateds)
	}
	if m.BrandId != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.IsBrand != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsBrand))
	}
	if m.AdditionalAttributes != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdditionalAttributes.Size()))
		n19, err := m.AdditionalAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.SeoTitle) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoTitle)))
		i += copy(dAtA[i:], m.SeoTitle)
	}
	if len(m.SeoKeyword) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoKeyword)))
		i += copy(dAtA[i:], m.SeoKeyword)
	}
	if len(m.SeoDescription) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoDescription)))
		i += copy(dAtA[i:], m.SeoDescription)
	}
	if m.SeoScore != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SeoScore))
	}
	if len(m.VideoLink) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.VideoLink)))
		i += copy(dAtA[i:], m.VideoLink)
	}
	if len(m.CertificateFile) > 0 {
		for _, msg := range m.CertificateFile {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CreatedUser) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CreatedUser)))
		i += copy(dAtA[i:], m.CreatedUser)
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.StatusDate != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusDate))
	}
	if m.IsReview {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		if m.IsReview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsReviewType != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsReviewType))
	}
	if m.Score != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Score))
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if m.FilterType != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.FilterType))
	}
	if m.IsEnable {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		if m.IsEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Assignee) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Assignee)))
		i += copy(dAtA[i:], m.Assignee)
	}
	if m.ReviewDate != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReviewDate))
	}
	if len(m.ReasonDescription) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonDescription)))
		i += copy(dAtA[i:], m.ReasonDescription)
	}
	if m.SpecialPrice != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SpecialPrice))))
		i += 8
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.IsUpdated != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsUpdated))
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionToDate))
	}
	if len(m.PromotionNote) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.PromotionNote)))
		i += copy(dAtA[i:], m.PromotionNote)
	}
	if len(m.CabinetList) > 0 {
		dAtA21 := make([]byte, len(m.CabinetList)*10)
		var j20 int
		for _, num := range m.CabinetList {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.ExtendedShippingPackage != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage.Size()))
		n22, err := m.ExtendedShippingPackage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsShopUpdate {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		if m.IsShopUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsEvent != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsEvent))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttributeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MultiData) > 0 {
		for _, msg := range m.MultiData {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SingleData) > 0 {
		for _, msg := range m.SingleData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TextData) > 0 {
		for _, msg := range m.TextData {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CustomData) > 0 {
		for _, msg := range m.CustomData {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttributeOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Images) > 0 {
		for k, _ := range m.Images {
			dAtA[i] = 0x1a
			i++
			v := m.Images[k]
			mapSize := 1 + len(k) + sovProduct(uint64(len(k))) + 1 + len(v) + sovProduct(uint64(len(v)))
			i = encodeVarintProduct(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintProduct(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ValueCustom) > 0 {
		for _, msg := range m.ValueCustom {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AttributeId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AttributeId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Attribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttributeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AttributeId))
	}
	if m.AttributeType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AttributeType))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ProductOption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductOption)))
		i += copy(dAtA[i:], m.ProductOption)
	}
	if m.ShowRequired != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShowRequired))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.AttributeValue) > 0 {
		for _, msg := range m.AttributeValue {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.IsCustom {
		dAtA[i] = 0x48
		i++
		if m.IsCustom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsCheckout {
		dAtA[i] = 0x50
		i++
		if m.IsCheckout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CustomAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdTemp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IdTemp))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		for _, msg := range m.Value {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Images) > 0 {
		for k, _ := range m.Images {
			dAtA[i] = 0x2a
			i++
			v := m.Images[k]
			mapSize := 1 + len(k) + sovProduct(uint64(len(k))) + 1 + len(v) + sovProduct(uint64(len(v)))
			i = encodeVarintProduct(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintProduct(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValueCustom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueCustom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionIdTemp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OptionIdTemp))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttributeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Background) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Background)))
		i += copy(dAtA[i:], m.Background)
	}
	if len(m.ColorHexRgb) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ColorHexRgb)))
		i += copy(dAtA[i:], m.ColorHexRgb)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Image_50X50) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Image_50X50)))
		i += copy(dAtA[i:], m.Image_50X50)
	}
	if len(m.Image_500X500) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Image_500X500)))
		i += copy(dAtA[i:], m.Image_500X500)
	}
	if m.OptionId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OptionId))
	}
	if m.ColorType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ColorType))
	}
	if m.IsCustom {
		dAtA[i] = 0x48
		i++
		if m.IsCustom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductCertificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.AttachmentUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttachmentUrl)))
		i += copy(dAtA[i:], m.AttachmentUrl)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if m.BrandId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if len(m.CategoryId) > 0 {
		dAtA24 := make([]byte, len(m.CategoryId)*10)
		var j23 int
		for _, num := range m.CategoryId {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	if len(m.StatusNew) > 0 {
		dAtA26 := make([]byte, len(m.StatusNew)*10)
		var j25 int
		for _, num := range m.StatusNew {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateByFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateByFields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StatusNew != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if m.BrandId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.StatusNew) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.StatusNew)))
		i += copy(dAtA[i:], m.StatusNew)
	}
	if m.IsOff != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsOff))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if m.ResetCache != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ResetCache))
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetVariantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVariantRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.AttributeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttributeHash)))
		i += copy(dAtA[i:], m.AttributeHash)
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if len(m.Include) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Include)))
		i += copy(dAtA[i:], m.Include)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateVariantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVariantsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.VersionNo != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.VersionNo))
	}
	if m.Fields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Fields.Size()))
		n27, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateVariantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVariantsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateVariantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVariantResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AttributeHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttributeHash)))
		i += copy(dAtA[i:], m.AttributeHash)
	}
	if m.Error {
		dAtA[i] = 0x10
		i++
		if m.Error {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CategoryLevels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryLevels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cat1Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Cat1Id))
	}
	if m.Cat2Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Cat2Id))
	}
	if m.Cat3Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Cat3Id))
	}
	if m.Cat4Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Cat4Id))
	}
	if len(m.Cat2Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Cat2Name)))
		i += copy(dAtA[i:], m.Cat2Name)
	}
	if len(m.Cat3Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Cat3Name)))
		i += copy(dAtA[i:], m.Cat3Name)
	}
	if len(m.Cat4Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Cat4Name)))
		i += copy(dAtA[i:], m.Cat4Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.Thumbnail) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Thumbnail)))
		i += copy(dAtA[i:], m.Thumbnail)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductRelated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductRelated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.ProductImage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductImage)))
		i += copy(dAtA[i:], m.ProductImage)
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if len(m.CategoryName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryName)))
		i += copy(dAtA[i:], m.CategoryName)
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if m.Price != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
		i += 4
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.Price != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if m.UnitType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UnitType))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.VersionNo != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.VersionNo))
	}
	if len(m.CategoryId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryId)))
		i += copy(dAtA[i:], m.CategoryId)
	}
	if m.CategoryLevels != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CategoryLevels.Size()))
		n28, err := m.CategoryLevels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if len(m.TagsKey) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.TagsKey)))
		i += copy(dAtA[i:], m.TagsKey)
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedAt))
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CreatedAt))
	}
	if m.BrandId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.Quantity != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if len(m.Seo) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Seo)))
		i += copy(dAtA[i:], m.Seo)
	}
	if len(m.SeoTitle) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoTitle)))
		i += copy(dAtA[i:], m.SeoTitle)
	}
	if len(m.SeoDescription) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoDescription)))
		i += copy(dAtA[i:], m.SeoDescription)
	}
	if len(m.SeoKeyword) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SeoKeyword)))
		i += copy(dAtA[i:], m.SeoKeyword)
	}
	if m.SeoScore != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SeoScore))
	}
	if len(m.ProductLink) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductLink)))
		i += copy(dAtA[i:], m.ProductLink)
	}
	if m.HeightProduct != 0 {
		dAtA[i] = 0xdd
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeightProduct))))
		i += 4
	}
	if m.WitdhProduct != 0 {
		dAtA[i] = 0xe5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WitdhProduct))))
		i += 4
	}
	if m.LengthProduct != 0 {
		dAtA[i] = 0xed
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LengthProduct))))
		i += 4
	}
	if len(m.VideoLink) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.VideoLink)))
		i += copy(dAtA[i:], m.VideoLink)
	}
	if len(m.VideoInfo) > 0 {
		for _, msg := range m.VideoInfo {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShopType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopType))
	}
	if len(m.ProductRelateds) > 0 {
		for _, msg := range m.ProductRelateds {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cprice != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x2
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cprice))))
		i += 8
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.ProductImage) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductImage)))
		i += copy(dAtA[i:], m.ProductImage)
	}
	if len(m.CategoryName) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryName)))
		i += copy(dAtA[i:], m.CategoryName)
	}
	if m.SpecialPrice != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SpecialPrice))
	}
	if m.IsEnable {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.IsEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonDescription) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonDescription)))
		i += copy(dAtA[i:], m.ReasonDescription)
	}
	if len(m.BrandName) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.BrandName)))
		i += copy(dAtA[i:], m.BrandName)
	}
	if m.IsReview {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		if m.IsReview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReviewDate != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ReviewDate))
	}
	if len(m.ProductCertificate) > 0 {
		for _, msg := range m.ProductCertificate {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UrlPath) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UrlPath)))
		i += copy(dAtA[i:], m.UrlPath)
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if len(m.Assignee) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Assignee)))
		i += copy(dAtA[i:], m.Assignee)
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsOff {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		if m.IsOff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionToDate))
	}
	if len(m.PromotionNote) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.PromotionNote)))
		i += copy(dAtA[i:], m.PromotionNote)
	}
	if m.ExtendedShippingPackage != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage.Size()))
		n29, err := m.ExtendedShippingPackage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.IsConfigVariant {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x3
		i++
		if m.IsConfigVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if m.RatingPercent != 0 {
		dAtA[i] = 0xe5
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RatingPercent))))
		i += 4
	}
	if m.FinalPrice != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPrice))))
		i += 8
	}
	if m.PriceMax != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriceMax))))
		i += 8
	}
	if m.FinalPriceMax != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x3
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPriceMax))))
		i += 8
	}
	if m.IsInvalidVariant {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		if m.IsInvalidVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductVariants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductVariants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if m.AdminId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdminId))
	}
	if m.VersionNo != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.VersionNo))
	}
	if m.IsInvalidVariant {
		dAtA[i] = 0x38
		i++
		if m.IsInvalidVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertificateFilesFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateFilesFilters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.CategoryId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryId)))
		i += copy(dAtA[i:], m.CategoryId)
	}
	if m.BrandId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCertificateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCertificateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Filters.Size()))
		n30, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertificateFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateFiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.Pagination != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Pagination.Size()))
		n31, err := m.Pagination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Status) > 0 {
		dAtA33 := make([]byte, len(m.Status)*10)
		var j32 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MetaData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.MetaData.Size()))
		n34, err := m.MetaData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Action))
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.StoreCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.StoreCode)))
		i += copy(dAtA[i:], m.StoreCode)
	}
	if len(m.StoreName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.StoreName)))
		i += copy(dAtA[i:], m.StoreName)
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Status))
	}
	if m.UpdatedStatus != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedStatus))
	}
	if len(m.ReasonCode) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonCode)))
		i += copy(dAtA[i:], m.ReasonCode)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	if len(m.UpdatedUser) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UpdatedUser)))
		i += copy(dAtA[i:], m.UpdatedUser)
	}
	if m.UpdatedDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedDate))
	}
	if len(m.ReasonName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ReasonName)))
		i += copy(dAtA[i:], m.ReasonName)
	}
	if m.DiscountPercent != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.DiscountPercent))
	}
	if m.UpdatedDiscountPercent != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedDiscountPercent))
	}
	if m.StockAvailability {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.StockAvailability {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpdatedStockAvailability {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.UpdatedStockAvailability {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Weight != 0 {
		dAtA[i] = 0x95
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.UpdatedWeight != 0 {
		dAtA[i] = 0xa5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdatedWeight))))
		i += 4
	}
	if m.Price != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Price))
	}
	if m.UpdatedPrice != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedPrice))
	}
	if m.IsStatusUpdated {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsStatusUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDiscountPercentUpdated {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDiscountPercentUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStockAvailabilityUpdated {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsStockAvailabilityUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsWeightUpdated {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsWeightUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPriceUpdated {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsPriceUpdated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRedisByKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRedisByKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Params) > 0 {
		for _, s := range m.Params {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRedisByKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRedisByKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VasUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VasUp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Time))
	}
	if len(m.CategoryId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryId)))
		i += copy(dAtA[i:], m.CategoryId)
	}
	if m.Position != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Position))
	}
	if m.TypeUp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TypeUp))
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VasUpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VasUpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepushRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepushRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductIds) > 0 {
		dAtA36 := make([]byte, len(m.ProductIds)*10)
		var j35 int
		for _, num := range m.ProductIds {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if m.RepushEs {
		dAtA[i] = 0x10
		i++
		if m.RepushEs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RepushRedis {
		dAtA[i] = 0x18
		i++
		if m.RepushRedis {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepushResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepushResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtendedShippingPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendedShippingPackage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsUsingInstant {
		dAtA[i] = 0x8
		i++
		if m.IsUsingInstant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUsingInDay {
		dAtA[i] = 0x10
		i++
		if m.IsUsingInDay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsSelfShipping {
		dAtA[i] = 0x18
		i++
		if m.IsSelfShipping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Variant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AttributeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttributeHash)))
		i += copy(dAtA[i:], m.AttributeHash)
	}
	if m.PromotionStartDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionStartDate))
	}
	if m.PromotionEndDate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PromotionEndDate))
	}
	if m.PromotionPercent != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PromotionPercent))))
		i += 4
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if len(m.SkuUser) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SkuUser)))
		i += copy(dAtA[i:], m.SkuUser)
	}
	if m.Price != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if m.SpecialPrice != 0 {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SpecialPrice))))
		i += 8
	}
	if m.FinalPrice != 0 {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPrice))))
		i += 8
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if m.Order != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VariantAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Id))
	}
	if m.OptionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OptionId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdsService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdsService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShopAds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ShopAds))
	}
	if m.AdPlus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdPlus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetProductsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProductsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductSkus) > 0 {
		for _, msg := range m.ProductSkus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DataConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.DataConfig.Size()))
		n37, err := m.DataConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetProductsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProductsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Products) > 0 {
		for _, msg := range m.Products {
			dAtA[i] = 0x42
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductDetailSku) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductDetailSku) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if m.ProductExternalId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductExternalId))
	}
	if m.AdminId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.AdminId))
	}
	if m.SellerAdminId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.SellerAdminId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.CatPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CatPath)))
		i += copy(dAtA[i:], m.CatPath)
	}
	if len(m.CategoryId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.CategoryId)))
		i += copy(dAtA[i:], m.CategoryId)
	}
	if m.BrandId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.BrandId))
	}
	if m.StockStatus != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StockStatus))
	}
	if m.StatusNew != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusNew))
	}
	if m.Price != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if m.FinalPrice != 0 {
		dAtA[i] = 0x69
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FinalPrice))))
		i += 8
	}
	if m.IsPromotion != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.IsPromotion))
	}
	if m.PromotionPercent != 0 {
		dAtA[i] = 0x7d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PromotionPercent))))
		i += 4
	}
	if len(m.UnitType) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.UnitType)))
		i += copy(dAtA[i:], m.UnitType)
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Quantity))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x95
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.HeightProduct != 0 {
		dAtA[i] = 0x9d
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeightProduct))))
		i += 4
	}
	if m.WitdhProduct != 0 {
		dAtA[i] = 0xa5
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WitdhProduct))))
		i += 4
	}
	if m.LengthProduct != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LengthProduct))))
		i += 4
	}
	if len(m.Sku) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Sku)))
		i += copy(dAtA[i:], m.Sku)
	}
	if len(m.ProductSkuUser) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ProductSkuUser)))
		i += copy(dAtA[i:], m.ProductSkuUser)
	}
	if len(m.VariantSkuUser) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.VariantSkuUser)))
		i += copy(dAtA[i:], m.VariantSkuUser)
	}
	if len(m.AttributeHash) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttributeHash)))
		i += copy(dAtA[i:], m.AttributeHash)
	}
	if m.IsConfigVariant {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsConfigVariant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsValidAttributeHash {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.IsValidAttributeHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExtendedShippingPackage != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ExtendedShippingPackage.Size()))
		n38, err := m.ExtendedShippingPackage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Promotion != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Promotion.Size()))
		n39, err := m.Promotion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.ProductAttributes) > 0 {
		for _, msg := range m.ProductAttributes {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkuAttributeOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkuAttributeOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Id))
	}
	if m.OptionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OptionId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductSkuFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSkuFilters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.AttributeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.AttributeHash)))
		i += copy(dAtA[i:], m.AttributeHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductsFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductsFilters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProductSkus) > 0 {
		for _, msg := range m.ProductSkus {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductDataConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductDataConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Source))
	}
	if m.CheckPromotion {
		dAtA[i] = 0x10
		i++
		if m.CheckPromotion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GetProductAttributes {
		dAtA[i] = 0x18
		i++
		if m.GetProductAttributes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GetFuturePromotion {
		dAtA[i] = 0x20
		i++
		if m.GetFuturePromotion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductVariationAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductVariationAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.OptionId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.OptionId))
	}
	if len(m.OptionValue) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.OptionValue)))
		i += copy(dAtA[i:], m.OptionValue)
	}
	if m.ColorType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ColorType))
	}
	if len(m.ColorValue) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.ColorValue)))
		i += copy(dAtA[i:], m.ColorValue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EsErrorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EsErrorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetryNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.RetryNumber))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TimeStamp))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EsReindexLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EsReindexLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ProductId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.ErrorResponses) > 0 {
		for _, msg := range m.ErrorResponses {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Status))
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.StatusCode))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.UpdatedAt))
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CreatedAt))
	}
	if m.RetryCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.RetryCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepeatedFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EsReindexLogListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EsReindexLogListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Page))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Limit))
	}
	if len(m.SortBy) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.SortBy)))
		i += copy(dAtA[i:], m.SortBy)
	}
	if len(m.OrderBy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProduct(dAtA, i, uint64(len(m.OrderBy)))
		i += copy(dAtA[i:], m.OrderBy)
	}
	if len(m.Filters) > 0 {
		for k, _ := range m.Filters {
			dAtA[i] = 0x2a
			i++
			v := m.Filters[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovProduct(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovProduct(uint64(len(k))) + msgSize
			i = encodeVarintProduct(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProduct(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintProduct(dAtA, i, uint64(v.Size()))
				n40, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n40
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EsReindexLogListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EsReindexLogListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Total))
	}
	if m.TotalPage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.TotalPage))
	}
	if m.CurrentPage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.CurrentPage))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProduct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.Size_))
	}
	if m.NextPage != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.NextPage))
	}
	if m.PrevPage != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProduct(dAtA, i, uint64(m.PrevPage))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintProduct(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UpdateByRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateBy != nil {
		l = m.UpdateBy.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTypeShopMallRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateType != 0 {
		n += 1 + sovProduct(uint64(m.UpdateType))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ReasonReject != nil {
		l = m.ReasonReject.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ReasonCancel != nil {
		l = m.ReasonCancel.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Reason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReasonCode)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTypeShopMallResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateByResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateBy != nil {
		l = m.UpdateBy.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sorts) > 0 {
		for _, s := range m.Sorts {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.MetaData {
		n += 2
	}
	if m.ProductAll {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CategoryId != 0 {
		n += 1 + sovProduct(uint64(m.CategoryId))
	}
	l = len(m.StatusNew)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.StockStatus != 0 {
		n += 1 + sovProduct(uint64(m.StockStatus))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.PriceFrom != 0 {
		n += 9
	}
	if m.PriceTo != 0 {
		n += 9
	}
	if m.IsPromotion != 0 {
		n += 1 + sovProduct(uint64(m.IsPromotion))
	}
	if m.IsOff != 0 {
		n += 1 + sovProduct(uint64(m.IsOff))
	}
	if m.UpdatedDateFrom != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedDateFrom))
	}
	if m.UpdatedDateTo != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedDateTo))
	}
	l = len(m.ProductIds)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.FilterType != 0 {
		n += 1 + sovProduct(uint64(m.FilterType))
	}
	l = len(m.Assignee)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ReviewFromDate != 0 {
		n += 1 + sovProduct(uint64(m.ReviewFromDate))
	}
	if m.ReviewToDate != 0 {
		n += 2 + sovProduct(uint64(m.ReviewToDate))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	l = len(m.IsReview)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsReviewType != 0 {
		n += 2 + sovProduct(uint64(m.IsReviewType))
	}
	if m.BrandId != 0 {
		n += 2 + sovProduct(uint64(m.BrandId))
	}
	l = len(m.ShopType)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovProduct(uint64(m.Status))
	}
	l = len(m.ShopName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.RatingFrom != 0 {
		n += 2 + sovProduct(uint64(m.RatingFrom))
	}
	if m.RatingTo != 0 {
		n += 2 + sovProduct(uint64(m.RatingTo))
	}
	if m.PromotionPercentFrom != 0 {
		n += 2 + sovProduct(uint64(m.PromotionPercentFrom))
	}
	if m.PromotionPercentTo != 0 {
		n += 2 + sovProduct(uint64(m.PromotionPercentTo))
	}
	if m.PromotionApp != 0 {
		n += 2 + sovProduct(uint64(m.PromotionApp))
	}
	if m.ShopFreeShipping != 0 {
		n += 2 + sovProduct(uint64(m.ShopFreeShipping))
	}
	if m.IsCertified != 0 {
		n += 2 + sovProduct(uint64(m.IsCertified))
	}
	l = len(m.SellerAdminId)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.PromotionStartDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionToDate))
	}
	l = len(m.InsideProductType)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.FinalPriceFrom != 0 {
		n += 10
	}
	if m.FinalPriceTo != 0 {
		n += 10
	}
	if m.OrderComplete_30From != 0 {
		n += 2 + sovProduct(uint64(m.OrderComplete_30From))
	}
	if m.OrderComplete_30To != 0 {
		n += 2 + sovProduct(uint64(m.OrderComplete_30To))
	}
	if m.HasCertificate != 0 {
		n += 2 + sovProduct(uint64(m.HasCertificate))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.ExtendedShippingPackage != 0 {
		n += 2 + sovProduct(uint64(m.ExtendedShippingPackage))
	}
	l = len(m.ProductExternalIds)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsConfigVariant != 0 {
		n += 2 + sovProduct(uint64(m.IsConfigVariant))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Rating != 0 {
		n += 5
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.Price != 0 {
		n += 9
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	l = len(m.StatusName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedAt))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.StockStatus != 0 {
		n += 1 + sovProduct(uint64(m.StockStatus))
	}
	l = len(m.CatPath)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.IsReview {
		n += 2
	}
	if m.ReviewDate != 0 {
		n += 2 + sovProduct(uint64(m.ReviewDate))
	}
	l = len(m.Assignee)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.ProductCertificate) > 0 {
		for _, e := range m.ProductCertificate {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.SellerAdminId != 0 {
		n += 2 + sovProduct(uint64(m.SellerAdminId))
	}
	l = len(m.BrandName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.CategoryName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.UrlPath)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ShopName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.FinalPrice != 0 {
		n += 10
	}
	if m.PromotionPercent != 0 {
		n += 2 + sovProduct(uint64(m.PromotionPercent))
	}
	if m.BrandId != 0 {
		n += 2 + sovProduct(uint64(m.BrandId))
	}
	if m.VersionNo != 0 {
		n += 2 + sovProduct(uint64(m.VersionNo))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.Weight != 0 {
		n += 6
	}
	if m.IsCertified != 0 {
		n += 2 + sovProduct(uint64(m.IsCertified))
	}
	if m.ShopFreeShipping != 0 {
		n += 2 + sovProduct(uint64(m.ShopFreeShipping))
	}
	if m.PromotionApp != 0 {
		n += 2 + sovProduct(uint64(m.PromotionApp))
	}
	if m.OrderComplete_30 != 0 {
		n += 2 + sovProduct(uint64(m.OrderComplete_30))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	if m.IsEnable {
		n += 3
	}
	if m.ShopType != 0 {
		n += 2 + sovProduct(uint64(m.ShopType))
	}
	if m.IsUpdated != 0 {
		n += 2 + sovProduct(uint64(m.IsUpdated))
	}
	if m.IsPromotion != 0 {
		n += 2 + sovProduct(uint64(m.IsPromotion))
	}
	if m.PromotionStartDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionToDate))
	}
	if m.SpecialPrice != 0 {
		n += 10
	}
	if m.RatingPercent != 0 {
		n += 6
	}
	if m.CategoryLevels != nil {
		l = m.CategoryLevels.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.PromotionNote)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.UnitType != 0 {
		n += 2 + sovProduct(uint64(m.UnitType))
	}
	if m.CreatedAt != 0 {
		n += 2 + sovProduct(uint64(m.CreatedAt))
	}
	if m.IsOff {
		n += 3
	}
	if m.Vasup != 0 {
		n += 2 + sovProduct(uint64(m.Vasup))
	}
	if m.AdminId != 0 {
		n += 2 + sovProduct(uint64(m.AdminId))
	}
	if m.LengthProduct != 0 {
		n += 6
	}
	if m.HeightProduct != 0 {
		n += 6
	}
	if m.WitdhProduct != 0 {
		n += 6
	}
	if m.ProductExternalId != 0 {
		n += 2 + sovProduct(uint64(m.ProductExternalId))
	}
	l = len(m.ShippingImages)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.ExtendedShippingPackage != nil {
		l = m.ExtendedShippingPackage.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsConfigVariant {
		n += 3
	}
	if m.PriceMax != 0 {
		n += 10
	}
	if m.FinalPriceMax != 0 {
		n += 10
	}
	if m.TotalVariant != 0 {
		n += 2 + sovProduct(uint64(m.TotalVariant))
	}
	if m.IsInvalidVariant {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if len(m.CategoryIds) > 0 {
		l = 0
		for _, e := range m.CategoryIds {
			l += sovProduct(uint64(e))
		}
		n += 1 + sovProduct(uint64(l)) + l
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.DescriptionScore != 0 {
		n += 5
	}
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Weight != 0 {
		n += 5
	}
	if m.LengthProduct != 0 {
		n += 5
	}
	if m.HeightProduct != 0 {
		n += 5
	}
	if m.WitdhProduct != 0 {
		n += 5
	}
	if m.IsEnable {
		n += 2
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.UnitType != 0 {
		n += 1 + sovProduct(uint64(m.UnitType))
	}
	if m.CategoryId != 0 {
		n += 1 + sovProduct(uint64(m.CategoryId))
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	if m.HasOptions {
		n += 3
	}
	if m.StockStatus != 0 {
		n += 2 + sovProduct(uint64(m.StockStatus))
	}
	if m.TypeProduct != 0 {
		n += 2 + sovProduct(uint64(m.TypeProduct))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	if m.Price != 0 {
		n += 10
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			l = len(s)
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.MetaTitle)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.MetaKeyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.MetaDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.TagsKey)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductRelateds)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.BrandId != 0 {
		n += 2 + sovProduct(uint64(m.BrandId))
	}
	if m.IsBrand != 0 {
		n += 2 + sovProduct(uint64(m.IsBrand))
	}
	if m.AdditionalAttributes != nil {
		l = m.AdditionalAttributes.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoTitle)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoKeyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.SeoScore != 0 {
		n += 2 + sovProduct(uint64(m.SeoScore))
	}
	l = len(m.VideoLink)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.CertificateFile) > 0 {
		for _, e := range m.CertificateFile {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.ShopType != 0 {
		n += 2 + sovProduct(uint64(m.ShopType))
	}
	l = len(m.CreatedUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.Assignee)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.StatusDate != 0 {
		n += 2 + sovProduct(uint64(m.StatusDate))
	}
	if m.IsReview {
		n += 3
	}
	if m.IsReviewType != 0 {
		n += 2 + sovProduct(uint64(m.IsReviewType))
	}
	if m.Score != 0 {
		n += 2 + sovProduct(uint64(m.Score))
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.FilterType != 0 {
		n += 2 + sovProduct(uint64(m.FilterType))
	}
	if m.IsUpdated != 0 {
		n += 2 + sovProduct(uint64(m.IsUpdated))
	}
	if m.IsPromotion != 0 {
		n += 2 + sovProduct(uint64(m.IsPromotion))
	}
	if m.PromotionStartDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionToDate))
	}
	if m.SpecialPrice != 0 {
		n += 10
	}
	l = len(m.PromotionNote)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.ExtendedShippingPackage != nil {
		l = m.ExtendedShippingPackage.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.DescriptionScore != 0 {
		n += 5
	}
	l = len(m.ShortDescription)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Weight != 0 {
		n += 5
	}
	if m.LengthProduct != 0 {
		n += 5
	}
	if m.HeightProduct != 0 {
		n += 5
	}
	if m.WitdhProduct != 0 {
		n += 5
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.UnitType != 0 {
		n += 1 + sovProduct(uint64(m.UnitType))
	}
	if m.CategoryId != 0 {
		n += 1 + sovProduct(uint64(m.CategoryId))
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	if m.HasOptions {
		n += 3
	}
	if m.StockStatus != 0 {
		n += 2 + sovProduct(uint64(m.StockStatus))
	}
	if m.TypeProduct != 0 {
		n += 2 + sovProduct(uint64(m.TypeProduct))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	if m.Price != 0 {
		n += 10
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			l = len(s)
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.MetaTitle)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.MetaKeyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.MetaDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.TagsKey)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductRelateds)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.BrandId != 0 {
		n += 2 + sovProduct(uint64(m.BrandId))
	}
	if m.IsBrand != 0 {
		n += 2 + sovProduct(uint64(m.IsBrand))
	}
	if m.AdditionalAttributes != nil {
		l = m.AdditionalAttributes.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoTitle)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoKeyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.SeoScore != 0 {
		n += 2 + sovProduct(uint64(m.SeoScore))
	}
	l = len(m.VideoLink)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.CertificateFile) > 0 {
		for _, e := range m.CertificateFile {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.CreatedUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.StatusDate != 0 {
		n += 2 + sovProduct(uint64(m.StatusDate))
	}
	if m.IsReview {
		n += 3
	}
	if m.IsReviewType != 0 {
		n += 2 + sovProduct(uint64(m.IsReviewType))
	}
	if m.Score != 0 {
		n += 2 + sovProduct(uint64(m.Score))
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.FilterType != 0 {
		n += 2 + sovProduct(uint64(m.FilterType))
	}
	if m.IsEnable {
		n += 3
	}
	l = len(m.Assignee)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.ReviewDate != 0 {
		n += 2 + sovProduct(uint64(m.ReviewDate))
	}
	l = len(m.ReasonDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.SpecialPrice != 0 {
		n += 10
	}
	if m.IsPromotion != 0 {
		n += 2 + sovProduct(uint64(m.IsPromotion))
	}
	if m.IsUpdated != 0 {
		n += 2 + sovProduct(uint64(m.IsUpdated))
	}
	if m.PromotionStartDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionToDate))
	}
	l = len(m.PromotionNote)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.CabinetList) > 0 {
		l = 0
		for _, e := range m.CabinetList {
			l += sovProduct(uint64(e))
		}
		n += 2 + sovProduct(uint64(l)) + l
	}
	if m.ExtendedShippingPackage != nil {
		l = m.ExtendedShippingPackage.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.IsShopUpdate {
		n += 3
	}
	if m.IsEvent != 0 {
		n += 2 + sovProduct(uint64(m.IsEvent))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MultiData) > 0 {
		for _, e := range m.MultiData {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.SingleData) > 0 {
		for _, e := range m.SingleData {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.TextData) > 0 {
		for _, e := range m.TextData {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.CustomData) > 0 {
		for _, e := range m.CustomData {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.Images) > 0 {
		for k, v := range m.Images {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProduct(uint64(len(k))) + 1 + len(v) + sovProduct(uint64(len(v)))
			n += mapEntrySize + 1 + sovProduct(uint64(mapEntrySize))
		}
	}
	if len(m.ValueCustom) > 0 {
		for _, e := range m.ValueCustom {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.AttributeId != 0 {
		n += 1 + sovProduct(uint64(m.AttributeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Attribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttributeId != 0 {
		n += 1 + sovProduct(uint64(m.AttributeId))
	}
	if m.AttributeType != 0 {
		n += 1 + sovProduct(uint64(m.AttributeType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductOption)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ShowRequired != 0 {
		n += 1 + sovProduct(uint64(m.ShowRequired))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.AttributeValue) > 0 {
		for _, e := range m.AttributeValue {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.IsCustom {
		n += 2
	}
	if m.IsCheckout {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CustomAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdTemp != 0 {
		n += 1 + sovProduct(uint64(m.IdTemp))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.Images) > 0 {
		for k, v := range m.Images {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProduct(uint64(len(k))) + 1 + len(v) + sovProduct(uint64(len(v)))
			n += mapEntrySize + 1 + sovProduct(uint64(mapEntrySize))
		}
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueCustom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionIdTemp != 0 {
		n += 1 + sovProduct(uint64(m.OptionIdTemp))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ColorHexRgb)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Image_50X50)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Image_500X500)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.OptionId != 0 {
		n += 1 + sovProduct(uint64(m.OptionId))
	}
	if m.ColorType != 0 {
		n += 1 + sovProduct(uint64(m.ColorType))
	}
	if m.IsCustom {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.AttachmentUrl)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if m.BrandId != 0 {
		n += 1 + sovProduct(uint64(m.BrandId))
	}
	if len(m.CategoryId) > 0 {
		l = 0
		for _, e := range m.CategoryId {
			l += sovProduct(uint64(e))
		}
		n += 1 + sovProduct(uint64(l)) + l
	}
	if len(m.StatusNew) > 0 {
		l = 0
		for _, e := range m.StatusNew {
			l += sovProduct(uint64(e))
		}
		n += 1 + sovProduct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateByFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.BrandId != 0 {
		n += 1 + sovProduct(uint64(m.BrandId))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	l = len(m.StatusNew)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.IsOff != 0 {
		n += 1 + sovProduct(uint64(m.IsOff))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovProduct(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovProduct(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if m.ResetCache != 0 {
		n += 1 + sovProduct(uint64(m.ResetCache))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ProductExternalId != 0 {
		n += 1 + sovProduct(uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVariantRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.AttributeHash)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Include)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVariantsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.VersionNo != 0 {
		n += 1 + sovProduct(uint64(m.VersionNo))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVariantsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVariantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttributeHash)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Error {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CategoryLevels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cat1Id != 0 {
		n += 1 + sovProduct(uint64(m.Cat1Id))
	}
	if m.Cat2Id != 0 {
		n += 1 + sovProduct(uint64(m.Cat2Id))
	}
	if m.Cat3Id != 0 {
		n += 1 + sovProduct(uint64(m.Cat3Id))
	}
	if m.Cat4Id != 0 {
		n += 1 + sovProduct(uint64(m.Cat4Id))
	}
	l = len(m.Cat2Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Cat3Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Cat4Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductRelated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductImage)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.CategoryName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if m.Price != 0 {
		n += 5
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.UnitType != 0 {
		n += 1 + sovProduct(uint64(m.UnitType))
	}
	if m.Weight != 0 {
		n += 5
	}
	if m.StockStatus != 0 {
		n += 1 + sovProduct(uint64(m.StockStatus))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.VersionNo != 0 {
		n += 1 + sovProduct(uint64(m.VersionNo))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.CategoryLevels != nil {
		l = m.CategoryLevels.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	if len(m.ProductImages) > 0 {
		for _, s := range m.ProductImages {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.TagsKey)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.IsPromotion != 0 {
		n += 2 + sovProduct(uint64(m.IsPromotion))
	}
	if m.UpdatedAt != 0 {
		n += 2 + sovProduct(uint64(m.UpdatedAt))
	}
	if m.CreatedAt != 0 {
		n += 2 + sovProduct(uint64(m.CreatedAt))
	}
	if m.BrandId != 0 {
		n += 2 + sovProduct(uint64(m.BrandId))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	l = len(m.Seo)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoTitle)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.SeoKeyword)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.SeoScore != 0 {
		n += 2 + sovProduct(uint64(m.SeoScore))
	}
	l = len(m.ProductLink)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.HeightProduct != 0 {
		n += 6
	}
	if m.WitdhProduct != 0 {
		n += 6
	}
	if m.LengthProduct != 0 {
		n += 6
	}
	l = len(m.VideoLink)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.VideoInfo) > 0 {
		for _, e := range m.VideoInfo {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.ShopType != 0 {
		n += 2 + sovProduct(uint64(m.ShopType))
	}
	if len(m.ProductRelateds) > 0 {
		for _, e := range m.ProductRelateds {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.Cprice != 0 {
		n += 10
	}
	if m.SellerAdminId != 0 {
		n += 2 + sovProduct(uint64(m.SellerAdminId))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductImage)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.CategoryName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.SpecialPrice != 0 {
		n += 2 + sovProduct(uint64(m.SpecialPrice))
	}
	if m.IsEnable {
		n += 3
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonDescription)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.BrandName)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsReview {
		n += 3
	}
	if m.ReviewDate != 0 {
		n += 2 + sovProduct(uint64(m.ReviewDate))
	}
	if len(m.ProductCertificate) > 0 {
		for _, e := range m.ProductCertificate {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.UrlPath)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.Assignee)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.IsOff {
		n += 3
	}
	if m.PromotionStartDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionToDate != 0 {
		n += 2 + sovProduct(uint64(m.PromotionToDate))
	}
	l = len(m.PromotionNote)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.ExtendedShippingPackage != nil {
		l = m.ExtendedShippingPackage.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsConfigVariant {
		n += 3
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.ProductExternalId != 0 {
		n += 2 + sovProduct(uint64(m.ProductExternalId))
	}
	if m.RatingPercent != 0 {
		n += 6
	}
	if m.FinalPrice != 0 {
		n += 10
	}
	if m.PriceMax != 0 {
		n += 10
	}
	if m.FinalPriceMax != 0 {
		n += 10
	}
	if m.IsInvalidVariant {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductVariants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	if m.AdminId != 0 {
		n += 1 + sovProduct(uint64(m.AdminId))
	}
	if m.VersionNo != 0 {
		n += 1 + sovProduct(uint64(m.VersionNo))
	}
	if m.IsInvalidVariant {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertificateFilesFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.BrandId != 0 {
		n += 1 + sovProduct(uint64(m.BrandId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCertificateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertificateFiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovProduct(uint64(e))
		}
		n += 1 + sovProduct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovProduct(uint64(m.Action))
	}
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.StoreCode)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.StoreName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProduct(uint64(m.Status))
	}
	if m.UpdatedStatus != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedStatus))
	}
	l = len(m.ReasonCode)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.UpdatedUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.UpdatedDate != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedDate))
	}
	l = len(m.ReasonName)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.DiscountPercent != 0 {
		n += 1 + sovProduct(uint64(m.DiscountPercent))
	}
	if m.UpdatedDiscountPercent != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedDiscountPercent))
	}
	if m.StockAvailability {
		n += 3
	}
	if m.UpdatedStockAvailability {
		n += 3
	}
	if m.Weight != 0 {
		n += 6
	}
	if m.UpdatedWeight != 0 {
		n += 6
	}
	if m.Price != 0 {
		n += 2 + sovProduct(uint64(m.Price))
	}
	if m.UpdatedPrice != 0 {
		n += 2 + sovProduct(uint64(m.UpdatedPrice))
	}
	if m.IsStatusUpdated {
		n += 3
	}
	if m.IsDiscountPercentUpdated {
		n += 3
	}
	if m.IsStockAvailabilityUpdated {
		n += 3
	}
	if m.IsWeightUpdated {
		n += 3
	}
	if m.IsPriceUpdated {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRedisByKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, s := range m.Params {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRedisByKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VasUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.Time != 0 {
		n += 1 + sovProduct(uint64(m.Time))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovProduct(uint64(m.Position))
	}
	if m.TypeUp != 0 {
		n += 1 + sovProduct(uint64(m.TypeUp))
	}
	if m.ProductExternalId != 0 {
		n += 1 + sovProduct(uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VasUpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ProductExternalId != 0 {
		n += 1 + sovProduct(uint64(m.ProductExternalId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepushRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProductIds) > 0 {
		l = 0
		for _, e := range m.ProductIds {
			l += sovProduct(uint64(e))
		}
		n += 1 + sovProduct(uint64(l)) + l
	}
	if m.RepushEs {
		n += 2
	}
	if m.RepushRedis {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepushResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtendedShippingPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsUsingInstant {
		n += 2
	}
	if m.IsUsingInDay {
		n += 2
	}
	if m.IsSelfShipping {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Variant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	l = len(m.AttributeHash)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.PromotionStartDate != 0 {
		n += 1 + sovProduct(uint64(m.PromotionStartDate))
	}
	if m.PromotionEndDate != 0 {
		n += 1 + sovProduct(uint64(m.PromotionEndDate))
	}
	if m.PromotionPercent != 0 {
		n += 5
	}
	if m.IsPromotion != 0 {
		n += 1 + sovProduct(uint64(m.IsPromotion))
	}
	l = len(m.SkuUser)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.SpecialPrice != 0 {
		n += 9
	}
	if m.FinalPrice != 0 {
		n += 9
	}
	if m.Quantity != 0 {
		n += 1 + sovProduct(uint64(m.Quantity))
	}
	if m.Order != 0 {
		n += 1 + sovProduct(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VariantAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProduct(uint64(m.Id))
	}
	if m.OptionId != 0 {
		n += 1 + sovProduct(uint64(m.OptionId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdsService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopAds != 0 {
		n += 1 + sovProduct(uint64(m.ShopAds))
	}
	if m.AdPlus != 0 {
		n += 1 + sovProduct(uint64(m.AdPlus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProductsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProductSkus) > 0 {
		for _, e := range m.ProductSkus {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.DataConfig != nil {
		l = m.DataConfig.Size()
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetProductsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Products) > 0 {
		for _, e := range m.Products {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductDetailSku) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	if m.ProductExternalId != 0 {
		n += 1 + sovProduct(uint64(m.ProductExternalId))
	}
	if m.AdminId != 0 {
		n += 1 + sovProduct(uint64(m.AdminId))
	}
	if m.SellerAdminId != 0 {
		n += 1 + sovProduct(uint64(m.SellerAdminId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.CatPath)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.CategoryId)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.BrandId != 0 {
		n += 1 + sovProduct(uint64(m.BrandId))
	}
	if m.StockStatus != 0 {
		n += 1 + sovProduct(uint64(m.StockStatus))
	}
	if m.StatusNew != 0 {
		n += 1 + sovProduct(uint64(m.StatusNew))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.FinalPrice != 0 {
		n += 9
	}
	if m.IsPromotion != 0 {
		n += 1 + sovProduct(uint64(m.IsPromotion))
	}
	if m.PromotionPercent != 0 {
		n += 5
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.Quantity != 0 {
		n += 2 + sovProduct(uint64(m.Quantity))
	}
	if m.Weight != 0 {
		n += 6
	}
	if m.HeightProduct != 0 {
		n += 6
	}
	if m.WitdhProduct != 0 {
		n += 6
	}
	if m.LengthProduct != 0 {
		n += 6
	}
	l = len(m.Sku)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.ProductSkuUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.VariantSkuUser)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	l = len(m.AttributeHash)
	if l > 0 {
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.IsConfigVariant {
		n += 3
	}
	if m.IsValidAttributeHash {
		n += 3
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.ExtendedShippingPackage != nil {
		l = m.ExtendedShippingPackage.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if m.Promotion != nil {
		l = m.Promotion.Size()
		n += 2 + l + sovProduct(uint64(l))
	}
	if len(m.ProductAttributes) > 0 {
		for _, e := range m.ProductAttributes {
			l = e.Size()
			n += 2 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkuAttributeOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProduct(uint64(m.Id))
	}
	if m.OptionId != 0 {
		n += 1 + sovProduct(uint64(m.OptionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductSkuFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.AttributeHash)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductsFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProductSkus) > 0 {
		for _, e := range m.ProductSkus {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductDataConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovProduct(uint64(m.Source))
	}
	if m.CheckPromotion {
		n += 2
	}
	if m.GetProductAttributes {
		n += 2
	}
	if m.GetFuturePromotion {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductVariationAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProduct(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.OptionId != 0 {
		n += 1 + sovProduct(uint64(m.OptionId))
	}
	l = len(m.OptionValue)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ColorType != 0 {
		n += 1 + sovProduct(uint64(m.ColorType))
	}
	l = len(m.ColorValue)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EsErrorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetryNumber != 0 {
		n += 1 + sovProduct(uint64(m.RetryNumber))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovProduct(uint64(m.TimeStamp))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovProduct(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EsReindexLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if m.ProductId != 0 {
		n += 1 + sovProduct(uint64(m.ProductId))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.ErrorResponses) > 0 {
		for _, e := range m.ErrorResponses {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovProduct(uint64(m.Status))
	}
	if m.StatusCode != 0 {
		n += 1 + sovProduct(uint64(m.StatusCode))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovProduct(uint64(m.UpdatedAt))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovProduct(uint64(m.CreatedAt))
	}
	if m.RetryCount != 0 {
		n += 1 + sovProduct(uint64(m.RetryCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepeatedFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EsReindexLogListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovProduct(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovProduct(uint64(m.Limit))
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	l = len(m.OrderBy)
	if l > 0 {
		n += 1 + l + sovProduct(uint64(l))
	}
	if len(m.Filters) > 0 {
		for k, v := range m.Filters {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProduct(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProduct(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProduct(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EsReindexLogListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovProduct(uint64(m.Total))
	}
	if m.TotalPage != 0 {
		n += 1 + sovProduct(uint64(m.TotalPage))
	}
	if m.CurrentPage != 0 {
		n += 1 + sovProduct(uint64(m.CurrentPage))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovProduct(uint64(l))
		}
	}
	if m.Size_ != 0 {
		n += 1 + sovProduct(uint64(m.Size_))
	}
	if m.NextPage != 0 {
		n += 1 + sovProduct(uint64(m.NextPage))
	}
	if m.PrevPage != 0 {
		n += 1 + sovProduct(uint64(m.PrevPage))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovProduct(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProduct(x uint64) (n int) {
	return sovProduct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateByRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateByRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateByRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateBy == nil {
				m.UpdateBy = &UpdateBy{}
			}
			if err := m.UpdateBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &UpdateByFields{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.FieldMask{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTypeShopMallRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTypeShopMallRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTypeShopMallRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateType", wireType)
			}
			m.UpdateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonReject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReasonReject == nil {
				m.ReasonReject = &Reason{}
			}
			if err := m.ReasonReject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReasonCancel == nil {
				m.ReasonCancel = &Reason{}
			}
			if err := m.ReasonCancel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTypeShopMallResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTypeShopMallResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTypeShopMallResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateByResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateByResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateByResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateBy == nil {
				m.UpdateBy = &UpdateBy{}
			}
			if err := m.UpdateBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &UpdateRequest{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &UpdateResponse{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &ProductUpdate{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.FieldMask{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ProductAdd{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sorts = append(m.Sorts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &Filters{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &base.Pagination{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetaData = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProductAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceFrom", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriceFrom = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTo", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriceTo = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOff", wireType)
			}
			m.IsOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsOff |= (Filters_IsBoolInt(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDateFrom", wireType)
			}
			m.UpdatedDateFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedDateFrom |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDateTo", wireType)
			}
			m.UpdatedDateTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedDateTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductIds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterType", wireType)
			}
			m.FilterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewFromDate", wireType)
			}
			m.ReviewFromDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewFromDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewToDate", wireType)
			}
			m.ReviewToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReview", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsReview = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReviewType", wireType)
			}
			m.IsReviewType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReviewType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShopType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShopName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatingFrom", wireType)
			}
			m.RatingFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatingFrom |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatingTo", wireType)
			}
			m.RatingTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatingTo |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionPercentFrom", wireType)
			}
			m.PromotionPercentFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionPercentFrom |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionPercentTo", wireType)
			}
			m.PromotionPercentTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionPercentTo |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionApp", wireType)
			}
			m.PromotionApp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionApp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopFreeShipping", wireType)
			}
			m.ShopFreeShipping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopFreeShipping |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCertified", wireType)
			}
			m.IsCertified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCertified |= (Filters_IsBoolInt(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellerAdminId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToDate", wireType)
			}
			m.PromotionToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideProductType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideProductType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPriceFrom", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPriceFrom = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPriceTo", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPriceTo = float64(math.Float64frombits(v))
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderComplete_30From", wireType)
			}
			m.OrderComplete_30From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderComplete_30From |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderComplete_30To", wireType)
			}
			m.OrderComplete_30To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderComplete_30To |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCertificate", wireType)
			}
			m.HasCertificate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasCertificate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			m.ExtendedShippingPackage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtendedShippingPackage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductExternalIds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfigVariant", wireType)
			}
			m.IsConfigVariant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsConfigVariant |= (Filters_IsBoolInt(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Product{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaData == nil {
				m.MetaData = &MetaData{}
			}
			if err := m.MetaData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rating = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImages = append(m.ProductImages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReview = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewDate", wireType)
			}
			m.ReviewDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductCertificate = append(m.ProductCertificate, &ProductCertificate{})
			if err := m.ProductCertificate[len(m.ProductCertificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrandName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShopName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPrice = float64(math.Float64frombits(v))
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionPercent", wireType)
			}
			m.PromotionPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionPercent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNo", wireType)
			}
			m.VersionNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCertified", wireType)
			}
			m.IsCertified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCertified |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopFreeShipping", wireType)
			}
			m.ShopFreeShipping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopFreeShipping |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionApp", wireType)
			}
			m.PromotionApp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionApp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderComplete_30", wireType)
			}
			m.OrderComplete_30 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderComplete_30 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnable = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopType", wireType)
			}
			m.ShopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdated", wireType)
			}
			m.IsUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsUpdated |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToDate", wireType)
			}
			m.PromotionToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SpecialPrice = float64(math.Float64frombits(v))
		case 45:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatingPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RatingPercent = float32(math.Float32frombits(v))
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CategoryLevels == nil {
				m.CategoryLevels = &CategoryLevels{}
			}
			if err := m.CategoryLevels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionNote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromotionNote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOff = bool(v != 0)
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vasup", wireType)
			}
			m.Vasup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vasup |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LengthProduct = float32(math.Float32frombits(v))
		case 54:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeightProduct = float32(math.Float32frombits(v))
		case 55:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitdhProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WitdhProduct = float32(math.Float32frombits(v))
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingImages = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendedShippingPackage == nil {
				m.ExtendedShippingPackage = &ExtendedShippingPackage{}
			}
			if err := m.ExtendedShippingPackage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfigVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConfigVariant = bool(v != 0)
		case 60:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriceMax = float64(math.Float64frombits(v))
		case 61:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPriceMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPriceMax = float64(math.Float64frombits(v))
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVariant", wireType)
			}
			m.TotalVariant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalVariant |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInvalidVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInvalidVariant = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryIds = append(m.CategoryIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryIds) == 0 {
					m.CategoryIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryIds = append(m.CategoryIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryIds", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptionScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DescriptionScore = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LengthProduct = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeightProduct = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitdhProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WitdhProduct = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnable = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOptions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOptions = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeProduct", wireType)
			}
			m.TypeProduct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeProduct |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImages = append(m.ProductImages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagsKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRelateds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductRelateds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBrand", wireType)
			}
			m.IsBrand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBrand |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalAttributes == nil {
				m.AdditionalAttributes = &AttributeOptions{}
			}
			if err := m.AdditionalAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoScore", wireType)
			}
			m.SeoScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeoScore |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateFile = append(m.CertificateFile, &ProductCertificate{})
			if err := m.CertificateFile[len(m.CertificateFile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopType", wireType)
			}
			m.ShopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDate", wireType)
			}
			m.StatusDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusDate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReview = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReviewType", wireType)
			}
			m.IsReviewType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReviewType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterType", wireType)
			}
			m.FilterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdated", wireType)
			}
			m.IsUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsUpdated |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToDate", wireType)
			}
			m.PromotionToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SpecialPrice = float64(math.Float64frombits(v))
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionNote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromotionNote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendedShippingPackage == nil {
				m.ExtendedShippingPackage = &ExtendedShippingPackage{}
			}
			if err := m.ExtendedShippingPackage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptionScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DescriptionScore = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LengthProduct = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeightProduct = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitdhProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WitdhProduct = float32(math.Float32frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			m.CategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CategoryId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOptions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOptions = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeProduct", wireType)
			}
			m.TypeProduct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeProduct |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImages = append(m.ProductImages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagsKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRelateds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductRelateds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBrand", wireType)
			}
			m.IsBrand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsBrand |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalAttributes == nil {
				m.AdditionalAttributes = &AttributeOptions{}
			}
			if err := m.AdditionalAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoScore", wireType)
			}
			m.SeoScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeoScore |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateFile = append(m.CertificateFile, &ProductCertificate{})
			if err := m.CertificateFile[len(m.CertificateFile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDate", wireType)
			}
			m.StatusDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReview = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReviewType", wireType)
			}
			m.IsReviewType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReviewType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterType", wireType)
			}
			m.FilterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnable = bool(v != 0)
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewDate", wireType)
			}
			m.ReviewDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 49:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SpecialPrice = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdated", wireType)
			}
			m.IsUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsUpdated |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToDate", wireType)
			}
			m.PromotionToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionNote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromotionNote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CabinetList = append(m.CabinetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CabinetList) == 0 {
					m.CabinetList = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CabinetList = append(m.CabinetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CabinetList", wireType)
			}
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendedShippingPackage == nil {
				m.ExtendedShippingPackage = &ExtendedShippingPackage{}
			}
			if err := m.ExtendedShippingPackage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShopUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShopUpdate = bool(v != 0)
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEvent", wireType)
			}
			m.IsEvent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEvent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiData = append(m.MultiData, &AttributeOption{})
			if err := m.MultiData[len(m.MultiData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleData = append(m.SingleData, &AttributeOption{})
			if err := m.SingleData[len(m.SingleData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextData = append(m.TextData, &AttributeOption{})
			if err := m.TextData[len(m.TextData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData, &CustomAttribute{})
			if err := m.CustomData[len(m.CustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Images == nil {
				m.Images = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProduct
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProduct
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProduct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProduct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Images[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueCustom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueCustom = append(m.ValueCustom, &ValueCustom{})
			if err := m.ValueCustom[len(m.ValueCustom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeId", wireType)
			}
			m.AttributeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeId", wireType)
			}
			m.AttributeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeType", wireType)
			}
			m.AttributeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRequired", wireType)
			}
			m.ShowRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowRequired |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeValue = append(m.AttributeValue, &AttributeValue{})
			if err := m.AttributeValue[len(m.AttributeValue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCustom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCustom = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCheckout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCheckout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdTemp", wireType)
			}
			m.IdTemp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdTemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &ValueCustom{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Images == nil {
				m.Images = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProduct
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProduct
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProduct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProduct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Images[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueCustom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueCustom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueCustom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionIdTemp", wireType)
			}
			m.OptionIdTemp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionIdTemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorHexRgb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColorHexRgb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image_50X50", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image_50X50 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image_500X500", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image_500X500 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorType", wireType)
			}
			m.ColorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorType |= (ColorType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCustom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCustom = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product_certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product_certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CategoryId = append(m.CategoryId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CategoryId) == 0 {
					m.CategoryId = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CategoryId = append(m.CategoryId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StatusNew = append(m.StatusNew, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StatusNew) == 0 {
					m.StatusNew = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StatusNew = append(m.StatusNew, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateByFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateByFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateByFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOff", wireType)
			}
			m.IsOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsOff |= (CountRequest_IsBoolInt(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCache", wireType)
			}
			m.ResetCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCache |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVariantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVariantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVariantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVariantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVariantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVariantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNo", wireType)
			}
			m.VersionNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.FieldMask{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVariantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVariantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVariantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &UpdateVariantResponse{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVariantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVariantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVariantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryLevels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryLevels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryLevels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat1Id", wireType)
			}
			m.Cat1Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cat1Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat2Id", wireType)
			}
			m.Cat2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cat2Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat3Id", wireType)
			}
			m.Cat3Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cat3Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat4Id", wireType)
			}
			m.Cat4Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cat4Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat2Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat2Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat3Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat3Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cat4Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cat4Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductRelated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductRelated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductRelated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNo", wireType)
			}
			m.VersionNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CategoryLevels == nil {
				m.CategoryLevels = &CategoryLevels{}
			}
			if err := m.CategoryLevels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImages = append(m.ProductImages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagsKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoKeyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoKeyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoScore", wireType)
			}
			m.SeoScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeoScore |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeightProduct = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitdhProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WitdhProduct = float32(math.Float32frombits(v))
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LengthProduct = float32(math.Float32frombits(v))
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoInfo = append(m.VideoInfo, &ProductVideo{})
			if err := m.VideoInfo[len(m.VideoInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopType", wireType)
			}
			m.ShopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRelateds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductRelateds = append(m.ProductRelateds, &ProductRelated{})
			if err := m.ProductRelateds[len(m.ProductRelateds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cprice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cprice = float64(math.Float64frombits(v))
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialPrice", wireType)
			}
			m.SpecialPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialPrice |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnable = bool(v != 0)
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrandName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReview = bool(v != 0)
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewDate", wireType)
			}
			m.ReviewDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductCertificate = append(m.ProductCertificate, &ProductCertificate{})
			if err := m.ProductCertificate[len(m.ProductCertificate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOff = bool(v != 0)
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionToDate", wireType)
			}
			m.PromotionToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionToDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionNote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromotionNote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendedShippingPackage == nil {
				m.ExtendedShippingPackage = &ExtendedShippingPackage{}
			}
			if err := m.ExtendedShippingPackage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfigVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConfigVariant = bool(v != 0)
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatingPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RatingPercent = float32(math.Float32frombits(v))
		case 61:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPrice = float64(math.Float64frombits(v))
		case 62:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriceMax = float64(math.Float64frombits(v))
		case 63:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPriceMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPriceMax = float64(math.Float64frombits(v))
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInvalidVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInvalidVariant = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductVariants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductVariants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductVariants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionNo", wireType)
			}
			m.VersionNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionNo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInvalidVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInvalidVariant = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateFilesFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateFilesFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateFilesFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCertificateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCertificateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCertificateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &CertificateFilesFilters{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ProductCertificate{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &base.Pagination{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ProductHistory{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaData == nil {
				m.MetaData = &MetaData{}
			}
			if err := m.MetaData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedStatus", wireType)
			}
			m.UpdatedStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDate", wireType)
			}
			m.UpdatedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountPercent", wireType)
			}
			m.DiscountPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDiscountPercent", wireType)
			}
			m.UpdatedDiscountPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedDiscountPercent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockAvailability", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StockAvailability = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedStockAvailability", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatedStockAvailability = bool(v != 0)
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdatedWeight = float32(math.Float32frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedPrice", wireType)
			}
			m.UpdatedPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedPrice |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStatusUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStatusUpdated = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDiscountPercentUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDiscountPercentUpdated = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStockAvailabilityUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStockAvailabilityUpdated = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWeightUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWeightUpdated = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPriceUpdated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPriceUpdated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &VasUp{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &VasUpResponse{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRedisByKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRedisByKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRedisByKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRedisByKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRedisByKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRedisByKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VasUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VasUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VasUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUp", wireType)
			}
			m.TypeUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeUp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VasUpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VasUpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VasUpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepushRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepushRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepushRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProductIds = append(m.ProductIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProduct
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProductIds) == 0 {
					m.ProductIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProductIds = append(m.ProductIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepushEs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepushEs = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepushRedis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepushRedis = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepushResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepushResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepushResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendedShippingPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedShippingPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedShippingPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsingInstant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsingInstant = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsingInDay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsingInDay = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSelfShipping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSelfShipping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &VariantAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionStartDate", wireType)
			}
			m.PromotionStartDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionStartDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionEndDate", wireType)
			}
			m.PromotionEndDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotionEndDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PromotionPercent = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SpecialPrice = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPrice = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariantAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariantAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariantAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdsService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopAds", wireType)
			}
			m.ShopAds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopAds |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdPlus", wireType)
			}
			m.AdPlus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdPlus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProductsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProductsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProductsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSkus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSkus = append(m.ProductSkus, &ProductSkuFilters{})
			if err := m.ProductSkus[len(m.ProductSkus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataConfig == nil {
				m.DataConfig = &ProductDataConfiguration{}
			}
			if err := m.DataConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProductsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProductsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProductsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Products", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Products = append(m.Products, &ProductDetailSku{})
			if err := m.Products[len(m.Products)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductDetailSku) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductDetailSku: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductDetailSku: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductExternalId", wireType)
			}
			m.ProductExternalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductExternalId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAdminId", wireType)
			}
			m.SellerAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAdminId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CatPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			m.BrandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrandId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockStatus", wireType)
			}
			m.StockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StockStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusNew", wireType)
			}
			m.StatusNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FinalPrice = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPromotion", wireType)
			}
			m.IsPromotion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPromotion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotionPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PromotionPercent = float32(math.Float32frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeightProduct = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitdhProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WitdhProduct = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthProduct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LengthProduct = float32(math.Float32frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSkuUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSkuUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfigVariant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConfigVariant = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValidAttributeHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValidAttributeHash = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &ProductVariationAttributes{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedShippingPackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendedShippingPackage == nil {
				m.ExtendedShippingPackage = &ExtendedShippingPackage{}
			}
			if err := m.ExtendedShippingPackage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Promotion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Promotion == nil {
				m.Promotion = &flashdeal.FlashDeal{}
			}
			if err := m.Promotion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductAttributes = append(m.ProductAttributes, &Attribute{})
			if err := m.ProductAttributes[len(m.ProductAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkuAttributeOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkuAttributeOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkuAttributeOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSkuFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSkuFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSkuFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductsFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductsFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductsFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSkus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSkus = append(m.ProductSkus, &ProductSkuFilters{})
			if err := m.ProductSkus[len(m.ProductSkus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductDataConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductDataConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductDataConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (ProductDataConfiguration_DataSource(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPromotion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckPromotion = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetProductAttributes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetProductAttributes = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFuturePromotion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetFuturePromotion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductVariationAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductVariationAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductVariationAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionId", wireType)
			}
			m.OptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorType", wireType)
			}
			m.ColorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColorType |= (ColorType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EsErrorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EsErrorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EsErrorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryNumber", wireType)
			}
			m.RetryNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EsReindexLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EsReindexLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EsReindexLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorResponses = append(m.ErrorResponses, &EsErrorResponse{})
			if err := m.ErrorResponses[len(m.ErrorResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCount", wireType)
			}
			m.RetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EsReindexLogListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EsReindexLogListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EsReindexLogListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = make(map[string]*RepeatedFilter)
			}
			var mapkey string
			var mapvalue *RepeatedFilter
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProduct
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProduct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProduct
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthProduct
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RepeatedFilter{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProduct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProduct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Filters[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EsReindexLogListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EsReindexLogListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EsReindexLogListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPage", wireType)
			}
			m.TotalPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPage", wireType)
			}
			m.CurrentPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProduct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &EsReindexLog{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPage", wireType)
			}
			m.NextPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevPage", wireType)
			}
			m.PrevPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProduct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProduct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProduct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProduct
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProduct
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProduct(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProduct = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProduct   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("product/product.proto", fileDescriptor_product_e20d6eceb1f56627) }

var fileDescriptor_product_e20d6eceb1f56627 = []byte{
	// 6379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x4b, 0x8c, 0x1c, 0x49,
	0x5a, 0xff, 0x56, 0x55, 0x57, 0x75, 0x55, 0x54, 0x3f, 0xaa, 0xc3, 0xed, 0x76, 0xba, 0x6c, 0xb7,
	0xdb, 0x39, 0xb6, 0xa7, 0xfd, 0xea, 0xb6, 0xdb, 0x9e, 0x97, 0x77, 0x1e, 0x6b, 0x7b, 0xda, 0x5e,
	0x6b, 0x3c, 0x63, 0xff, 0xd3, 0xf6, 0x6a, 0xff, 0x3b, 0x88, 0xdc, 0xec, 0xaa, 0xe8, 0xee, 0xa4,
	0xab, 0x2b, 0x6b, 0x32, 0xb3, 0x6c, 0x37, 0xc3, 0x0a, 0x01, 0xe2, 0xb0, 0x42, 0x2b, 0xf1, 0xd2,
	0x82, 0x04, 0x12, 0x42, 0xe2, 0x84, 0x84, 0x58, 0x89, 0xdb, 0x1e, 0x90, 0x00, 0xf1, 0x38, 0x22,
	0x38, 0x21, 0x2e, 0x68, 0xc5, 0x81, 0x2b, 0x12, 0x47, 0x84, 0x50, 0x7c, 0xf1, 0xc8, 0x88, 0xc8,
	0xc8, 0xec, 0xea, 0x9d, 0x01, 0x71, 0x98, 0x8b, 0xbb, 0xe2, 0x8b, 0xf7, 0x17, 0x11, 0xdf, 0xf7,
	0xfb, 0xbe, 0xf8, 0x32, 0x8c, 0x8e, 0x8f, 0xe2, 0xa8, 0x3f, 0xee, 0xa5, 0xeb, 0xfc, 0xef, 0xda,
	0x28, 0x8e, 0xd2, 0x08, 0x2f, 0x26, 0x64, 0xd8, 0x8f, 0xd6, 0x5e, 0xdc, 0x58, 0x0b, 0x46, 0xe1,
	0x1a, 0xcf, 0xeb, 0x9e, 0xde, 0x89, 0xa2, 0x9d, 0x01, 0x59, 0x0f, 0x46, 0xe1, 0x7a, 0x30, 0x1c,
	0x46, 0x69, 0x90, 0x86, 0xd1, 0x30, 0x61, 0x75, 0xba, 0xf3, 0x5b, 0x41, 0x42, 0xd6, 0xe9, 0x3f,
	0x9c, 0xb0, 0xc2, 0x8b, 0x43, 0x6a, 0x6b, 0xbc, 0xbd, 0xbe, 0x1d, 0x92, 0x41, 0xdf, 0xdf, 0x0f,
	0x92, 0x3d, 0x5e, 0x62, 0x55, 0xf4, 0xbe, 0x3d, 0x08, 0x92, 0xdd, 0x3e, 0x09, 0x06, 0x62, 0x1c,
	0x92, 0xc0, 0x4a, 0xba, 0x7f, 0x59, 0x41, 0xf3, 0xcf, 0x47, 0xfd, 0x20, 0x25, 0x77, 0x0f, 0x3c,
	0xf2, 0xd9, 0x98, 0x24, 0x29, 0xfe, 0x3a, 0x6a, 0x8d, 0x81, 0xe4, 0x6f, 0x1d, 0x38, 0x95, 0x95,
	0xca, 0x6a, 0x7b, 0x63, 0x79, 0xcd, 0x36, 0xf0, 0x35, 0x59, 0xb3, 0x39, 0xe6, 0xbf, 0xf0, 0xfb,
	0x68, 0x9a, 0xe7, 0x3a, 0x55, 0xa8, 0x7a, 0xbe, 0xbc, 0xea, 0x7d, 0x3a, 0xf6, 0xc4, 0x13, 0x95,
	0xf0, 0x06, 0x6a, 0xc0, 0x74, 0x12, 0xa7, 0x06, 0xd5, 0xbb, 0x6b, 0x6c, 0xb6, 0x6b, 0x62, 0xb6,
	0x6b, 0x50, 0xe3, 0xe3, 0x20, 0xd9, 0xf3, 0x78, 0x49, 0xf7, 0xb7, 0xab, 0xe8, 0x24, 0x6b, 0xef,
	0xd9, 0xc1, 0x88, 0x3c, 0xdd, 0x8d, 0x46, 0x1f, 0x07, 0x83, 0x81, 0x98, 0xce, 0x39, 0xd4, 0xe6,
	0xd3, 0x49, 0x0f, 0x46, 0x04, 0x26, 0x34, 0xeb, 0xcd, 0x30, 0x52, 0x1f, 0x68, 0xd8, 0x45, 0x32,
	0x3d, 0x4e, 0x48, 0x0c, 0x23, 0x6f, 0x79, 0x1a, 0x0d, 0xdf, 0x45, 0xb3, 0x31, 0x09, 0x92, 0x68,
	0xe8, 0xc7, 0xe4, 0xe7, 0x48, 0x2f, 0xe5, 0xe3, 0x3b, 0x6d, 0x9f, 0x9e, 0x07, 0x45, 0x3d, 0xbd,
	0x8a, 0xd2, 0x46, 0x2f, 0x18, 0xf6, 0xc8, 0xc0, 0x99, 0x3a, 0x42, 0x1b, 0xac, 0x0a, 0x5e, 0x45,
	0xf3, 0x09, 0x19, 0x0c, 0x48, 0xec, 0x07, 0xfd, 0xfd, 0x70, 0xe8, 0x87, 0x7d, 0xa7, 0x0e, 0x53,
	0x32, 0xc9, 0xae, 0x87, 0x1a, 0xac, 0x09, 0xbc, 0x82, 0xda, 0xa2, 0x91, 0xa8, 0xcf, 0x58, 0xd0,
	0xf2, 0x54, 0x12, 0xbe, 0x88, 0xe6, 0x64, 0x72, 0x7f, 0x9f, 0x0c, 0x53, 0xce, 0x03, 0x83, 0xea,
	0x9e, 0x46, 0x5d, 0x1b, 0xa7, 0x93, 0x51, 0x34, 0x4c, 0x88, 0xfb, 0x18, 0x75, 0xb2, 0xcd, 0xc4,
	0x68, 0x5f, 0x68, 0x37, 0xb9, 0x0f, 0xd1, 0x1c, 0xa3, 0x26, 0x62, 0x35, 0xdf, 0x42, 0x53, 0xfd,
	0x20, 0x0d, 0x9c, 0xca, 0x4a, 0x6d, 0xb5, 0xbd, 0xf1, 0x5a, 0x59, 0x4b, 0xbc, 0x8a, 0x07, 0x15,
	0xdc, 0x8f, 0xc4, 0x46, 0x4f, 0xe4, 0xd0, 0xde, 0x46, 0x53, 0x83, 0x30, 0x49, 0x79, 0x5b, 0xe7,
	0xcb, 0xdb, 0x62, 0x75, 0x3c, 0xa8, 0xe1, 0xfe, 0x61, 0x05, 0xcd, 0x6a, 0x9d, 0xe0, 0x33, 0x08,
	0xf1, 0x1a, 0x74, 0x45, 0xd8, 0x26, 0x6b, 0x71, 0xca, 0xc3, 0x3e, 0x7e, 0xcf, 0x3c, 0x16, 0x05,
	0x23, 0x7f, 0xc2, 0xfe, 0xf2, 0xb6, 0xbf, 0xd0, 0xa9, 0xb8, 0x2e, 0x78, 0x27, 0xe7, 0xbb, 0x6c,
	0x19, 0xa3, 0x42, 0x71, 0xef, 0x22, 0x74, 0xa7, 0xdf, 0x17, 0x33, 0xba, 0x25, 0x39, 0x4d, 0x7b,
	0x5c, 0x29, 0x1d, 0x2f, 0xad, 0xc6, 0xd8, 0x7c, 0x0d, 0xb5, 0xa1, 0x8d, 0x09, 0xbb, 0xfc, 0xa7,
	0x0a, 0x6a, 0x3f, 0x0a, 0x93, 0x54, 0x74, 0xba, 0x88, 0xea, 0x49, 0x14, 0xa7, 0x09, 0xac, 0x49,
	0xcb, 0x63, 0x09, 0xfc, 0x16, 0x9a, 0xde, 0x0e, 0x07, 0x29, 0x89, 0x13, 0xce, 0xbd, 0x33, 0xf6,
	0xd1, 0xdc, 0x67, 0x85, 0x3c, 0x51, 0x1a, 0xbf, 0x87, 0xd0, 0x28, 0xd8, 0x09, 0x87, 0x20, 0x50,
	0x39, 0xef, 0x8c, 0xba, 0x20, 0x58, 0x9f, 0xc8, 0x42, 0x9e, 0x52, 0x01, 0x9f, 0x42, 0xad, 0x7d,
	0x92, 0x06, 0x3e, 0xf0, 0x81, 0x9e, 0xd5, 0xa6, 0xd7, 0xa4, 0x84, 0x0f, 0x83, 0x34, 0xc0, 0x67,
	0x51, 0x5b, 0x4c, 0x24, 0x18, 0x0c, 0xe0, 0x10, 0x36, 0xe5, 0xdc, 0xee, 0x0c, 0x06, 0xee, 0x9f,
	0xcf, 0xa1, 0x69, 0x3e, 0x22, 0x7a, 0x02, 0x7b, 0x41, 0x4a, 0x76, 0xa2, 0xf8, 0x20, 0x63, 0x84,
	0x4a, 0xa2, 0x9c, 0x4a, 0xd2, 0x20, 0x1d, 0x27, 0xfe, 0x90, 0xbc, 0xe4, 0xa7, 0x4f, 0xa1, 0x50,
	0x19, 0x95, 0xa4, 0x51, 0x6f, 0xcf, 0x67, 0x34, 0x98, 0x4c, 0xdd, 0xd3, 0x68, 0x18, 0xa3, 0xa9,
	0x61, 0xb0, 0x4f, 0x60, 0xa8, 0x2d, 0x0f, 0x7e, 0xe3, 0x0e, 0xaa, 0x25, 0x7b, 0x63, 0x18, 0x5e,
	0xcb, 0xa3, 0x3f, 0xd9, 0x9a, 0x84, 0x3d, 0xe2, 0x6f, 0xc7, 0xd1, 0xbe, 0xd3, 0x58, 0xa9, 0xac,
	0x56, 0x3c, 0x85, 0x82, 0xbb, 0xa8, 0xc9, 0x52, 0x69, 0xe4, 0x4c, 0x43, 0xae, 0x4c, 0xd3, 0x51,
	0x84, 0x89, 0x3f, 0x8a, 0xa3, 0xfd, 0x08, 0x58, 0xda, 0x64, 0xd2, 0x54, 0xa5, 0xe1, 0x0f, 0x50,
	0x23, 0x4c, 0xfc, 0x68, 0x7b, 0xdb, 0x69, 0xad, 0x54, 0x56, 0xe7, 0x36, 0x5e, 0x2f, 0x5d, 0xac,
	0xb5, 0x87, 0xc9, 0xdd, 0x28, 0x1a, 0x3c, 0x1c, 0xa6, 0x1e, 0xaf, 0x86, 0xaf, 0xa2, 0x05, 0x21,
	0x7a, 0x41, 0x70, 0xc0, 0x38, 0xd1, 0x4a, 0x65, 0xb5, 0xe6, 0xe5, 0x33, 0xa8, 0x40, 0xd4, 0x88,
	0x69, 0xe4, 0xb4, 0xa1, 0xac, 0x49, 0xa6, 0x8b, 0x90, 0x6d, 0xbd, 0xc4, 0x99, 0x61, 0x62, 0x50,
	0x21, 0xd1, 0x12, 0x6c, 0xeb, 0x30, 0x5d, 0x31, 0xcb, 0x96, 0x49, 0x21, 0x51, 0xe6, 0x04, 0x49,
	0x12, 0xee, 0x0c, 0x09, 0x71, 0xe6, 0xa0, 0x01, 0x99, 0xc6, 0x97, 0x51, 0x27, 0x26, 0x2f, 0x42,
	0xf2, 0x12, 0x06, 0x06, 0xdd, 0x3a, 0xf3, 0x30, 0x94, 0x1c, 0x9d, 0x09, 0x5c, 0xa0, 0xa5, 0x11,
	0x2b, 0xd9, 0x81, 0x92, 0x06, 0x95, 0xf6, 0xf7, 0xd9, 0x38, 0x18, 0xa6, 0x61, 0x7a, 0xe0, 0x2c,
	0xc0, 0x92, 0xcb, 0x34, 0x3e, 0x8d, 0x5a, 0x61, 0xe2, 0xb3, 0x0a, 0x0e, 0x86, 0xc1, 0x64, 0x04,
	0xda, 0x83, 0x4c, 0xb0, 0xe9, 0x1c, 0x83, 0xe9, 0x18, 0x54, 0xda, 0xc3, 0x56, 0x1c, 0x0c, 0xfb,
	0x74, 0x5f, 0x2e, 0x42, 0x09, 0x99, 0xa6, 0x3d, 0x24, 0xbb, 0xd1, 0x88, 0x55, 0x3f, 0xce, 0x7a,
	0x90, 0x04, 0xbc, 0x84, 0x1a, 0x7c, 0x33, 0x2e, 0x41, 0x3d, 0x9e, 0x92, 0xb5, 0x60, 0x2f, 0x9e,
	0x50, 0x6a, 0xc1, 0x86, 0xa4, 0xca, 0x28, 0x48, 0xc3, 0xe1, 0x0e, 0x5b, 0x57, 0x87, 0xf1, 0x58,
	0x21, 0xd1, 0xfa, 0x3c, 0x99, 0x46, 0xce, 0x49, 0x26, 0x4a, 0x25, 0x01, 0xbf, 0x89, 0x96, 0xe4,
	0x5e, 0xf3, 0x47, 0x24, 0xee, 0x91, 0x61, 0xca, 0x9a, 0xea, 0x42, 0xd1, 0x82, 0x5c, 0xbc, 0x81,
	0x16, 0xf3, 0x39, 0x69, 0xe4, 0x9c, 0x82, 0x5a, 0xd6, 0x3c, 0x7c, 0x1e, 0xcd, 0x66, 0xf4, 0x60,
	0x34, 0x72, 0x4e, 0x43, 0x61, 0x9d, 0x88, 0xd7, 0x10, 0x86, 0xe9, 0x6d, 0xc7, 0x84, 0xf8, 0xc9,
	0x6e, 0x38, 0x1a, 0x85, 0xc3, 0x1d, 0xe7, 0x0c, 0x14, 0xb5, 0xe4, 0xe0, 0x8f, 0xe0, 0x10, 0xf5,
	0x48, 0x9c, 0x86, 0xdb, 0x21, 0xe9, 0x3b, 0xcb, 0x47, 0x3b, 0x26, 0x5a, 0x65, 0x1b, 0x1e, 0x38,
	0x0b, 0x2c, 0x37, 0xc9, 0x74, 0xa1, 0x93, 0xbd, 0x31, 0x43, 0x38, 0x2b, 0x6c, 0xeb, 0x8a, 0xb4,
	0xce, 0x9c, 0x24, 0x0d, 0xe2, 0x94, 0x6d, 0xca, 0x73, 0xb0, 0x29, 0xad, 0x79, 0xf4, 0x98, 0x66,
	0x74, 0xb1, 0x8b, 0x5d, 0x76, 0x4c, 0x73, 0x19, 0xf8, 0x3a, 0x3a, 0x16, 0x0e, 0x93, 0xb0, 0x4f,
	0x7c, 0x71, 0xe0, 0x60, 0x53, 0xbd, 0x06, 0x03, 0xb1, 0x65, 0xd1, 0xe3, 0xb4, 0x1d, 0x0e, 0x83,
	0x81, 0xaf, 0x48, 0xab, 0xf3, 0x20, 0x8f, 0x72, 0x74, 0xba, 0xd9, 0x55, 0x5a, 0x1a, 0x39, 0x17,
	0xa0, 0xa4, 0x41, 0xa5, 0x9b, 0x27, 0x8a, 0xfb, 0x24, 0xa6, 0x80, 0x66, 0x34, 0x20, 0x29, 0xf1,
	0x6f, 0x5e, 0x67, 0x2d, 0x5f, 0x64, 0x9b, 0xc7, 0x9e, 0x4b, 0xf9, 0x93, 0xcf, 0x49, 0x23, 0xe7,
	0x75, 0xb6, 0x79, 0x6c, 0x79, 0x74, 0x65, 0x76, 0x03, 0xb9, 0x54, 0x54, 0xd6, 0x3b, 0xab, 0x70,
	0x82, 0x4d, 0x32, 0x76, 0xd0, 0xf4, 0x1e, 0x39, 0x78, 0x19, 0xc5, 0x7d, 0xe7, 0x12, 0xf0, 0x43,
	0x24, 0xf1, 0xbb, 0xe8, 0x24, 0x79, 0x95, 0x92, 0x61, 0x9f, 0xf4, 0xe5, 0xfe, 0xf1, 0x47, 0x41,
	0x6f, 0x2f, 0xd8, 0x21, 0xce, 0x65, 0xe0, 0x75, 0x71, 0x01, 0xbe, 0xaa, 0xc0, 0x51, 0x5a, 0x28,
	0xa6, 0xac, 0xa0, 0x92, 0xef, 0x0a, 0x74, 0x62, 0xcd, 0xc3, 0xcf, 0xd1, 0x02, 0xdd, 0x5f, 0xd1,
	0x70, 0x3b, 0xdc, 0xf1, 0x5f, 0x04, 0x71, 0x18, 0x0c, 0x53, 0xe7, 0xea, 0xd1, 0x76, 0x68, 0xbe,
	0x05, 0x77, 0x03, 0xb5, 0x64, 0x3e, 0x46, 0xa8, 0xf1, 0xf0, 0xa9, 0x7f, 0xe7, 0xd1, 0xa3, 0xce,
	0xd7, 0x70, 0x1b, 0x4d, 0x3f, 0x7c, 0xea, 0x3f, 0xf3, 0x9e, 0x6f, 0x76, 0x2a, 0x78, 0x06, 0x35,
	0x1f, 0x3e, 0xf5, 0xef, 0xdf, 0x79, 0xf4, 0x74, 0xb3, 0x53, 0x75, 0x7f, 0x11, 0xcd, 0x30, 0x6c,
	0xc0, 0xc1, 0xc4, 0x0d, 0x0d, 0xaf, 0x9d, 0x29, 0x45, 0x24, 0x0c, 0xa8, 0xe1, 0x77, 0x55, 0x0d,
	0x5e, 0x2d, 0x43, 0x9f, 0x1f, 0x73, 0xbd, 0xee, 0x65, 0x15, 0xdc, 0x1f, 0x63, 0x34, 0xcd, 0xdb,
	0x3b, 0x0c, 0xc9, 0x48, 0xdd, 0x5b, 0xcd, 0xeb, 0xde, 0x5a, 0xa6, 0x7b, 0x97, 0x50, 0x83, 0x49,
	0x32, 0xd0, 0xd1, 0x55, 0x8f, 0xa7, 0xe8, 0xfe, 0x95, 0x6d, 0xed, 0x07, 0x3b, 0x24, 0x71, 0xea,
	0x00, 0x80, 0x0c, 0x2a, 0xc5, 0x47, 0xb0, 0x97, 0xb9, 0xda, 0x66, 0x09, 0x03, 0x3b, 0x30, 0x9d,
	0xac, 0x62, 0x87, 0x15, 0xd4, 0x16, 0x29, 0x3a, 0xc4, 0x16, 0x53, 0x7c, 0x0a, 0x89, 0xb6, 0x20,
	0xb4, 0x65, 0x90, 0x72, 0x5d, 0xab, 0x50, 0xf0, 0x07, 0x08, 0x05, 0x69, 0x1a, 0x87, 0x5b, 0xe3,
	0x94, 0x24, 0x4e, 0x1b, 0x16, 0xe0, 0xac, 0x9d, 0x91, 0x77, 0x44, 0x39, 0x4f, 0xa9, 0x92, 0x83,
	0x2f, 0x33, 0x0c, 0x38, 0x68, 0xf0, 0xa5, 0x8b, 0x9a, 0xbd, 0x20, 0xf5, 0x47, 0x41, 0xba, 0x0b,
	0xaa, 0xb7, 0xe5, 0xc9, 0x74, 0xce, 0x44, 0x9b, 0xb3, 0x98, 0x68, 0x9a, 0x3e, 0x9c, 0x07, 0x3c,
	0xa6, 0xe8, 0x43, 0x30, 0x82, 0x40, 0xed, 0x29, 0xea, 0x56, 0x25, 0x69, 0xba, 0x7d, 0xc1, 0xd0,
	0xed, 0x86, 0x09, 0x85, 0xf3, 0x26, 0xd4, 0xa7, 0xe8, 0x98, 0x58, 0x2c, 0xf5, 0xc8, 0x1f, 0x03,
	0x5e, 0x5d, 0x2a, 0xdd, 0xac, 0x6a, 0x05, 0xcf, 0xd6, 0x8a, 0x4d, 0xca, 0x2f, 0x5a, 0xad, 0x3e,
	0xba, 0x92, 0x4c, 0x7d, 0xc3, 0x52, 0x33, 0x9d, 0xad, 0x50, 0xa8, 0x4a, 0x93, 0xb0, 0x13, 0x8a,
	0x2c, 0x41, 0x11, 0x9d, 0x48, 0x59, 0x31, 0x8e, 0x07, 0x6c, 0x29, 0x98, 0x06, 0x97, 0x69, 0x5d,
	0xbd, 0x3b, 0x16, 0xf5, 0xae, 0x22, 0xdd, 0x93, 0x8c, 0x51, 0x2a, 0xd2, 0x05, 0x90, 0x25, 0xa5,
	0x32, 0x68, 0xed, 0x8a, 0xa7, 0x92, 0x74, 0xcd, 0xc2, 0xd5, 0x31, 0xd7, 0xd3, 0xf9, 0x0c, 0x0d,
	0xc0, 0x9c, 0x36, 0x00, 0xcc, 0x32, 0x42, 0x2f, 0x48, 0x9c, 0xd0, 0xe2, 0xc3, 0x08, 0x54, 0x72,
	0xcd, 0x53, 0x28, 0x9a, 0x4e, 0x5c, 0x36, 0x74, 0xe2, 0x12, 0x6a, 0xbc, 0x24, 0xe1, 0xce, 0x6e,
	0x0a, 0x0a, 0xb5, 0xea, 0xf1, 0x14, 0xc7, 0xc0, 0x99, 0xfa, 0x5e, 0x91, 0x18, 0x38, 0xd3, 0xca,
	0x76, 0x48, 0x70, 0xae, 0x10, 0x12, 0xe4, 0x80, 0x86, 0x6b, 0x03, 0x1a, 0x57, 0xd1, 0x42, 0x4e,
	0xd3, 0x80, 0x06, 0x9d, 0xf5, 0xf2, 0x19, 0x16, 0x9b, 0xfe, 0xbc, 0xcd, 0xa6, 0xd7, 0x20, 0xe6,
	0x05, 0xc6, 0x3f, 0x03, 0x62, 0x92, 0x61, 0xb0, 0x35, 0x20, 0xa0, 0x22, 0xd9, 0x91, 0x62, 0x04,
	0x1d, 0x1e, 0x32, 0x55, 0xa8, 0xc0, 0xc3, 0x65, 0x84, 0xc2, 0xc4, 0xe7, 0x27, 0x14, 0x54, 0xdf,
	0xac, 0xa7, 0x50, 0x72, 0xb6, 0xc4, 0x25, 0x8b, 0x2d, 0x51, 0x84, 0x4b, 0x2e, 0x1f, 0x15, 0x97,
	0x5c, 0x29, 0xc2, 0x25, 0xe7, 0xd1, 0x6c, 0x32, 0x22, 0xbd, 0x50, 0xee, 0xc7, 0xab, 0xb0, 0x1f,
	0x75, 0x22, 0xf0, 0x92, 0x21, 0x50, 0xb1, 0x1d, 0xaf, 0xc1, 0x9e, 0x30, 0xa8, 0xf8, 0x13, 0x34,
	0x2f, 0xb7, 0xfa, 0x80, 0xbc, 0x20, 0x83, 0xc4, 0x59, 0x2b, 0x73, 0x83, 0xdd, 0xe3, 0x85, 0x1f,
	0x41, 0x59, 0xcf, 0xac, 0xcc, 0xf5, 0x02, 0x1f, 0xf2, 0x30, 0x4a, 0x89, 0xb3, 0xce, 0xd6, 0x50,
	0xa7, 0xd2, 0x95, 0x18, 0x0f, 0x43, 0x8e, 0xa9, 0xae, 0xb3, 0x95, 0x90, 0x04, 0xba, 0x12, 0xbd,
	0x98, 0x08, 0xe9, 0x7e, 0x83, 0x9d, 0x82, 0x8c, 0x42, 0x77, 0x3a, 0xb7, 0xd8, 0x36, 0x60, 0x89,
	0x85, 0x21, 0xb6, 0x88, 0xea, 0x2f, 0x82, 0x64, 0x3c, 0x72, 0x6e, 0x42, 0x15, 0x96, 0x00, 0x31,
	0x29, 0x84, 0xd0, 0x2d, 0xb6, 0x5f, 0xa4, 0xf4, 0xb9, 0x88, 0xe6, 0x06, 0x64, 0xb8, 0x93, 0xee,
	0x0a, 0x28, 0xe7, 0xbc, 0xc1, 0xf8, 0xa4, 0x53, 0x69, 0xb9, 0x5d, 0x38, 0x4d, 0xb2, 0xdc, 0x9b,
	0xac, 0x9c, 0x4e, 0xa5, 0xab, 0xf3, 0x32, 0x4c, 0xfb, 0x59, 0x73, 0x6f, 0x41, 0x31, 0x9d, 0x48,
	0xb1, 0xa5, 0x05, 0xcb, 0x38, 0x6f, 0xc3, 0xe0, 0x6c, 0x59, 0x20, 0x4f, 0x05, 0x5a, 0xe2, 0x0a,
	0xf7, 0x1d, 0x8e, 0x9a, 0x75, 0x32, 0xde, 0x2b, 0x43, 0x60, 0xb7, 0x61, 0x6d, 0xaf, 0xd9, 0xd7,
	0x76, 0x93, 0x57, 0x7b, 0xca, 0x6b, 0x3d, 0x61, 0x95, 0xca, 0x00, 0xdb, 0x55, 0x1b, 0xf8, 0xfa,
	0x3a, 0xac, 0x49, 0x3e, 0x83, 0x2e, 0x3a, 0x03, 0xb6, 0xfb, 0xc1, 0x2b, 0xe7, 0x5d, 0xd8, 0xb6,
	0x19, 0x81, 0x4e, 0x51, 0x05, 0xbf, 0xb4, 0xcc, 0x7b, 0x50, 0xc6, 0x24, 0x53, 0x26, 0xa7, 0x51,
	0x1a, 0x0c, 0x64, 0x8f, 0xef, 0x33, 0xe1, 0xa3, 0x11, 0xa9, 0x48, 0x0b, 0x13, 0x3f, 0x1c, 0xbe,
	0x08, 0x06, 0x61, 0x5f, 0x16, 0xfd, 0x00, 0x06, 0x67, 0xc9, 0x71, 0xbf, 0xdf, 0x41, 0x28, 0x73,
	0x0f, 0xd9, 0x34, 0x58, 0xc5, 0xae, 0xc1, 0x5c, 0x34, 0xa3, 0xa8, 0x8b, 0xc4, 0xa9, 0xae, 0xd4,
	0xa8, 0x5c, 0x50, 0x69, 0x12, 0x6d, 0xd5, 0x14, 0xb4, 0xb5, 0x82, 0xda, 0x7d, 0x92, 0xf4, 0xe2,
	0x70, 0x04, 0xe2, 0x84, 0x39, 0x41, 0x54, 0x12, 0x65, 0xaf, 0x92, 0xf4, 0x93, 0x5e, 0x14, 0x13,
	0xf0, 0x8c, 0x54, 0xbd, 0x7c, 0x06, 0x2d, 0x9d, 0xec, 0x46, 0x54, 0xaa, 0x28, 0xad, 0x36, 0xa0,
	0xd5, 0x7c, 0x86, 0xa2, 0x2d, 0xa6, 0x35, 0x6d, 0x91, 0x3f, 0x11, 0xcd, 0x09, 0x4f, 0x44, 0x6b,
	0xb2, 0x13, 0x81, 0x6c, 0x27, 0x42, 0x93, 0xdb, 0x6d, 0x53, 0x6e, 0xab, 0x5a, 0x6f, 0xc6, 0xd0,
	0x7a, 0x9a, 0x24, 0x99, 0x35, 0x25, 0x89, 0xa1, 0xdd, 0xe7, 0x0e, 0xf3, 0x63, 0xcd, 0xdb, 0xb0,
	0x28, 0x35, 0x7f, 0x22, 0xe0, 0x5a, 0x02, 0x30, 0xac, 0xe9, 0xa9, 0xa4, 0x1c, 0x54, 0x5c, 0xb0,
	0x40, 0x45, 0x17, 0xcd, 0xd0, 0xf1, 0x48, 0x26, 0x60, 0x56, 0x46, 0xa5, 0x69, 0x7a, 0xed, 0x98,
	0xa1, 0xd7, 0x24, 0x8e, 0x5e, 0x54, 0x71, 0x74, 0x1e, 0x85, 0x1f, 0xb7, 0xa2, 0xf0, 0x65, 0x84,
	0xc0, 0x48, 0x48, 0xc3, 0x74, 0x20, 0x00, 0x94, 0x42, 0xa1, 0xa3, 0x83, 0x94, 0x30, 0xea, 0x18,
	0x82, 0xd2, 0x68, 0xd4, 0xba, 0x65, 0x86, 0x86, 0xb2, 0xb9, 0x18, 0x98, 0xca, 0xd1, 0xe9, 0x4c,
	0xd2, 0x60, 0x27, 0xa1, 0x75, 0x39, 0xa0, 0x92, 0x69, 0xda, 0x8e, 0x18, 0x5d, 0x4c, 0x06, 0x54,
	0xa2, 0x27, 0x00, 0xa9, 0x5a, 0x5e, 0x8e, 0xae, 0x21, 0xa5, 0x53, 0x06, 0x52, 0xea, 0xa2, 0x66,
	0x98, 0xf8, 0x90, 0x14, 0x28, 0x4a, 0xa4, 0xf1, 0xcf, 0xa0, 0xe3, 0x41, 0xbf, 0x1f, 0xd2, 0xb1,
	0x04, 0x03, 0x5f, 0x31, 0x04, 0xce, 0x80, 0xfc, 0xbb, 0x78, 0x88, 0x21, 0xf0, 0x98, 0x2d, 0xac,
	0x67, 0x6f, 0x04, 0x50, 0x04, 0x89, 0x38, 0x33, 0x97, 0x39, 0x9e, 0x14, 0x04, 0xb0, 0x5d, 0x48,
	0x24, 0x59, 0x79, 0x96, 0xdb, 0x2e, 0x19, 0x89, 0x49, 0x96, 0x48, 0x63, 0xe4, 0x8a, 0xf0, 0x80,
	0x68, 0x64, 0xd1, 0x13, 0x3b, 0xf7, 0xe7, 0x38, 0x5e, 0x11, 0x04, 0xc0, 0x8a, 0x61, 0x9f, 0x44,
	0xfe, 0x20, 0x1c, 0xee, 0x01, 0x00, 0x6b, 0x79, 0x0a, 0x05, 0x3f, 0x47, 0x1d, 0x05, 0x92, 0xfb,
	0xdb, 0xe1, 0x80, 0x38, 0xaf, 0x1d, 0x15, 0xdd, 0xe7, 0x9a, 0xd0, 0x41, 0xd4, 0x79, 0x13, 0x44,
	0x51, 0x61, 0xc8, 0x15, 0x35, 0x1c, 0xd7, 0x0b, 0x6c, 0x2b, 0xa9, 0x34, 0xcd, 0x6e, 0xb9, 0x98,
	0xb7, 0x5b, 0xf8, 0xe1, 0x03, 0x18, 0x44, 0x41, 0xda, 0x94, 0xa7, 0x92, 0x74, 0xab, 0x69, 0xd5,
	0xb4, 0x9a, 0xf2, 0x5e, 0xc4, 0x4b, 0x56, 0x2f, 0xe2, 0x22, 0xaa, 0x33, 0xb6, 0x5e, 0x86, 0x6c,
	0x96, 0x30, 0xad, 0xa6, 0x2b, 0x93, 0x5c, 0x3c, 0x5d, 0xb5, 0x82, 0x54, 0xc3, 0x33, 0x7b, 0x2d,
	0xef, 0x99, 0xd5, 0xe1, 0xe6, 0xda, 0xa1, 0x70, 0x73, 0xfd, 0x08, 0x70, 0xf3, 0xfa, 0x51, 0xe1,
	0xe6, 0x8d, 0x89, 0xe1, 0xe6, 0x46, 0x01, 0xdc, 0x34, 0x60, 0xdf, 0x4d, 0x2b, 0xec, 0x2b, 0x05,
	0x27, 0xb7, 0xbe, 0x64, 0x70, 0xf2, 0x0e, 0x6a, 0x72, 0xdd, 0x9e, 0x38, 0x6f, 0x94, 0xb9, 0x60,
	0xbe, 0xc5, 0x4a, 0x79, 0xb2, 0xb8, 0xfb, 0x5f, 0x1d, 0x34, 0xab, 0x5d, 0x6d, 0x7d, 0xa5, 0xc0,
	0x0f, 0x51, 0xe0, 0x5f, 0xa9, 0xe8, 0xaf, 0x54, 0xf4, 0x57, 0x2a, 0xfa, 0xff, 0x88, 0x8a, 0x36,
	0x95, 0xf0, 0x79, 0x8b, 0x12, 0x36, 0x1d, 0x94, 0x17, 0x2c, 0x0e, 0x4a, 0x43, 0x19, 0x5f, 0x64,
	0x2e, 0xc8, 0x42, 0x65, 0xfc, 0xfa, 0xe1, 0xca, 0x78, 0xb5, 0x5c, 0x19, 0x5f, 0x2a, 0x51, 0xc6,
	0x97, 0x27, 0x51, 0xc6, 0x57, 0x26, 0x51, 0xc6, 0x57, 0xf3, 0xca, 0x58, 0xb3, 0x3f, 0xae, 0x59,
	0xec, 0x0f, 0x09, 0x58, 0xd6, 0x6c, 0x8e, 0xd6, 0xcc, 0x4d, 0xbb, 0x9e, 0x77, 0xd3, 0xae, 0x21,
	0xcc, 0xc7, 0xa3, 0xee, 0xa7, 0xeb, 0xd0, 0x8e, 0x25, 0x27, 0xaf, 0x72, 0x6f, 0xd8, 0x54, 0xae,
	0x09, 0x0f, 0x36, 0x2c, 0xf0, 0x40, 0x87, 0x18, 0x37, 0x73, 0x10, 0xa3, 0x08, 0x3e, 0xdc, 0x3a,
	0x2a, 0x7c, 0x78, 0xa3, 0x08, 0x3e, 0xe4, 0x81, 0xc1, 0x9b, 0x56, 0x60, 0x00, 0x36, 0xf4, 0x56,
	0x38, 0x24, 0xa9, 0x0f, 0x57, 0x26, 0x6f, 0x09, 0x1b, 0x3a, 0xa3, 0x95, 0x83, 0x87, 0xb7, 0xff,
	0x07, 0xc1, 0xc3, 0x3b, 0x47, 0x02, 0x0f, 0x7c, 0xd7, 0x03, 0x24, 0x66, 0x8c, 0x06, 0xb7, 0x4b,
	0xd3, 0x33, 0xa8, 0x5c, 0x3c, 0x92, 0x17, 0x84, 0xfb, 0x4c, 0x98, 0x78, 0x84, 0xb4, 0xfb, 0xa3,
	0x2a, 0xea, 0x98, 0xc2, 0x0e, 0x6f, 0x22, 0xb4, 0x3f, 0x1e, 0xa4, 0xa1, 0xaf, 0x44, 0x14, 0x5d,
	0x98, 0x48, 0x50, 0x7a, 0x4a, 0x45, 0xfc, 0x00, 0xb5, 0x93, 0x70, 0xb8, 0x33, 0x20, 0xe2, 0x96,
	0xe9, 0x08, 0xed, 0xa8, 0x35, 0xf1, 0x3d, 0xd4, 0x4a, 0xc9, 0xab, 0x94, 0x35, 0x53, 0x3b, 0x4a,
	0x33, 0x59, 0x3d, 0x3a, 0x9a, 0xde, 0x38, 0x49, 0x59, 0x9c, 0x41, 0xe0, 0x4c, 0x95, 0x35, 0x73,
	0x0f, 0x0a, 0x66, 0x17, 0x36, 0x6a, 0x4d, 0xf7, 0x8f, 0xab, 0x68, 0xde, 0xe8, 0x07, 0x77, 0x50,
	0x8d, 0x2a, 0x38, 0x16, 0x40, 0x46, 0x7f, 0x32, 0x17, 0xe1, 0x60, 0x4c, 0x60, 0xda, 0x2d, 0x8f,
	0x25, 0xf0, 0x43, 0xd4, 0xe0, 0xda, 0x99, 0x4d, 0xe3, 0xc6, 0x44, 0xd3, 0x58, 0x7b, 0x08, 0x75,
	0x36, 0x87, 0x69, 0x7c, 0xe0, 0xf1, 0x06, 0xf0, 0x26, 0x9a, 0x81, 0x36, 0x7d, 0x36, 0x36, 0x3e,
	0xa1, 0x73, 0x45, 0x9b, 0x67, 0x30, 0x26, 0x6c, 0x56, 0x9e, 0x56, 0x8d, 0x1e, 0x08, 0xa9, 0xcf,
	0x44, 0xcc, 0x5c, 0xcd, 0xd3, 0x68, 0xdd, 0x77, 0x50, 0x5b, 0x19, 0x41, 0xf9, 0x64, 0x2b, 0x72,
	0xb2, 0xb7, 0xab, 0x6f, 0x57, 0xdc, 0x7f, 0xaf, 0xa2, 0x96, 0x9c, 0x4d, 0xae, 0xb3, 0x4a, 0xbe,
	0x33, 0xba, 0xab, 0xb3, 0x34, 0x88, 0xd1, 0x2a, 0x5c, 0x0e, 0x1b, 0x54, 0x2b, 0x50, 0x56, 0x40,
	0x50, 0xa4, 0x62, 0x65, 0x83, 0x0a, 0x92, 0x6f, 0x37, 0x7a, 0xe9, 0xc7, 0xe4, 0xb3, 0x71, 0x18,
	0x13, 0x36, 0xeb, 0xba, 0xa7, 0x13, 0x69, 0x0f, 0xd0, 0x3f, 0x43, 0xc6, 0xf0, 0x1b, 0x7f, 0x82,
	0xe6, 0xb3, 0x71, 0xb0, 0x39, 0x4f, 0x97, 0x45, 0xc9, 0xc9, 0xb9, 0xc3, 0x0a, 0x78, 0x66, 0x65,
	0xda, 0x07, 0x28, 0x9d, 0x26, 0xeb, 0x03, 0xb4, 0x0d, 0xd3, 0x11, 0x7c, 0x59, 0x5b, 0x52, 0x47,
	0xf0, 0x05, 0x5b, 0x41, 0x6d, 0x9a, 0xd8, 0x25, 0xbd, 0xbd, 0x68, 0xcc, 0x40, 0x72, 0xd3, 0x53,
	0x49, 0xee, 0x1f, 0x55, 0xd1, 0xbc, 0xb1, 0x83, 0xb1, 0x83, 0xa6, 0xc3, 0xbe, 0x9f, 0x92, 0xfd,
	0x11, 0x30, 0xbd, 0xee, 0x89, 0xa4, 0x58, 0xcd, 0x6a, 0xb6, 0x9a, 0x36, 0xce, 0xbe, 0x25, 0x56,
	0x78, 0xe2, 0x6d, 0x96, 0xdb, 0xf1, 0xf5, 0xb2, 0x1d, 0x6f, 0x8c, 0xd7, 0xba, 0xe3, 0x05, 0xaf,
	0x1a, 0x19, 0xaf, 0xbe, 0xc8, 0xd6, 0xfc, 0x08, 0xb5, 0x95, 0xf1, 0xd2, 0xbd, 0xc3, 0x76, 0x87,
	0xaf, 0x33, 0xca, 0xa0, 0xda, 0x1b, 0x74, 0xff, 0xb6, 0x8a, 0xe6, 0xf4, 0xb5, 0x86, 0x0b, 0xc7,
	0xa0, 0xb7, 0xb7, 0x13, 0x47, 0xe3, 0x61, 0x9f, 0x0f, 0x49, 0xa1, 0xc0, 0x85, 0x63, 0x34, 0x88,
	0x62, 0x7f, 0x97, 0xbc, 0xf2, 0xe3, 0x9d, 0x2d, 0xde, 0xa0, 0x4e, 0xcc, 0xba, 0xab, 0x29, 0xdd,
	0x51, 0x2a, 0x30, 0x85, 0xef, 0x6f, 0x96, 0x80, 0xad, 0x41, 0x7f, 0xf8, 0x6f, 0x5c, 0x7f, 0xf5,
	0xc6, 0x75, 0x1e, 0xda, 0xa6, 0x92, 0x68, 0x9f, 0x22, 0x49, 0xd3, 0xd7, 0x39, 0x2f, 0x75, 0x22,
	0xdd, 0x80, 0x72, 0xd2, 0x60, 0xf4, 0xd5, 0xbd, 0x8c, 0x80, 0x3f, 0x40, 0x88, 0x0d, 0x11, 0x0e,
	0x47, 0x13, 0x22, 0x20, 0x0a, 0xae, 0xbc, 0xef, 0xd1, 0x72, 0xcf, 0x0e, 0x46, 0xc4, 0x53, 0xaa,
	0x94, 0xef, 0x6f, 0xf7, 0x53, 0x74, 0xcc, 0x02, 0x3e, 0x69, 0x25, 0x0a, 0x39, 0xd9, 0xe5, 0x2a,
	0x63, 0x66, 0x46, 0xe0, 0x42, 0x23, 0xe8, 0xed, 0x52, 0x18, 0xe6, 0x8f, 0xe3, 0x81, 0x08, 0xd3,
	0xd5, 0xa9, 0xee, 0x6f, 0x56, 0x50, 0x53, 0x84, 0xd3, 0x1e, 0xc1, 0xf3, 0xae, 0x1a, 0x1f, 0x55,
	0xc3, 0xf8, 0x30, 0xcc, 0xca, 0x1a, 0x00, 0x8a, 0x12, 0xb3, 0x72, 0x0a, 0x0a, 0x28, 0x14, 0xf7,
	0xc7, 0x15, 0x11, 0x91, 0x2a, 0xc2, 0xbe, 0x8d, 0x2a, 0x15, 0x9b, 0x25, 0xaa, 0x42, 0xd6, 0xea,
	0x24, 0x90, 0xb5, 0x56, 0x74, 0xc9, 0x29, 0xa7, 0x36, 0xc5, 0xe2, 0xe8, 0xe4, 0xd4, 0x4c, 0xe8,
	0x5e, 0xcf, 0x43, 0x77, 0xf7, 0x1f, 0x2a, 0x68, 0xe6, 0x5e, 0x34, 0x1e, 0xca, 0x48, 0xd5, 0xc9,
	0xb9, 0x7a, 0x58, 0x64, 0xe7, 0x87, 0xf2, 0xf6, 0xad, 0x06, 0x9b, 0xec, 0x6a, 0xd1, 0x26, 0xcb,
	0x7a, 0xcf, 0x07, 0x4d, 0xfe, 0x54, 0x01, 0x36, 0x17, 0xd0, 0x2c, 0x6f, 0x95, 0x47, 0xd8, 0x2c,
	0xa2, 0x3a, 0x5c, 0xfa, 0x70, 0x99, 0xc0, 0x12, 0xee, 0x0a, 0x6a, 0x8a, 0xe8, 0x98, 0x82, 0x12,
	0x7f, 0x53, 0x41, 0xe8, 0x01, 0x91, 0xbc, 0x39, 0x2c, 0x56, 0xc6, 0xc2, 0xbb, 0xaa, 0x9d, 0x77,
	0xb0, 0x01, 0x12, 0x92, 0xfa, 0xbd, 0xa0, 0xb7, 0xcb, 0x84, 0xc3, 0xac, 0xa7, 0x92, 0x34, 0x47,
	0xc9, 0x94, 0xe1, 0x28, 0x29, 0xb8, 0x17, 0xac, 0x17, 0xde, 0x0b, 0xba, 0xbf, 0x51, 0x41, 0x0b,
	0x0f, 0x48, 0x2a, 0x40, 0xe8, 0x84, 0xf3, 0xd1, 0x74, 0xf9, 0x6e, 0x90, 0xec, 0x2a, 0xc7, 0x52,
	0xa1, 0x6a, 0x63, 0xad, 0x19, 0x63, 0xa5, 0x9a, 0x6b, 0xd8, 0x1b, 0x8c, 0xfb, 0x42, 0xd8, 0x89,
	0xa4, 0xfb, 0x6f, 0x15, 0x74, 0x9c, 0x9d, 0x1b, 0x3e, 0xac, 0x64, 0xd2, 0x71, 0x9d, 0xb3, 0x7e,
	0xd7, 0xc0, 0x3f, 0x87, 0xe8, 0x3f, 0xa7, 0xdd, 0x9e, 0xd1, 0x02, 0x24, 0x6a, 0xe0, 0x1e, 0x6e,
	0x71, 0xca, 0x27, 0x91, 0x12, 0x78, 0x3e, 0x35, 0x69, 0xe0, 0xb9, 0x06, 0xf5, 0xeb, 0x47, 0xf3,
	0x13, 0x06, 0x68, 0xc9, 0x9c, 0x29, 0xdf, 0x99, 0x0f, 0x94, 0x46, 0x19, 0x52, 0xbf, 0x52, 0x16,
	0xaf, 0x2f, 0x17, 0x90, 0x87, 0xed, 0x67, 0x5d, 0x44, 0x06, 0x33, 0x65, 0x0f, 0xf9, 0x45, 0xac,
	0x58, 0x17, 0x71, 0x11, 0xd5, 0x49, 0x1c, 0x47, 0x8c, 0x9b, 0x4d, 0x8f, 0x25, 0xe8, 0xf2, 0xed,
	0x93, 0x24, 0xa1, 0xba, 0x8a, 0xad, 0xac, 0x48, 0x52, 0xc9, 0x31, 0xa7, 0x5f, 0xf3, 0xd3, 0xc2,
	0xbd, 0x20, 0xbd, 0x21, 0x16, 0xad, 0xee, 0x89, 0x24, 0xcf, 0xd9, 0x10, 0x27, 0x82, 0xe5, 0x6c,
	0x64, 0x39, 0x37, 0x99, 0xec, 0x15, 0x39, 0x37, 0xb3, 0x9c, 0x5b, 0x99, 0x64, 0x13, 0x49, 0xaa,
	0x4c, 0xa0, 0x3a, 0x28, 0x13, 0x26, 0xd5, 0x32, 0x02, 0xcf, 0xbd, 0xc9, 0x72, 0x1b, 0x32, 0xf7,
	0xa6, 0x9a, 0x7b, 0x8b, 0xe5, 0x4e, 0xcb, 0x5c, 0x46, 0x70, 0xbf, 0x81, 0x66, 0xb8, 0xf6, 0xfa,
	0x56, 0xd8, 0x27, 0x11, 0xc5, 0x2c, 0xe0, 0x92, 0x61, 0x2c, 0x83, 0xdf, 0xb4, 0x85, 0x74, 0x77,
	0xbc, 0xbf, 0x35, 0x0c, 0x42, 0xa1, 0xa7, 0x32, 0x82, 0xfb, 0xfb, 0x55, 0x34, 0x27, 0x62, 0xf5,
	0x98, 0xf3, 0xeb, 0xd0, 0xed, 0xec, 0xa2, 0x19, 0x91, 0x52, 0x42, 0xed, 0x34, 0x1a, 0x0f, 0xa4,
	0xc9, 0x3c, 0x81, 0x7c, 0x35, 0x74, 0x62, 0xa9, 0xd0, 0xc8, 0x05, 0x48, 0xd5, 0x6d, 0x01, 0x52,
	0x16, 0x11, 0xd6, 0xb0, 0x8b, 0x30, 0xe9, 0xc7, 0x64, 0x6e, 0xe5, 0xc9, 0x42, 0xf6, 0xdc, 0x3f,
	0x3d, 0x26, 0x3d, 0xe6, 0x1f, 0x92, 0x34, 0x08, 0x07, 0x3f, 0x55, 0x00, 0x62, 0x99, 0xc0, 0x91,
	0xe3, 0x9a, 0x52, 0xfd, 0xab, 0x9a, 0x6f, 0xb9, 0x6e, 0xfa, 0x96, 0x33, 0x1f, 0x79, 0xc3, 0x0c,
	0x89, 0xd2, 0xfc, 0xc1, 0xd3, 0x16, 0x7f, 0xb0, 0xe1, 0xdd, 0x6f, 0xe6, 0xbd, 0xfb, 0x7a, 0xb0,
	0x56, 0x2b, 0x17, 0xac, 0x65, 0x40, 0x10, 0x94, 0x0f, 0x2d, 0xb3, 0x84, 0xdf, 0xb4, 0xbf, 0x48,
	0xf8, 0x8d, 0xbe, 0x4a, 0x33, 0x39, 0x7c, 0x92, 0xf7, 0x46, 0xcf, 0x5a, 0xbd, 0xd1, 0x79, 0x94,
	0x32, 0x57, 0x84, 0x52, 0xa4, 0x17, 0x79, 0xde, 0xf0, 0x22, 0x9b, 0x0e, 0xaa, 0x8e, 0xdd, 0x41,
	0xa5, 0x84, 0x71, 0x2e, 0xe4, 0xc2, 0x38, 0xf5, 0x40, 0x20, 0x9c, 0x0b, 0x04, 0x52, 0x51, 0xd2,
	0xb1, 0xbc, 0xf7, 0x59, 0xfa, 0xea, 0x17, 0x0d, 0x5f, 0x7d, 0x07, 0xd5, 0x12, 0x12, 0xf1, 0x68,
	0x43, 0xfa, 0x53, 0xf7, 0x18, 0x2f, 0x99, 0x1e, 0x63, 0x8b, 0x3f, 0xf8, 0x84, 0xdd, 0x1f, 0x6c,
	0xf8, 0x96, 0x9d, 0xbc, 0x6f, 0x59, 0xf3, 0x18, 0x9f, 0x34, 0x3d, 0xc6, 0x8a, 0xcc, 0x00, 0x01,
	0xd5, 0xd5, 0x65, 0x06, 0x08, 0xaa, 0xfc, 0xcd, 0xcd, 0xa9, 0xc9, 0x6e, 0x6e, 0x4e, 0xdb, 0x6e,
	0x6e, 0xf2, 0xf7, 0x45, 0x67, 0xac, 0xf7, 0x45, 0xba, 0x2f, 0x7b, 0x39, 0xe7, 0xcb, 0xbe, 0x2b,
	0xf2, 0xc3, 0xe1, 0x76, 0xe4, 0x9c, 0x05, 0x9d, 0xe7, 0x96, 0x7a, 0xb1, 0x41, 0x14, 0x7b, 0x4a,
	0x2d, 0xfd, 0x6e, 0x79, 0xc5, 0xbc, 0x5b, 0x7e, 0x62, 0xb9, 0x97, 0x38, 0x57, 0x66, 0xe5, 0xeb,
	0xf2, 0xda, 0x72, 0x7b, 0xb1, 0x84, 0x1a, 0x3d, 0x26, 0x54, 0x5c, 0x10, 0x2a, 0x3c, 0x65, 0x93,
	0x96, 0xaf, 0xd9, 0xa5, 0x25, 0x0f, 0x99, 0x3e, 0x9f, 0x85, 0x4c, 0xe7, 0x24, 0xfa, 0x05, 0x9b,
	0x44, 0xcf, 0x49, 0xed, 0x8b, 0x36, 0xa9, 0x9d, 0x73, 0x05, 0xb3, 0xa0, 0x45, 0xc3, 0x15, 0xac,
	0x39, 0xaf, 0x57, 0x4d, 0xe7, 0xb5, 0x61, 0x93, 0x5c, 0xca, 0xdb, 0x24, 0x76, 0x07, 0xf5, 0xe5,
	0x42, 0x07, 0xb5, 0x1e, 0xb2, 0x7b, 0x35, 0x17, 0xb2, 0xab, 0x5d, 0x0a, 0x5c, 0x3b, 0x24, 0xae,
	0x79, 0x2d, 0xef, 0x30, 0x2f, 0x88, 0x4c, 0x5e, 0xff, 0x52, 0x22, 0x93, 0xd5, 0x48, 0xe1, 0xeb,
	0x46, 0xa4, 0xb0, 0x69, 0x58, 0xdd, 0xb0, 0xdc, 0x89, 0xa8, 0x77, 0x01, 0x1b, 0xc6, 0x5d, 0x80,
	0x1e, 0x75, 0x7e, 0xf3, 0xe8, 0x51, 0xe7, 0x59, 0x60, 0xe3, 0x2d, 0x2d, 0xb0, 0xb1, 0xc8, 0x51,
	0xff, 0xc6, 0x51, 0x1d, 0xf5, 0x6f, 0x4e, 0xee, 0xa8, 0x7f, 0xeb, 0xe8, 0x37, 0xf8, 0x6f, 0xff,
	0x6f, 0x84, 0x17, 0xbe, 0x53, 0x14, 0x5e, 0xa8, 0xe2, 0xf8, 0xdb, 0x47, 0x73, 0xd9, 0x17, 0x18,
	0x5e, 0x5f, 0x2f, 0x0e, 0xc8, 0xcc, 0x07, 0xd8, 0xbe, 0x6b, 0x0d, 0xb0, 0x35, 0x82, 0xc7, 0xdf,
	0xcb, 0x07, 0x8f, 0x6b, 0x51, 0x91, 0xef, 0x4f, 0x10, 0x15, 0xf9, 0x81, 0x3d, 0x2a, 0xd2, 0x1e,
	0xef, 0xf8, 0x8d, 0xc2, 0x78, 0xc7, 0xbf, 0xaa, 0xa2, 0x79, 0x21, 0x88, 0x05, 0x1f, 0x0e, 0xc3,
	0x6c, 0x2a, 0x8b, 0xab, 0x47, 0x63, 0xb1, 0x7e, 0x36, 0x6a, 0x47, 0x3f, 0x1b, 0x16, 0x99, 0x3c,
	0x55, 0xe8, 0x16, 0x32, 0xbe, 0x35, 0x6f, 0xaa, 0xce, 0x0d, 0x05, 0xb3, 0x35, 0x72, 0x98, 0xcd,
	0xce, 0xc5, 0xe9, 0x42, 0x2e, 0xfe, 0x52, 0x05, 0x9d, 0xb8, 0x97, 0x89, 0x97, 0xfb, 0xe1, 0x80,
	0x24, 0xe2, 0x23, 0xda, 0xc9, 0x5d, 0x2e, 0x06, 0x52, 0xac, 0xe6, 0x91, 0xa2, 0x8a, 0x74, 0x6a,
	0x3a, 0xd2, 0x71, 0xbf, 0x8b, 0x8e, 0x3f, 0x20, 0xa9, 0x32, 0x0a, 0x61, 0x6f, 0x3f, 0xc8, 0xbe,
	0x43, 0xae, 0x94, 0x1d, 0xcd, 0x82, 0x09, 0xc8, 0xef, 0x92, 0xdd, 0xcf, 0x50, 0xc7, 0x2c, 0x83,
	0xdf, 0xd3, 0xbe, 0x6e, 0x3a, 0x82, 0x58, 0x66, 0x5f, 0x3a, 0xe9, 0x5b, 0x8d, 0x19, 0x8f, 0xea,
	0x97, 0xd6, 0xbf, 0x56, 0x41, 0xf8, 0x51, 0x98, 0xa4, 0xdf, 0x0c, 0x93, 0x34, 0x8a, 0x0f, 0x8a,
	0x5d, 0x08, 0x5a, 0x35, 0xe3, 0x0b, 0xea, 0xea, 0x51, 0xbf, 0xa0, 0xce, 0x3e, 0x11, 0xa5, 0x3b,
	0xb4, 0x2e, 0x3e, 0x11, 0x75, 0x7f, 0x50, 0x41, 0xc7, 0xb4, 0xd1, 0x1c, 0xe5, 0x93, 0x7c, 0xce,
	0x04, 0x51, 0xf7, 0xcb, 0xf8, 0xd2, 0xeb, 0x87, 0x4d, 0x69, 0x8d, 0xf2, 0x66, 0xe9, 0xd0, 0x83,
	0x1e, 0xcc, 0x9a, 0x71, 0x85, 0xa7, 0x0e, 0x63, 0xb4, 0xe5, 0xa3, 0x2f, 0xd3, 0x6e, 0x9d, 0xb2,
	0xd8, 0xad, 0x60, 0x69, 0x44, 0x31, 0x61, 0xa0, 0xa2, 0x2e, 0x9c, 0x84, 0x82, 0x92, 0xe5, 0x2b,
	0xd6, 0xba, 0x42, 0x51, 0x18, 0xcd, 0x1c, 0xd9, 0xe2, 0x5b, 0xdc, 0x8b, 0x68, 0x4e, 0xa8, 0x5b,
	0x9e, 0xdf, 0x64, 0xee, 0x7e, 0x9d, 0x6a, 0xa2, 0x9a, 0xd6, 0x24, 0x9e, 0x56, 0x64, 0xb5, 0x61,
	0x4c, 0xa5, 0xdf, 0xb6, 0x28, 0x7d, 0xa5, 0x0c, 0xa8, 0xd1, 0x19, 0x76, 0x41, 0xa6, 0xd2, 0x94,
	0x11, 0xc1, 0x94, 0x67, 0xb5, 0x11, 0xc1, 0x9c, 0x2f, 0xa3, 0x4e, 0x3f, 0x4c, 0x7a, 0xd1, 0x78,
	0x98, 0x4a, 0xad, 0x31, 0x07, 0xb3, 0xcb, 0xd1, 0xf1, 0x6d, 0xe4, 0xc8, 0xd6, 0xcd, 0x3a, 0xf3,
	0x50, 0xa7, 0x30, 0x1f, 0x3e, 0xe6, 0x01, 0x4b, 0x36, 0x78, 0x11, 0x84, 0x83, 0x60, 0x2b, 0x1c,
	0x50, 0x1b, 0x88, 0x85, 0x45, 0x59, 0x72, 0xf0, 0xfb, 0xa8, 0x9b, 0x71, 0x37, 0x57, 0x6f, 0x01,
	0xea, 0x95, 0x94, 0x50, 0xac, 0x6c, 0x6c, 0x46, 0xa2, 0x89, 0x5a, 0x3c, 0x7f, 0x91, 0xe9, 0x48,
	0x9d, 0x9a, 0x59, 0xf6, 0xc7, 0xd9, 0x67, 0x1b, 0x4c, 0x2f, 0x9e, 0x47, 0xb3, 0xa2, 0x1c, 0xcb,
	0x5d, 0x82, 0x5c, 0x9d, 0xc8, 0x21, 0x02, 0x37, 0x71, 0x45, 0xa4, 0xc3, 0x09, 0x09, 0x11, 0xf4,
	0x0c, 0xfc, 0x0d, 0x74, 0x2a, 0x4c, 0x72, 0x0c, 0x93, 0xf5, 0x1c, 0xa8, 0x57, 0x56, 0x04, 0x7f,
	0x88, 0xce, 0x40, 0xb3, 0x26, 0x13, 0x64, 0x1b, 0x27, 0xa1, 0x8d, 0xf2, 0x42, 0x7c, 0xd4, 0x6c,
	0xfa, 0xb2, 0x66, 0x57, 0x8e, 0x5a, 0xcf, 0xa0, 0xfb, 0x06, 0xac, 0x66, 0xaa, 0xe9, 0x45, 0xe1,
	0x53, 0x50, 0x38, 0x47, 0x77, 0xdf, 0x45, 0xad, 0xe7, 0x23, 0x21, 0x2c, 0xd7, 0xb5, 0xc7, 0x47,
	0x4e, 0x15, 0xa9, 0xea, 0xe4, 0xf9, 0x88, 0xbf, 0x86, 0xb1, 0x89, 0x10, 0xad, 0xcd, 0x85, 0xdb,
	0x44, 0x6f, 0x97, 0xb0, 0xea, 0xf2, 0xb9, 0x11, 0x68, 0xe6, 0x3b, 0x68, 0x11, 0xbc, 0xeb, 0xfd,
	0x30, 0xb9, 0x7b, 0xf0, 0x11, 0x91, 0xc2, 0xdb, 0x41, 0xd3, 0xf4, 0xd4, 0x05, 0xf2, 0xde, 0x4d,
	0x24, 0x2d, 0xb7, 0x9d, 0x4b, 0xa8, 0x31, 0x0a, 0xe2, 0x60, 0x9f, 0x49, 0xe2, 0x96, 0xc7, 0x53,
	0xee, 0x1d, 0x50, 0x76, 0x6a, 0xdb, 0x7c, 0xb4, 0x58, 0x79, 0xff, 0xa3, 0xc5, 0x06, 0xa2, 0xfb,
	0x3e, 0x5b, 0xdc, 0xf7, 0xe9, 0xfe, 0x75, 0x05, 0xd5, 0x61, 0xd8, 0x93, 0xf8, 0xa8, 0xd2, 0x90,
	0xfb, 0xa8, 0x6a, 0x1e, 0xfc, 0xce, 0x5f, 0x2c, 0xd9, 0x74, 0xf5, 0x28, 0x4a, 0x42, 0x79, 0xd1,
	0x3d, 0xeb, 0xc9, 0x34, 0x65, 0x01, 0x44, 0x14, 0x8e, 0x47, 0x1c, 0x9a, 0x88, 0x64, 0x11, 0x06,
	0x6d, 0x14, 0x3b, 0xff, 0x3f, 0x47, 0xb3, 0x1a, 0xf7, 0x0f, 0x9d, 0x8e, 0xe2, 0xf4, 0xad, 0x6a,
	0x4e, 0xdf, 0xa2, 0xce, 0x6b, 0xc5, 0x9d, 0x27, 0x68, 0xd6, 0x23, 0xa3, 0x71, 0xb2, 0x2b, 0x16,
	0xd7, 0x78, 0xad, 0xa2, 0xc2, 0x2e, 0xdc, 0xd4, 0xd7, 0x2a, 0x4e, 0xa3, 0x56, 0x0c, 0x55, 0x7c,
	0x92, 0x70, 0x6f, 0x74, 0x46, 0xa0, 0x32, 0x96, 0x27, 0x62, 0xba, 0xb8, 0xd0, 0x77, 0xd3, 0xd3,
	0x68, 0xee, 0x55, 0x34, 0x27, 0x3a, 0xe5, 0x53, 0xee, 0xa2, 0x26, 0x9f, 0x83, 0x78, 0x83, 0x45,
	0xa6, 0xdd, 0xdf, 0xab, 0xa0, 0x13, 0x05, 0x56, 0x07, 0x3f, 0x53, 0xe3, 0x04, 0xbe, 0x9c, 0x1a,
	0x26, 0x29, 0x45, 0x79, 0x15, 0x79, 0xa6, 0x34, 0x3a, 0xc5, 0x71, 0x0a, 0xcd, 0xef, 0x07, 0x07,
	0x7c, 0xf4, 0x26, 0x99, 0xb7, 0x9a, 0x90, 0xc1, 0x76, 0xf6, 0x11, 0x65, 0x4d, 0xb6, 0xaa, 0xd1,
	0xdd, 0x7f, 0xae, 0xa1, 0x69, 0x0e, 0x93, 0xf1, 0x7d, 0x0d, 0x1c, 0xb3, 0xf3, 0x76, 0xb1, 0x14,
	0x59, 0xdb, 0x31, 0xf2, 0xa4, 0x17, 0x3b, 0x45, 0xf6, 0x64, 0xad, 0xc4, 0x9e, 0x5c, 0x43, 0x38,
	0xa3, 0x93, 0x21, 0xd7, 0x84, 0x53, 0x50, 0xc3, 0x92, 0x63, 0xff, 0x28, 0x96, 0xc7, 0x3e, 0xe7,
	0x3f, 0x8a, 0x35, 0xbd, 0x85, 0x0d, 0x8b, 0xb7, 0x50, 0xf5, 0x0e, 0x4f, 0x17, 0x79, 0x87, 0x9b,
	0xaa, 0x77, 0x38, 0xe7, 0x3f, 0x69, 0xd9, 0x42, 0xe9, 0x0c, 0x1b, 0x0d, 0xe5, 0x6d, 0x34, 0xd5,
	0x97, 0xd8, 0x36, 0x5e, 0x35, 0x59, 0x44, 0x75, 0xf8, 0x96, 0x95, 0xbb, 0x5b, 0x59, 0xc2, 0x7d,
	0x86, 0x3a, 0xe6, 0x4a, 0xe1, 0x39, 0x54, 0x95, 0x98, 0xb5, 0xca, 0xae, 0x3b, 0xb2, 0xfb, 0xfc,
	0xaa, 0x79, 0x9f, 0x2f, 0xc2, 0x2a, 0x6a, 0x59, 0x58, 0x05, 0x7b, 0xf1, 0x28, 0x79, 0x4a, 0xe2,
	0x17, 0x7c, 0x54, 0xe0, 0x1c, 0x0b, 0xfa, 0x09, 0x3f, 0xec, 0x32, 0x4d, 0x8f, 0x7a, 0xd0, 0xf7,
	0x47, 0x83, 0x71, 0xc2, 0xaf, 0x2a, 0x45, 0xd2, 0xfd, 0xb3, 0x0a, 0xc2, 0x0f, 0x48, 0xca, 0xd1,
	0xa3, 0xbc, 0x9b, 0xfb, 0x28, 0x03, 0x7d, 0xc9, 0xde, 0x58, 0x6c, 0xc2, 0xd7, 0x4b, 0x11, 0xed,
	0xd3, 0xbd, 0xb1, 0x30, 0x15, 0xb4, 0xca, 0xf8, 0x09, 0x6a, 0x53, 0xf9, 0xcb, 0x2d, 0x74, 0x0e,
	0x6f, 0xd7, 0x4a, 0xdb, 0xa2, 0x08, 0xf7, 0x1e, 0x14, 0x1f, 0xc7, 0x0c, 0x97, 0xab, 0x4d, 0xb8,
	0xff, 0x1f, 0x1d, 0xd3, 0x06, 0xcd, 0x8f, 0xff, 0x5d, 0xd4, 0xe4, 0xed, 0x50, 0xa0, 0x58, 0x72,
	0x6c, 0xb4, 0xbb, 0x89, 0xa7, 0x7b, 0x63, 0x4f, 0xd6, 0x73, 0x7f, 0x07, 0xa1, 0x8e, 0x99, 0x7d,
	0xa8, 0x28, 0x2d, 0x10, 0x98, 0xd5, 0x62, 0x8f, 0x81, 0x6a, 0x95, 0xd6, 0x0c, 0xab, 0x74, 0x72,
	0xdb, 0x56, 0xdc, 0x9a, 0xd4, 0x95, 0x5b, 0x13, 0x19, 0x75, 0xd2, 0x50, 0xa3, 0x4e, 0xd4, 0xd7,
	0x09, 0xa6, 0x8d, 0xd7, 0x09, 0x0c, 0x1d, 0xd6, 0x2c, 0xb7, 0x37, 0x5b, 0x86, 0x67, 0xdd, 0xbc,
	0x3d, 0x41, 0x96, 0xdb, 0x13, 0xfd, 0x26, 0xa2, 0x9d, 0xbb, 0x89, 0x90, 0xe7, 0x75, 0x46, 0x3d,
	0xaf, 0xc6, 0x49, 0x9c, 0xcd, 0x9f, 0x44, 0x53, 0x4e, 0xcc, 0x59, 0xe4, 0x84, 0x55, 0xf2, 0xcc,
	0x17, 0x49, 0x1e, 0xed, 0x06, 0xa9, 0xc3, 0x3c, 0xff, 0xd9, 0x0d, 0x92, 0xf9, 0x9e, 0x91, 0x7a,
	0x8b, 0x50, 0x82, 0x7b, 0x0d, 0xff, 0xfc, 0xb1, 0xc9, 0xfc, 0xf3, 0x8b, 0x93, 0xf9, 0xe7, 0x8f,
	0x5b, 0xfd, 0xf3, 0xdc, 0x8e, 0x5b, 0xca, 0xec, 0x38, 0x25, 0x8e, 0x5f, 0xca, 0xcd, 0x13, 0x7a,
	0x1c, 0xbf, 0x94, 0x9f, 0x97, 0x51, 0x87, 0xbb, 0x34, 0xb2, 0xb2, 0xfc, 0xdb, 0x01, 0x93, 0x6e,
	0xd1, 0x32, 0x27, 0xad, 0x5a, 0xc6, 0xea, 0xbe, 0xeb, 0x16, 0xb9, 0xef, 0xde, 0x46, 0x27, 0xc2,
	0xc4, 0x67, 0xde, 0x15, 0xa3, 0x79, 0x06, 0x76, 0x8b, 0xb2, 0xf1, 0x13, 0x4d, 0x7b, 0x9e, 0x06,
	0x31, 0x70, 0xbd, 0xfc, 0xe6, 0x81, 0xf6, 0x49, 0x77, 0x81, 0x14, 0xce, 0x89, 0xa6, 0x47, 0x4b,
	0xbd, 0x9c, 0x67, 0xbe, 0x64, 0x2f, 0xe7, 0x03, 0xd4, 0xca, 0xf6, 0xf3, 0x32, 0x34, 0x5e, 0xe0,
	0x4d, 0xc9, 0x5e, 0xc3, 0xbc, 0x4f, 0x7f, 0x7d, 0x48, 0x82, 0x81, 0x97, 0xd5, 0xc5, 0x8f, 0x41,
	0x43, 0xb3, 0x17, 0xde, 0x32, 0x7e, 0x9c, 0x9d, 0xcc, 0xd5, 0x66, 0xa9, 0xea, 0x3e, 0x42, 0xf8,
	0xe9, 0xde, 0xd8, 0x0c, 0xaa, 0x75, 0xa4, 0x1a, 0x9b, 0x35, 0x62, 0x44, 0x73, 0x0a, 0x6d, 0x56,
	0x51, 0x68, 0xee, 0xa7, 0x68, 0x21, 0xa7, 0x37, 0xbe, 0xac, 0x50, 0x15, 0xf7, 0x67, 0xa5, 0x33,
	0x53, 0xba, 0xdf, 0xbe, 0x4c, 0x8d, 0xe6, 0xfe, 0xa8, 0x8a, 0x9c, 0x22, 0x4d, 0x85, 0xff, 0x1f,
	0x6a, 0x24, 0xd1, 0x38, 0xee, 0xb1, 0x08, 0xb8, 0xb9, 0x8d, 0x77, 0x8e, 0xa6, 0xe9, 0xd6, 0x28,
	0xe5, 0x29, 0x34, 0xe0, 0xf1, 0x86, 0xa8, 0x46, 0x80, 0xc0, 0x51, 0x45, 0xd4, 0x71, 0xcc, 0x69,
	0x90, 0xf1, 0x9b, 0x68, 0x69, 0x87, 0x48, 0xa1, 0xe2, 0x6b, 0x4e, 0x56, 0x5a, 0xa1, 0x20, 0x97,
	0x62, 0x40, 0x9a, 0xb3, 0x3d, 0x4e, 0xc7, 0x31, 0x51, 0xba, 0x61, 0xef, 0x06, 0x5a, 0xf3, 0xdc,
	0x2b, 0x08, 0x65, 0x63, 0xc5, 0x6d, 0x34, 0xfd, 0xe1, 0xe6, 0xfd, 0x3b, 0xcf, 0x1f, 0x3d, 0xeb,
	0x7c, 0x0d, 0x37, 0x50, 0x75, 0xf3, 0x69, 0xa7, 0x82, 0x9b, 0x68, 0xea, 0xde, 0x63, 0x6f, 0xb3,
	0x53, 0x75, 0x7f, 0xa5, 0x8a, 0xba, 0xc5, 0xe7, 0xad, 0x64, 0x1b, 0xd9, 0x22, 0x03, 0x2c, 0x68,
	0x48, 0xdf, 0x6e, 0x53, 0xc6, 0x76, 0xa3, 0x9a, 0x82, 0x27, 0x58, 0xa0, 0x26, 0x8f, 0x92, 0x53,
	0x69, 0x46, 0xcc, 0x64, 0xe3, 0xe8, 0x31, 0x93, 0x54, 0x91, 0x42, 0x4a, 0xc4, 0x1c, 0x33, 0x45,
	0x9a, 0x91, 0xdc, 0x1f, 0x54, 0xd0, 0xfc, 0x66, 0xb2, 0x49, 0x0d, 0x4f, 0x89, 0x5a, 0xc0, 0xd4,
	0x49, 0xe3, 0x03, 0x7f, 0x38, 0xde, 0xdf, 0x22, 0x31, 0x87, 0x84, 0x1a, 0x8d, 0x1e, 0x0c, 0x6a,
	0x6e, 0x52, 0x7d, 0xba, 0x3f, 0xe2, 0x06, 0xa8, 0x42, 0xc9, 0x4c, 0xdb, 0x9a, 0x62, 0xda, 0x2a,
	0x5f, 0xec, 0x00, 0xb7, 0x58, 0x7c, 0x8d, 0x4a, 0x72, 0xff, 0xa2, 0x8a, 0x66, 0x36, 0x13, 0x8f,
	0x84, 0xc3, 0x3e, 0x79, 0xf5, 0x28, 0xda, 0x51, 0x50, 0x69, 0x0b, 0x50, 0x69, 0xde, 0x5f, 0xa8,
	0x9f, 0x48, 0x7b, 0xc7, 0x8f, 0xd1, 0x3c, 0xfc, 0xf0, 0x63, 0x3e, 0xc9, 0xa4, 0x3c, 0x94, 0xdf,
	0x60, 0x89, 0x67, 0xd6, 0x56, 0x1c, 0x84, 0x75, 0xcd, 0x41, 0x68, 0xcc, 0xb0, 0x91, 0x9b, 0xa1,
	0x11, 0x54, 0x30, 0x7d, 0x48, 0x50, 0x41, 0x33, 0x17, 0x54, 0x00, 0x8e, 0x3c, 0xba, 0x12, 0xe0,
	0x01, 0xe2, 0xe8, 0x47, 0x25, 0xb9, 0x17, 0xc1, 0x0c, 0x85, 0x0a, 0x4c, 0x5a, 0x64, 0xe1, 0xc0,
	0x15, 0xe5, 0xb3, 0x02, 0xf7, 0x4f, 0xaa, 0xe8, 0x84, 0xca, 0x6b, 0xf5, 0xe5, 0x50, 0x8c, 0xa6,
	0x46, 0x54, 0x9b, 0xb0, 0xb5, 0x87, 0xdf, 0xb4, 0x95, 0x41, 0xb8, 0x1f, 0xa6, 0xdc, 0x18, 0x60,
	0x09, 0xe0, 0x44, 0x14, 0xa7, 0x77, 0x0f, 0x38, 0xc7, 0x79, 0x8a, 0x42, 0x7c, 0xb0, 0x35, 0xee,
	0x1e, 0x88, 0x08, 0x3c, 0x9e, 0xc4, 0xcf, 0x32, 0xbf, 0x3f, 0x0b, 0x68, 0xbb, 0x5d, 0xb4, 0x08,
	0xd6, 0xb1, 0x89, 0x17, 0xd2, 0x58, 0x98, 0xb7, 0x68, 0xaa, 0xfb, 0x5d, 0x34, 0xa3, 0x66, 0x58,
	0x82, 0xba, 0x6f, 0xab, 0x31, 0xd8, 0x85, 0xee, 0x70, 0x9d, 0x75, 0x6a, 0xe8, 0xf7, 0x7f, 0x54,
	0x90, 0x93, 0x1f, 0x53, 0x59, 0xac, 0x27, 0x04, 0x6d, 0xd1, 0x1f, 0x4f, 0x84, 0x53, 0xa3, 0xee,
	0x65, 0x04, 0x38, 0x9e, 0xe3, 0x38, 0x26, 0xc3, 0xf4, 0x89, 0x88, 0xad, 0xaa, 0x7b, 0x2a, 0x09,
	0xbf, 0xc9, 0xbd, 0x46, 0x53, 0x65, 0xf1, 0x0a, 0xea, 0x98, 0xb8, 0x67, 0x09, 0xa3, 0xa9, 0x24,
	0xfc, 0x79, 0xc2, 0x37, 0x27, 0xfc, 0xa6, 0x58, 0x71, 0x48, 0x5e, 0xb1, 0xae, 0xd8, 0xbe, 0x94,
	0x69, 0xf6, 0x48, 0x29, 0x79, 0x01, 0x79, 0xcc, 0xe3, 0x2d, 0xd3, 0x97, 0x3f, 0x45, 0x2d, 0x29,
	0x5d, 0x74, 0xa1, 0x3a, 0x87, 0xd0, 0xbd, 0xc7, 0x8f, 0x1e, 0x7b, 0xfe, 0xb3, 0xcd, 0x6f, 0x3f,
	0xeb, 0x54, 0xf0, 0x2c, 0x6a, 0xb1, 0xf4, 0x37, 0x37, 0xbf, 0xdd, 0xa9, 0xe2, 0x05, 0x34, 0xcb,
	0x92, 0x4f, 0xee, 0x3c, 0x7b, 0xb6, 0xe9, 0x7d, 0xd2, 0xa9, 0xe1, 0x79, 0xd4, 0x66, 0xa4, 0x87,
	0x1f, 0xdf, 0x79, 0xb0, 0xd9, 0x99, 0xda, 0xf8, 0xcf, 0x05, 0x79, 0x53, 0x20, 0xec, 0xc6, 0x1d,
	0x34, 0x45, 0x39, 0x8b, 0x0b, 0xbe, 0x16, 0x50, 0x76, 0x42, 0xd7, 0x2d, 0x2b, 0xc2, 0x5f, 0x51,
	0x76, 0x7e, 0xf9, 0x1f, 0xff, 0xf5, 0xb7, 0xaa, 0xd8, 0x9d, 0x15, 0x8f, 0x76, 0xaf, 0x0f, 0xc2,
	0x24, 0xbd, 0x5d, 0xb9, 0x8c, 0x7b, 0xa8, 0x76, 0xa7, 0xdf, 0xc7, 0x05, 0x6f, 0xf1, 0x66, 0x6f,
	0xf7, 0x76, 0xcf, 0x95, 0x94, 0xe0, 0xbd, 0x9c, 0x80, 0x5e, 0x16, 0xdc, 0x19, 0xd9, 0x4b, 0xd0,
	0xef, 0xd3, 0x4e, 0x7e, 0xb7, 0x02, 0xa6, 0xa1, 0xb9, 0x6f, 0xf0, 0xb5, 0x23, 0xed, 0xf9, 0xee,
	0xda, 0xa4, 0xc5, 0xf9, 0x78, 0x5c, 0x18, 0xcf, 0x69, 0xf7, 0x84, 0x1c, 0x0f, 0x49, 0xfc, 0x98,
	0x95, 0xf5, 0x07, 0xd1, 0x0e, 0x1d, 0xda, 0x1e, 0xaa, 0x3d, 0x20, 0x69, 0xd1, 0xfc, 0xb3, 0x00,
	0xe4, 0xee, 0x6b, 0x13, 0x18, 0xad, 0xee, 0x19, 0xe8, 0xf1, 0x04, 0x3e, 0x2e, 0x7b, 0xfc, 0x3c,
	0x13, 0xcb, 0xdf, 0xc3, 0xbf, 0x5a, 0x41, 0xed, 0x2c, 0x14, 0x38, 0xc1, 0xaf, 0x17, 0xf6, 0xaa,
	0x47, 0x0b, 0x77, 0x2f, 0x1c, 0x0e, 0x95, 0x87, 0x69, 0xe2, 0x5e, 0x84, 0xee, 0x57, 0xf0, 0xb2,
	0xb5, 0xfb, 0x75, 0x79, 0xd1, 0xfb, 0x39, 0x84, 0x56, 0x0b, 0xcf, 0xd6, 0xc4, 0xa3, 0x28, 0xbf,
	0x48, 0x76, 0x2f, 0x40, 0xef, 0x67, 0xf1, 0x99, 0xd2, 0xde, 0xf1, 0x0f, 0x65, 0xcc, 0xbe, 0xe4,
	0xc3, 0x24, 0x71, 0xb7, 0xc2, 0x0b, 0xd2, 0xbd, 0x3a, 0x59, 0x61, 0xbe, 0x07, 0x2e, 0xc1, 0xa0,
	0x5e, 0x73, 0x0f, 0x61, 0x09, 0xdd, 0x0a, 0x11, 0x6a, 0xf0, 0x97, 0x04, 0x26, 0x79, 0x03, 0xbc,
	0x3b, 0xd1, 0xe3, 0xde, 0x6e, 0x17, 0xfa, 0x5f, 0x74, 0xe7, 0x65, 0xff, 0x4c, 0xcd, 0xd1, 0x0e,
	0x13, 0x34, 0xcd, 0xdf, 0x0f, 0xc7, 0xa5, 0x8d, 0x25, 0x87, 0x6c, 0x03, 0xe3, 0x11, 0x72, 0xf7,
	0x14, 0xf4, 0x79, 0xdc, 0xed, 0x18, 0x7d, 0xc2, 0x2c, 0x5f, 0x2a, 0x9f, 0x71, 0x5c, 0x38, 0xe4,
	0xd5, 0x74, 0xde, 0xed, 0xc5, 0xc3, 0x8a, 0xf1, 0x7e, 0x4f, 0x43, 0xbf, 0x4b, 0xee, 0x82, 0xd1,
	0xef, 0xd6, 0x01, 0xed, 0xf8, 0x0f, 0x2a, 0x08, 0xe7, 0x1f, 0x7a, 0xc7, 0xeb, 0x65, 0x8d, 0x5b,
	0x1e, 0xdf, 0xef, 0x5e, 0x9f, 0xbc, 0x02, 0x1f, 0x17, 0x3f, 0x16, 0xee, 0x29, 0x63, 0x5c, 0x14,
	0x1e, 0x26, 0xbb, 0xd1, 0x68, 0x3f, 0x18, 0x0c, 0x98, 0x2c, 0xa8, 0xc3, 0xb7, 0x0b, 0xd8, 0x3d,
	0xfc, 0x73, 0x89, 0x22, 0x79, 0xa0, 0x7d, 0xfc, 0xe0, 0x9e, 0x84, 0x9e, 0x8f, 0xb9, 0x73, 0xb2,
	0x67, 0x40, 0x27, 0xb4, 0xb3, 0x5f, 0x67, 0x32, 0x31, 0x77, 0x67, 0x7f, 0xa5, 0xf0, 0x34, 0xe6,
	0xa3, 0x07, 0x8a, 0x56, 0xc6, 0x6c, 0xd4, 0x3d, 0x0f, 0xe3, 0x58, 0x76, 0x4f, 0x66, 0xe3, 0xc8,
	0x8a, 0x48, 0x5d, 0xf0, 0x7d, 0xfe, 0x72, 0xba, 0xb8, 0xae, 0x5e, 0x2d, 0xd6, 0x2c, 0xfa, 0x95,
	0x7f, 0xf7, 0xd2, 0x04, 0x25, 0x39, 0x4b, 0x0e, 0x91, 0x12, 0xbb, 0xbc, 0x6f, 0x1f, 0x55, 0x9f,
	0x8f, 0xf0, 0xd9, 0xa2, 0xb5, 0x16, 0x1d, 0xaf, 0x14, 0x17, 0xe0, 0xfd, 0x2d, 0x41, 0x7f, 0x1d,
	0xb7, 0xad, 0x2c, 0x3e, 0xe7, 0xff, 0xac, 0x76, 0x4b, 0x85, 0x2f, 0x97, 0xe8, 0x00, 0xe3, 0x9a,
	0xac, 0x7b, 0x65, 0xa2, 0xb2, 0xfa, 0xfe, 0x53, 0xc4, 0x32, 0x5c, 0x95, 0xac, 0x7f, 0xce, 0xaf,
	0xd6, 0xbe, 0xb7, 0xfe, 0xf9, 0x1e, 0x39, 0xf8, 0x1e, 0x7e, 0x29, 0xae, 0x4e, 0x84, 0x99, 0x5c,
	0x24, 0x88, 0xb4, 0x5b, 0x9d, 0xee, 0xf9, 0xf2, 0x42, 0x85, 0x82, 0x88, 0x5d, 0xdb, 0x50, 0x5e,
	0xfc, 0x02, 0xa8, 0x25, 0xd9, 0xeb, 0x6a, 0xe1, 0xe4, 0x0c, 0x8f, 0x74, 0xd1, 0xba, 0x5b, 0xdc,
	0xc0, 0x0a, 0x04, 0xd9, 0x21, 0xe9, 0x35, 0xe1, 0xd9, 0xbd, 0x5d, 0xb9, 0x7c, 0xf7, 0x83, 0xbf,
	0xfb, 0xc9, 0x72, 0xe5, 0xef, 0x7f, 0xb2, 0x5c, 0xf9, 0x97, 0x9f, 0x2c, 0x57, 0xbe, 0x73, 0x63,
	0x27, 0x4c, 0x07, 0xc1, 0x96, 0x68, 0x78, 0x98, 0xfd, 0x9f, 0x24, 0xe1, 0x90, 0x79, 0x6a, 0xaf,
	0x05, 0xa3, 0x30, 0xb9, 0xb6, 0x13, 0x89, 0x89, 0x6c, 0x35, 0xa0, 0xc8, 0xcd, 0xff, 0x0e, 0x00,
	0x00, 0xff, 0xff, 0x74, 0x20, 0x64, 0x5d, 0x22, 0x65, 0x00, 0x00,
}
