// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fdms/struct.proto

package fdms // import "gitlab.sendo.vn/protobuf/internal-apis-go/fdms"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ProductGerne int32

const (
	ProductGerne_PRODUCT_GERNE_UNKNOWN        ProductGerne = 0
	ProductGerne_PRODUCT_GERNE_BASIC_GOODS    ProductGerne = 1
	ProductGerne_PRODUCT_GERNE_CONSUMER_GOODS ProductGerne = 2
)

var ProductGerne_name = map[int32]string{
	0: "PRODUCT_GERNE_UNKNOWN",
	1: "PRODUCT_GERNE_BASIC_GOODS",
	2: "PRODUCT_GERNE_CONSUMER_GOODS",
}
var ProductGerne_value = map[string]int32{
	"PRODUCT_GERNE_UNKNOWN":        0,
	"PRODUCT_GERNE_BASIC_GOODS":    1,
	"PRODUCT_GERNE_CONSUMER_GOODS": 2,
}

func (x ProductGerne) String() string {
	return proto.EnumName(ProductGerne_name, int32(x))
}
func (ProductGerne) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{0}
}

type FraudType int32

const (
	FraudType_FRAUD_TYPE_UNKNOWN      FraudType = 0
	FraudType_FRAUD_TYPE_VOUCHER      FraudType = 1
	FraudType_FRAUD_TYPE_SHIPPING_FEE FraudType = 2
	FraudType_FRAUD_TYPE_CASHBACK     FraudType = 3
)

var FraudType_name = map[int32]string{
	0: "FRAUD_TYPE_UNKNOWN",
	1: "FRAUD_TYPE_VOUCHER",
	2: "FRAUD_TYPE_SHIPPING_FEE",
	3: "FRAUD_TYPE_CASHBACK",
}
var FraudType_value = map[string]int32{
	"FRAUD_TYPE_UNKNOWN":      0,
	"FRAUD_TYPE_VOUCHER":      1,
	"FRAUD_TYPE_SHIPPING_FEE": 2,
	"FRAUD_TYPE_CASHBACK":     3,
}

func (x FraudType) String() string {
	return proto.EnumName(FraudType_name, int32(x))
}
func (FraudType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{1}
}

type PaymentMethod int32

const (
	PaymentMethod_PAYMENT_METHOD_UNKNOWN  PaymentMethod = 0
	PaymentMethod_PAYMENT_METHOD_COD      PaymentMethod = 1
	PaymentMethod_PAYMENT_METHOD_INSTANCE PaymentMethod = 2
	PaymentMethod_PAYMENT_METHOD_ONLINE   PaymentMethod = 3
)

var PaymentMethod_name = map[int32]string{
	0: "PAYMENT_METHOD_UNKNOWN",
	1: "PAYMENT_METHOD_COD",
	2: "PAYMENT_METHOD_INSTANCE",
	3: "PAYMENT_METHOD_ONLINE",
}
var PaymentMethod_value = map[string]int32{
	"PAYMENT_METHOD_UNKNOWN":  0,
	"PAYMENT_METHOD_COD":      1,
	"PAYMENT_METHOD_INSTANCE": 2,
	"PAYMENT_METHOD_ONLINE":   3,
}

func (x PaymentMethod) String() string {
	return proto.EnumName(PaymentMethod_name, int32(x))
}
func (PaymentMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{2}
}

type ShopLevel int32

const (
	ShopLevel_SHOP_LEVEL_UNKNOWN ShopLevel = 0
	ShopLevel_SHOP_LEVEL_SUT     ShopLevel = 1
	ShopLevel_SHOP_LEVEL_STC     ShopLevel = 2
)

var ShopLevel_name = map[int32]string{
	0: "SHOP_LEVEL_UNKNOWN",
	1: "SHOP_LEVEL_SUT",
	2: "SHOP_LEVEL_STC",
}
var ShopLevel_value = map[string]int32{
	"SHOP_LEVEL_UNKNOWN": 0,
	"SHOP_LEVEL_SUT":     1,
	"SHOP_LEVEL_STC":     2,
}

func (x ShopLevel) String() string {
	return proto.EnumName(ShopLevel_name, int32(x))
}
func (ShopLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{3}
}

type CancelBy int32

const (
	CancelBy_CANCEL_BY_OFF    CancelBy = 0
	CancelBy_CANCEL_BY_BUYER  CancelBy = 1
	CancelBy_CANCEL_BY_SELLER CancelBy = 2
	CancelBy_CANCEL_BY_OTHER  CancelBy = 3
)

var CancelBy_name = map[int32]string{
	0: "CANCEL_BY_OFF",
	1: "CANCEL_BY_BUYER",
	2: "CANCEL_BY_SELLER",
	3: "CANCEL_BY_OTHER",
}
var CancelBy_value = map[string]int32{
	"CANCEL_BY_OFF":    0,
	"CANCEL_BY_BUYER":  1,
	"CANCEL_BY_SELLER": 2,
	"CANCEL_BY_OTHER":  3,
}

func (x CancelBy) String() string {
	return proto.EnumName(CancelBy_name, int32(x))
}
func (CancelBy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{4}
}

type ListOrdersBySellerReq struct {
	SellerAccountId      uint64     `protobuf:"varint,1,opt,name=seller_account_id,json=sellerAccountId,proto3" json:"seller_account_id,omitempty"`
	ReqParams            *ReqParams `protobuf:"bytes,2,opt,name=req_params,json=reqParams" json:"req_params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListOrdersBySellerReq) Reset()         { *m = ListOrdersBySellerReq{} }
func (m *ListOrdersBySellerReq) String() string { return proto.CompactTextString(m) }
func (*ListOrdersBySellerReq) ProtoMessage()    {}
func (*ListOrdersBySellerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{0}
}
func (m *ListOrdersBySellerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOrdersBySellerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOrdersBySellerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListOrdersBySellerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersBySellerReq.Merge(dst, src)
}
func (m *ListOrdersBySellerReq) XXX_Size() int {
	return m.Size()
}
func (m *ListOrdersBySellerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersBySellerReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersBySellerReq proto.InternalMessageInfo

func (m *ListOrdersBySellerReq) GetSellerAccountId() uint64 {
	if m != nil {
		return m.SellerAccountId
	}
	return 0
}

func (m *ListOrdersBySellerReq) GetReqParams() *ReqParams {
	if m != nil {
		return m.ReqParams
	}
	return nil
}

type ListOrdersBySellerRes struct {
	Data                 []*Order `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	Total                uint32   `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersBySellerRes) Reset()         { *m = ListOrdersBySellerRes{} }
func (m *ListOrdersBySellerRes) String() string { return proto.CompactTextString(m) }
func (*ListOrdersBySellerRes) ProtoMessage()    {}
func (*ListOrdersBySellerRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{1}
}
func (m *ListOrdersBySellerRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOrdersBySellerRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOrdersBySellerRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListOrdersBySellerRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersBySellerRes.Merge(dst, src)
}
func (m *ListOrdersBySellerRes) XXX_Size() int {
	return m.Size()
}
func (m *ListOrdersBySellerRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersBySellerRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersBySellerRes proto.InternalMessageInfo

func (m *ListOrdersBySellerRes) GetData() []*Order {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ListOrdersBySellerRes) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ListOrdersByBuyerReq struct {
	BuyerAccountId       uint64     `protobuf:"varint,1,opt,name=buyer_account_id,json=buyerAccountId,proto3" json:"buyer_account_id,omitempty"`
	ReqParams            *ReqParams `protobuf:"bytes,2,opt,name=req_params,json=reqParams" json:"req_params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListOrdersByBuyerReq) Reset()         { *m = ListOrdersByBuyerReq{} }
func (m *ListOrdersByBuyerReq) String() string { return proto.CompactTextString(m) }
func (*ListOrdersByBuyerReq) ProtoMessage()    {}
func (*ListOrdersByBuyerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{2}
}
func (m *ListOrdersByBuyerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOrdersByBuyerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOrdersByBuyerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListOrdersByBuyerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersByBuyerReq.Merge(dst, src)
}
func (m *ListOrdersByBuyerReq) XXX_Size() int {
	return m.Size()
}
func (m *ListOrdersByBuyerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersByBuyerReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersByBuyerReq proto.InternalMessageInfo

func (m *ListOrdersByBuyerReq) GetBuyerAccountId() uint64 {
	if m != nil {
		return m.BuyerAccountId
	}
	return 0
}

func (m *ListOrdersByBuyerReq) GetReqParams() *ReqParams {
	if m != nil {
		return m.ReqParams
	}
	return nil
}

type ListOrdersByBuyerRes struct {
	Data                 []*Order `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	Total                uint32   `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersByBuyerRes) Reset()         { *m = ListOrdersByBuyerRes{} }
func (m *ListOrdersByBuyerRes) String() string { return proto.CompactTextString(m) }
func (*ListOrdersByBuyerRes) ProtoMessage()    {}
func (*ListOrdersByBuyerRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{3}
}
func (m *ListOrdersByBuyerRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOrdersByBuyerRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOrdersByBuyerRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListOrdersByBuyerRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersByBuyerRes.Merge(dst, src)
}
func (m *ListOrdersByBuyerRes) XXX_Size() int {
	return m.Size()
}
func (m *ListOrdersByBuyerRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersByBuyerRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersByBuyerRes proto.InternalMessageInfo

func (m *ListOrdersByBuyerRes) GetData() []*Order {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ListOrdersByBuyerRes) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ReqParams struct {
	Page                 uint32   `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	Limit                uint32   `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	From                 uint32   `protobuf:"varint,3,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint32   `protobuf:"varint,4,opt,name=to,proto3" json:"to,omitempty"`
	SortBy               string   `protobuf:"bytes,5,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqParams) Reset()         { *m = ReqParams{} }
func (m *ReqParams) String() string { return proto.CompactTextString(m) }
func (*ReqParams) ProtoMessage()    {}
func (*ReqParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{4}
}
func (m *ReqParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqParams.Merge(dst, src)
}
func (m *ReqParams) XXX_Size() int {
	return m.Size()
}
func (m *ReqParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqParams.DiscardUnknown(m)
}

var xxx_messageInfo_ReqParams proto.InternalMessageInfo

func (m *ReqParams) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ReqParams) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqParams) GetFrom() uint32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ReqParams) GetTo() uint32 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ReqParams) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

type Order struct {
	OrderId               string        `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	RemoteIp              string        `protobuf:"bytes,2,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	CreatedAt             uint32        `protobuf:"varint,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt             uint32        `protobuf:"varint,4,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	GrandTotal            uint64        `protobuf:"varint,5,opt,name=grand_total,json=grandTotal,proto3" json:"grand_total,omitempty"`
	SubTotal              uint64        `protobuf:"varint,6,opt,name=sub_total,json=subTotal,proto3" json:"sub_total,omitempty"`
	CancelBy              CancelBy      `protobuf:"varint,7,opt,name=cancel_by,json=cancelBy,proto3,enum=sendo.v1.api.fdms.CancelBy" json:"cancel_by,omitempty"`
	PaymentMethod         PaymentMethod `protobuf:"varint,8,opt,name=payment_method,json=paymentMethod,proto3,enum=sendo.v1.api.fdms.PaymentMethod" json:"payment_method,omitempty"`
	FraudInfo             *Fraud        `protobuf:"bytes,9,opt,name=fraud_info,json=fraudInfo" json:"fraud_info,omitempty"`
	ShippingAddress       *Address      `protobuf:"bytes,10,opt,name=shipping_address,json=shippingAddress" json:"shipping_address,omitempty"`
	WarehouseAddress      *Address      `protobuf:"bytes,11,opt,name=warehouse_address,json=warehouseAddress" json:"warehouse_address,omitempty"`
	SendoShippingDiscount uint64        `protobuf:"varint,12,opt,name=sendo_shipping_discount,json=sendoShippingDiscount,proto3" json:"sendo_shipping_discount,omitempty"`
	BuyerAgent            string        `protobuf:"bytes,13,opt,name=buyer_agent,json=buyerAgent,proto3" json:"buyer_agent,omitempty"`
	BuyerDevice           string        `protobuf:"bytes,14,opt,name=buyer_device,json=buyerDevice,proto3" json:"buyer_device,omitempty"`
	Buyer                 *Buyer        `protobuf:"bytes,15,opt,name=buyer" json:"buyer,omitempty"`
	Seller                *Seller       `protobuf:"bytes,16,opt,name=seller" json:"seller,omitempty"`
	Voucher               *Voucher      `protobuf:"bytes,17,opt,name=voucher" json:"voucher,omitempty"`
	Rating                *Rating       `protobuf:"bytes,18,opt,name=rating" json:"rating,omitempty"`
	CompletedAt           uint32        `protobuf:"varint,19,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	CarriedId             string        `protobuf:"bytes,20,opt,name=carried_id,json=carriedId,proto3" json:"carried_id,omitempty"`
	AffiliateAmount       uint64        `protobuf:"varint,21,opt,name=affiliate_amount,json=affiliateAmount,proto3" json:"affiliate_amount,omitempty"`
	SendoSupportFee       uint64        `protobuf:"varint,22,opt,name=sendo_support_fee,json=sendoSupportFee,proto3" json:"sendo_support_fee,omitempty"`
	SenpaySupportFee      uint64        `protobuf:"varint,23,opt,name=senpay_support_fee,json=senpaySupportFee,proto3" json:"senpay_support_fee,omitempty"`
	LoyaltyAmount         uint64        `protobuf:"varint,24,opt,name=loyalty_amount,json=loyaltyAmount,proto3" json:"loyalty_amount,omitempty"`
	Weight                uint32        `protobuf:"varint,25,opt,name=weight,proto3" json:"weight,omitempty"`
	IsFreeShipping        bool          `protobuf:"varint,26,opt,name=is_free_shipping,json=isFreeShipping,proto3" json:"is_free_shipping,omitempty"`
	Products              []*Product    `protobuf:"bytes,30,rep,name=products" json:"products,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}      `json:"-"`
	XXX_unrecognized      []byte        `json:"-"`
	XXX_sizecache         int32         `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{5}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(dst, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetRemoteIp() string {
	if m != nil {
		return m.RemoteIp
	}
	return ""
}

func (m *Order) GetCreatedAt() uint32 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetUpdatedAt() uint32 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *Order) GetGrandTotal() uint64 {
	if m != nil {
		return m.GrandTotal
	}
	return 0
}

func (m *Order) GetSubTotal() uint64 {
	if m != nil {
		return m.SubTotal
	}
	return 0
}

func (m *Order) GetCancelBy() CancelBy {
	if m != nil {
		return m.CancelBy
	}
	return CancelBy_CANCEL_BY_OFF
}

func (m *Order) GetPaymentMethod() PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return PaymentMethod_PAYMENT_METHOD_UNKNOWN
}

func (m *Order) GetFraudInfo() *Fraud {
	if m != nil {
		return m.FraudInfo
	}
	return nil
}

func (m *Order) GetShippingAddress() *Address {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

func (m *Order) GetWarehouseAddress() *Address {
	if m != nil {
		return m.WarehouseAddress
	}
	return nil
}

func (m *Order) GetSendoShippingDiscount() uint64 {
	if m != nil {
		return m.SendoShippingDiscount
	}
	return 0
}

func (m *Order) GetBuyerAgent() string {
	if m != nil {
		return m.BuyerAgent
	}
	return ""
}

func (m *Order) GetBuyerDevice() string {
	if m != nil {
		return m.BuyerDevice
	}
	return ""
}

func (m *Order) GetBuyer() *Buyer {
	if m != nil {
		return m.Buyer
	}
	return nil
}

func (m *Order) GetSeller() *Seller {
	if m != nil {
		return m.Seller
	}
	return nil
}

func (m *Order) GetVoucher() *Voucher {
	if m != nil {
		return m.Voucher
	}
	return nil
}

func (m *Order) GetRating() *Rating {
	if m != nil {
		return m.Rating
	}
	return nil
}

func (m *Order) GetCompletedAt() uint32 {
	if m != nil {
		return m.CompletedAt
	}
	return 0
}

func (m *Order) GetCarriedId() string {
	if m != nil {
		return m.CarriedId
	}
	return ""
}

func (m *Order) GetAffiliateAmount() uint64 {
	if m != nil {
		return m.AffiliateAmount
	}
	return 0
}

func (m *Order) GetSendoSupportFee() uint64 {
	if m != nil {
		return m.SendoSupportFee
	}
	return 0
}

func (m *Order) GetSenpaySupportFee() uint64 {
	if m != nil {
		return m.SenpaySupportFee
	}
	return 0
}

func (m *Order) GetLoyaltyAmount() uint64 {
	if m != nil {
		return m.LoyaltyAmount
	}
	return 0
}

func (m *Order) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Order) GetIsFreeShipping() bool {
	if m != nil {
		return m.IsFreeShipping
	}
	return false
}

func (m *Order) GetProducts() []*Product {
	if m != nil {
		return m.Products
	}
	return nil
}

type Buyer struct {
	Account              *Account `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	IsBadBuyer           bool     `protobuf:"varint,2,opt,name=is_bad_buyer,json=isBadBuyer,proto3" json:"is_bad_buyer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Buyer) Reset()         { *m = Buyer{} }
func (m *Buyer) String() string { return proto.CompactTextString(m) }
func (*Buyer) ProtoMessage()    {}
func (*Buyer) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{6}
}
func (m *Buyer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Buyer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Buyer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Buyer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Buyer.Merge(dst, src)
}
func (m *Buyer) XXX_Size() int {
	return m.Size()
}
func (m *Buyer) XXX_DiscardUnknown() {
	xxx_messageInfo_Buyer.DiscardUnknown(m)
}

var xxx_messageInfo_Buyer proto.InternalMessageInfo

func (m *Buyer) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *Buyer) GetIsBadBuyer() bool {
	if m != nil {
		return m.IsBadBuyer
	}
	return false
}

type Seller struct {
	Account              *Account  `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	ShopId               uint64    `protobuf:"varint,10,opt,name=shop_id,json=shopId,proto3" json:"shop_id,omitempty"`
	ShopLevel            ShopLevel `protobuf:"varint,11,opt,name=shop_level,json=shopLevel,proto3,enum=sendo.v1.api.fdms.ShopLevel" json:"shop_level,omitempty"`
	ShopCreatedAt        uint64    `protobuf:"varint,12,opt,name=shop_created_at,json=shopCreatedAt,proto3" json:"shop_created_at,omitempty"`
	ShopUpdatedAt        uint64    `protobuf:"varint,13,opt,name=shop_updated_at,json=shopUpdatedAt,proto3" json:"shop_updated_at,omitempty"`
	ShopTotalOrders      uint64    `protobuf:"varint,14,opt,name=shop_total_orders,json=shopTotalOrders,proto3" json:"shop_total_orders,omitempty"`
	ShopTotalProducts    uint64    `protobuf:"varint,15,opt,name=shop_total_products,json=shopTotalProducts,proto3" json:"shop_total_products,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Seller) Reset()         { *m = Seller{} }
func (m *Seller) String() string { return proto.CompactTextString(m) }
func (*Seller) ProtoMessage()    {}
func (*Seller) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{7}
}
func (m *Seller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Seller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Seller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Seller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Seller.Merge(dst, src)
}
func (m *Seller) XXX_Size() int {
	return m.Size()
}
func (m *Seller) XXX_DiscardUnknown() {
	xxx_messageInfo_Seller.DiscardUnknown(m)
}

var xxx_messageInfo_Seller proto.InternalMessageInfo

func (m *Seller) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *Seller) GetShopId() uint64 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *Seller) GetShopLevel() ShopLevel {
	if m != nil {
		return m.ShopLevel
	}
	return ShopLevel_SHOP_LEVEL_UNKNOWN
}

func (m *Seller) GetShopCreatedAt() uint64 {
	if m != nil {
		return m.ShopCreatedAt
	}
	return 0
}

func (m *Seller) GetShopUpdatedAt() uint64 {
	if m != nil {
		return m.ShopUpdatedAt
	}
	return 0
}

func (m *Seller) GetShopTotalOrders() uint64 {
	if m != nil {
		return m.ShopTotalOrders
	}
	return 0
}

func (m *Seller) GetShopTotalProducts() uint64 {
	if m != nil {
		return m.ShopTotalProducts
	}
	return 0
}

type Account struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Phone                string   `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
	Email                string   `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	RemoteIp             string   `protobuf:"bytes,4,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	ContactAddress       *Address `protobuf:"bytes,5,opt,name=contact_address,json=contactAddress" json:"contact_address,omitempty"`
	CreatedAt            uint32   `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{8}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(dst, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Account) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *Account) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Account) GetRemoteIp() string {
	if m != nil {
		return m.RemoteIp
	}
	return ""
}

func (m *Account) GetContactAddress() *Address {
	if m != nil {
		return m.ContactAddress
	}
	return nil
}

func (m *Account) GetCreatedAt() uint32 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

type Product struct {
	ProductId            uint32       `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	CategoryPath         string       `protobuf:"bytes,2,opt,name=category_path,json=categoryPath,proto3" json:"category_path,omitempty"`
	Gerne                ProductGerne `protobuf:"varint,3,opt,name=gerne,proto3,enum=sendo.v1.api.fdms.ProductGerne" json:"gerne,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{9}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(dst, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductId() uint32 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

func (m *Product) GetCategoryPath() string {
	if m != nil {
		return m.CategoryPath
	}
	return ""
}

func (m *Product) GetGerne() ProductGerne {
	if m != nil {
		return m.Gerne
	}
	return ProductGerne_PRODUCT_GERNE_UNKNOWN
}

type Voucher struct {
	VoucherCode          string   `protobuf:"bytes,1,opt,name=voucher_code,json=voucherCode,proto3" json:"voucher_code,omitempty"`
	Amount               uint64   `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	VoucherCampaign      string   `protobuf:"bytes,3,opt,name=voucher_campaign,json=voucherCampaign,proto3" json:"voucher_campaign,omitempty"`
	IsVoucherShop        bool     `protobuf:"varint,4,opt,name=is_voucher_shop,json=isVoucherShop,proto3" json:"is_voucher_shop,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Voucher) Reset()         { *m = Voucher{} }
func (m *Voucher) String() string { return proto.CompactTextString(m) }
func (*Voucher) ProtoMessage()    {}
func (*Voucher) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{10}
}
func (m *Voucher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Voucher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Voucher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Voucher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Voucher.Merge(dst, src)
}
func (m *Voucher) XXX_Size() int {
	return m.Size()
}
func (m *Voucher) XXX_DiscardUnknown() {
	xxx_messageInfo_Voucher.DiscardUnknown(m)
}

var xxx_messageInfo_Voucher proto.InternalMessageInfo

func (m *Voucher) GetVoucherCode() string {
	if m != nil {
		return m.VoucherCode
	}
	return ""
}

func (m *Voucher) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Voucher) GetVoucherCampaign() string {
	if m != nil {
		return m.VoucherCampaign
	}
	return ""
}

func (m *Voucher) GetIsVoucherShop() bool {
	if m != nil {
		return m.IsVoucherShop
	}
	return false
}

type Fraud struct {
	IsFraud              bool      `protobuf:"varint,1,opt,name=is_fraud,json=isFraud,proto3" json:"is_fraud,omitempty"`
	Weight               float32   `protobuf:"fixed32,2,opt,name=weight,proto3" json:"weight,omitempty"`
	Type                 FraudType `protobuf:"varint,3,opt,name=type,proto3,enum=sendo.v1.api.fdms.FraudType" json:"type,omitempty"`
	IsOverrided          bool      `protobuf:"varint,4,opt,name=is_overrided,json=isOverrided,proto3" json:"is_overrided,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Fraud) Reset()         { *m = Fraud{} }
func (m *Fraud) String() string { return proto.CompactTextString(m) }
func (*Fraud) ProtoMessage()    {}
func (*Fraud) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{11}
}
func (m *Fraud) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fraud) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fraud.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Fraud) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fraud.Merge(dst, src)
}
func (m *Fraud) XXX_Size() int {
	return m.Size()
}
func (m *Fraud) XXX_DiscardUnknown() {
	xxx_messageInfo_Fraud.DiscardUnknown(m)
}

var xxx_messageInfo_Fraud proto.InternalMessageInfo

func (m *Fraud) GetIsFraud() bool {
	if m != nil {
		return m.IsFraud
	}
	return false
}

func (m *Fraud) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Fraud) GetType() FraudType {
	if m != nil {
		return m.Type
	}
	return FraudType_FRAUD_TYPE_UNKNOWN
}

func (m *Fraud) GetIsOverrided() bool {
	if m != nil {
		return m.IsOverrided
	}
	return false
}

type Address struct {
	RegionId             uint32   `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionName           string   `protobuf:"bytes,2,opt,name=region_name,json=regionName,proto3" json:"region_name,omitempty"`
	DistrictId           uint32   `protobuf:"varint,3,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	DistrictName         string   `protobuf:"bytes,4,opt,name=district_name,json=districtName,proto3" json:"district_name,omitempty"`
	WardId               uint32   `protobuf:"varint,5,opt,name=ward_id,json=wardId,proto3" json:"ward_id,omitempty"`
	WardName             string   `protobuf:"bytes,6,opt,name=ward_name,json=wardName,proto3" json:"ward_name,omitempty"`
	Street               string   `protobuf:"bytes,7,opt,name=street,proto3" json:"street,omitempty"`
	Phone                string   `protobuf:"bytes,10,opt,name=phone,proto3" json:"phone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{12}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(dst, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetRegionId() uint32 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *Address) GetRegionName() string {
	if m != nil {
		return m.RegionName
	}
	return ""
}

func (m *Address) GetDistrictId() uint32 {
	if m != nil {
		return m.DistrictId
	}
	return 0
}

func (m *Address) GetDistrictName() string {
	if m != nil {
		return m.DistrictName
	}
	return ""
}

func (m *Address) GetWardId() uint32 {
	if m != nil {
		return m.WardId
	}
	return 0
}

func (m *Address) GetWardName() string {
	if m != nil {
		return m.WardName
	}
	return ""
}

func (m *Address) GetStreet() string {
	if m != nil {
		return m.Street
	}
	return ""
}

func (m *Address) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

type Rating struct {
	Score                uint32   `protobuf:"varint,1,opt,name=score,proto3" json:"score,omitempty"`
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rating) Reset()         { *m = Rating{} }
func (m *Rating) String() string { return proto.CompactTextString(m) }
func (*Rating) ProtoMessage()    {}
func (*Rating) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{13}
}
func (m *Rating) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rating) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rating.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Rating) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rating.Merge(dst, src)
}
func (m *Rating) XXX_Size() int {
	return m.Size()
}
func (m *Rating) XXX_DiscardUnknown() {
	xxx_messageInfo_Rating.DiscardUnknown(m)
}

var xxx_messageInfo_Rating proto.InternalMessageInfo

func (m *Rating) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Rating) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type Error struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_struct_692415c35026ebf0, []int{14}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*ListOrdersBySellerReq)(nil), "sendo.v1.api.fdms.ListOrdersBySellerReq")
	proto.RegisterType((*ListOrdersBySellerRes)(nil), "sendo.v1.api.fdms.ListOrdersBySellerRes")
	proto.RegisterType((*ListOrdersByBuyerReq)(nil), "sendo.v1.api.fdms.ListOrdersByBuyerReq")
	proto.RegisterType((*ListOrdersByBuyerRes)(nil), "sendo.v1.api.fdms.ListOrdersByBuyerRes")
	proto.RegisterType((*ReqParams)(nil), "sendo.v1.api.fdms.ReqParams")
	proto.RegisterType((*Order)(nil), "sendo.v1.api.fdms.Order")
	proto.RegisterType((*Buyer)(nil), "sendo.v1.api.fdms.Buyer")
	proto.RegisterType((*Seller)(nil), "sendo.v1.api.fdms.Seller")
	proto.RegisterType((*Account)(nil), "sendo.v1.api.fdms.Account")
	proto.RegisterType((*Product)(nil), "sendo.v1.api.fdms.Product")
	proto.RegisterType((*Voucher)(nil), "sendo.v1.api.fdms.Voucher")
	proto.RegisterType((*Fraud)(nil), "sendo.v1.api.fdms.Fraud")
	proto.RegisterType((*Address)(nil), "sendo.v1.api.fdms.Address")
	proto.RegisterType((*Rating)(nil), "sendo.v1.api.fdms.Rating")
	proto.RegisterType((*Error)(nil), "sendo.v1.api.fdms.Error")
	proto.RegisterEnum("sendo.v1.api.fdms.ProductGerne", ProductGerne_name, ProductGerne_value)
	proto.RegisterEnum("sendo.v1.api.fdms.FraudType", FraudType_name, FraudType_value)
	proto.RegisterEnum("sendo.v1.api.fdms.PaymentMethod", PaymentMethod_name, PaymentMethod_value)
	proto.RegisterEnum("sendo.v1.api.fdms.ShopLevel", ShopLevel_name, ShopLevel_value)
	proto.RegisterEnum("sendo.v1.api.fdms.CancelBy", CancelBy_name, CancelBy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FDMSServiceClient is the client API for FDMSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FDMSServiceClient interface {
	GetListOrdersBySeller(ctx context.Context, in *ListOrdersBySellerReq, opts ...grpc.CallOption) (*ListOrdersBySellerRes, error)
	GetListOrdersByBuyer(ctx context.Context, in *ListOrdersByBuyerReq, opts ...grpc.CallOption) (*ListOrdersByBuyerRes, error)
}

type fDMSServiceClient struct {
	cc *grpc.ClientConn
}

func NewFDMSServiceClient(cc *grpc.ClientConn) FDMSServiceClient {
	return &fDMSServiceClient{cc}
}

func (c *fDMSServiceClient) GetListOrdersBySeller(ctx context.Context, in *ListOrdersBySellerReq, opts ...grpc.CallOption) (*ListOrdersBySellerRes, error) {
	out := new(ListOrdersBySellerRes)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.fdms.FDMSService/GetListOrdersBySeller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fDMSServiceClient) GetListOrdersByBuyer(ctx context.Context, in *ListOrdersByBuyerReq, opts ...grpc.CallOption) (*ListOrdersByBuyerRes, error) {
	out := new(ListOrdersByBuyerRes)
	err := c.cc.Invoke(ctx, "/sendo.v1.api.fdms.FDMSService/GetListOrdersByBuyer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FDMSServiceServer is the server API for FDMSService service.
type FDMSServiceServer interface {
	GetListOrdersBySeller(context.Context, *ListOrdersBySellerReq) (*ListOrdersBySellerRes, error)
	GetListOrdersByBuyer(context.Context, *ListOrdersByBuyerReq) (*ListOrdersByBuyerRes, error)
}

func RegisterFDMSServiceServer(s *grpc.Server, srv FDMSServiceServer) {
	s.RegisterService(&_FDMSService_serviceDesc, srv)
}

func _FDMSService_GetListOrdersBySeller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersBySellerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FDMSServiceServer).GetListOrdersBySeller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.fdms.FDMSService/GetListOrdersBySeller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FDMSServiceServer).GetListOrdersBySeller(ctx, req.(*ListOrdersBySellerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FDMSService_GetListOrdersByBuyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersByBuyerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FDMSServiceServer).GetListOrdersByBuyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sendo.v1.api.fdms.FDMSService/GetListOrdersByBuyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FDMSServiceServer).GetListOrdersByBuyer(ctx, req.(*ListOrdersByBuyerReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FDMSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sendo.v1.api.fdms.FDMSService",
	HandlerType: (*FDMSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetListOrdersBySeller",
			Handler:    _FDMSService_GetListOrdersBySeller_Handler,
		},
		{
			MethodName: "GetListOrdersByBuyer",
			Handler:    _FDMSService_GetListOrdersByBuyer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fdms/struct.proto",
}

func (m *ListOrdersBySellerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersBySellerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SellerAccountId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.SellerAccountId))
	}
	if m.ReqParams != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ReqParams.Size()))
		n1, err := m.ReqParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListOrdersBySellerRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersBySellerRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStruct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListOrdersByBuyerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersByBuyerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyerAccountId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.BuyerAccountId))
	}
	if m.ReqParams != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ReqParams.Size()))
		n2, err := m.ReqParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListOrdersByBuyerRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersByBuyerRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStruct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReqParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Page))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Limit))
	}
	if m.From != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.To))
	}
	if len(m.SortBy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.SortBy)))
		i += copy(dAtA[i:], m.SortBy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if len(m.RemoteIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.RemoteIp)))
		i += copy(dAtA[i:], m.RemoteIp)
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.UpdatedAt))
	}
	if m.GrandTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.GrandTotal))
	}
	if m.SubTotal != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.SubTotal))
	}
	if m.CancelBy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.CancelBy))
	}
	if m.PaymentMethod != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.PaymentMethod))
	}
	if m.FraudInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.FraudInfo.Size()))
		n3, err := m.FraudInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ShippingAddress != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShippingAddress.Size()))
		n4, err := m.ShippingAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.WarehouseAddress != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.WarehouseAddress.Size()))
		n5, err := m.WarehouseAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SendoShippingDiscount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.SendoShippingDiscount))
	}
	if len(m.BuyerAgent) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.BuyerAgent)))
		i += copy(dAtA[i:], m.BuyerAgent)
	}
	if len(m.BuyerDevice) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.BuyerDevice)))
		i += copy(dAtA[i:], m.BuyerDevice)
	}
	if m.Buyer != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Buyer.Size()))
		n6, err := m.Buyer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Seller != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Seller.Size()))
		n7, err := m.Seller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Voucher != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Voucher.Size()))
		n8, err := m.Voucher.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Rating != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Rating.Size()))
		n9, err := m.Rating.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.CompletedAt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.CompletedAt))
	}
	if len(m.CarriedId) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.CarriedId)))
		i += copy(dAtA[i:], m.CarriedId)
	}
	if m.AffiliateAmount != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.AffiliateAmount))
	}
	if m.SendoSupportFee != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.SendoSupportFee))
	}
	if m.SenpaySupportFee != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.SenpaySupportFee))
	}
	if m.LoyaltyAmount != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.LoyaltyAmount))
	}
	if m.Weight != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Weight))
	}
	if m.IsFreeShipping {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsFreeShipping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Products) > 0 {
		for _, msg := range m.Products {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintStruct(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Buyer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Buyer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Account.Size()))
		n10, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.IsBadBuyer {
		dAtA[i] = 0x10
		i++
		if m.IsBadBuyer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Seller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Seller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Account.Size()))
		n11, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ShopId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopId))
	}
	if m.ShopLevel != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopLevel))
	}
	if m.ShopCreatedAt != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopCreatedAt))
	}
	if m.ShopUpdatedAt != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopUpdatedAt))
	}
	if m.ShopTotalOrders != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopTotalOrders))
	}
	if m.ShopTotalProducts != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ShopTotalProducts))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Id))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.RemoteIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.RemoteIp)))
		i += copy(dAtA[i:], m.RemoteIp)
	}
	if m.ContactAddress != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ContactAddress.Size()))
		n12, err := m.ContactAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.CreatedAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.ProductId))
	}
	if len(m.CategoryPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.CategoryPath)))
		i += copy(dAtA[i:], m.CategoryPath)
	}
	if m.Gerne != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Gerne))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Voucher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Voucher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VoucherCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.VoucherCode)))
		i += copy(dAtA[i:], m.VoucherCode)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Amount))
	}
	if len(m.VoucherCampaign) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.VoucherCampaign)))
		i += copy(dAtA[i:], m.VoucherCampaign)
	}
	if m.IsVoucherShop {
		dAtA[i] = 0x20
		i++
		if m.IsVoucherShop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Fraud) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fraud) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsFraud {
		dAtA[i] = 0x8
		i++
		if m.IsFraud {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Weight != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Type))
	}
	if m.IsOverrided {
		dAtA[i] = 0x20
		i++
		if m.IsOverrided {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.RegionId))
	}
	if len(m.RegionName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.RegionName)))
		i += copy(dAtA[i:], m.RegionName)
	}
	if m.DistrictId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.DistrictId))
	}
	if len(m.DistrictName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.DistrictName)))
		i += copy(dAtA[i:], m.DistrictName)
	}
	if m.WardId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.WardId))
	}
	if len(m.WardName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.WardName)))
		i += copy(dAtA[i:], m.WardName)
	}
	if len(m.Street) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Street)))
		i += copy(dAtA[i:], m.Street)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Rating) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rating) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Score))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStruct(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStruct(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintStruct(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ListOrdersBySellerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SellerAccountId != 0 {
		n += 1 + sovStruct(uint64(m.SellerAccountId))
	}
	if m.ReqParams != nil {
		l = m.ReqParams.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListOrdersBySellerRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovStruct(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovStruct(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListOrdersByBuyerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuyerAccountId != 0 {
		n += 1 + sovStruct(uint64(m.BuyerAccountId))
	}
	if m.ReqParams != nil {
		l = m.ReqParams.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListOrdersByBuyerRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovStruct(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovStruct(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovStruct(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovStruct(uint64(m.Limit))
	}
	if m.From != 0 {
		n += 1 + sovStruct(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovStruct(uint64(m.To))
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.RemoteIp)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStruct(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovStruct(uint64(m.UpdatedAt))
	}
	if m.GrandTotal != 0 {
		n += 1 + sovStruct(uint64(m.GrandTotal))
	}
	if m.SubTotal != 0 {
		n += 1 + sovStruct(uint64(m.SubTotal))
	}
	if m.CancelBy != 0 {
		n += 1 + sovStruct(uint64(m.CancelBy))
	}
	if m.PaymentMethod != 0 {
		n += 1 + sovStruct(uint64(m.PaymentMethod))
	}
	if m.FraudInfo != nil {
		l = m.FraudInfo.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.ShippingAddress != nil {
		l = m.ShippingAddress.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.WarehouseAddress != nil {
		l = m.WarehouseAddress.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.SendoShippingDiscount != 0 {
		n += 1 + sovStruct(uint64(m.SendoShippingDiscount))
	}
	l = len(m.BuyerAgent)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.BuyerDevice)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Buyer != nil {
		l = m.Buyer.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Seller != nil {
		l = m.Seller.Size()
		n += 2 + l + sovStruct(uint64(l))
	}
	if m.Voucher != nil {
		l = m.Voucher.Size()
		n += 2 + l + sovStruct(uint64(l))
	}
	if m.Rating != nil {
		l = m.Rating.Size()
		n += 2 + l + sovStruct(uint64(l))
	}
	if m.CompletedAt != 0 {
		n += 2 + sovStruct(uint64(m.CompletedAt))
	}
	l = len(m.CarriedId)
	if l > 0 {
		n += 2 + l + sovStruct(uint64(l))
	}
	if m.AffiliateAmount != 0 {
		n += 2 + sovStruct(uint64(m.AffiliateAmount))
	}
	if m.SendoSupportFee != 0 {
		n += 2 + sovStruct(uint64(m.SendoSupportFee))
	}
	if m.SenpaySupportFee != 0 {
		n += 2 + sovStruct(uint64(m.SenpaySupportFee))
	}
	if m.LoyaltyAmount != 0 {
		n += 2 + sovStruct(uint64(m.LoyaltyAmount))
	}
	if m.Weight != 0 {
		n += 2 + sovStruct(uint64(m.Weight))
	}
	if m.IsFreeShipping {
		n += 3
	}
	if len(m.Products) > 0 {
		for _, e := range m.Products {
			l = e.Size()
			n += 2 + l + sovStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Buyer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.IsBadBuyer {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Seller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.ShopId != 0 {
		n += 1 + sovStruct(uint64(m.ShopId))
	}
	if m.ShopLevel != 0 {
		n += 1 + sovStruct(uint64(m.ShopLevel))
	}
	if m.ShopCreatedAt != 0 {
		n += 1 + sovStruct(uint64(m.ShopCreatedAt))
	}
	if m.ShopUpdatedAt != 0 {
		n += 1 + sovStruct(uint64(m.ShopUpdatedAt))
	}
	if m.ShopTotalOrders != 0 {
		n += 1 + sovStruct(uint64(m.ShopTotalOrders))
	}
	if m.ShopTotalProducts != 0 {
		n += 1 + sovStruct(uint64(m.ShopTotalProducts))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStruct(uint64(m.Id))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.RemoteIp)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.ContactAddress != nil {
		l = m.ContactAddress.Size()
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStruct(uint64(m.CreatedAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovStruct(uint64(m.ProductId))
	}
	l = len(m.CategoryPath)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Gerne != 0 {
		n += 1 + sovStruct(uint64(m.Gerne))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Voucher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoucherCode)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovStruct(uint64(m.Amount))
	}
	l = len(m.VoucherCampaign)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.IsVoucherShop {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Fraud) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFraud {
		n += 2
	}
	if m.Weight != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovStruct(uint64(m.Type))
	}
	if m.IsOverrided {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovStruct(uint64(m.RegionId))
	}
	l = len(m.RegionName)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.DistrictId != 0 {
		n += 1 + sovStruct(uint64(m.DistrictId))
	}
	l = len(m.DistrictName)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.WardId != 0 {
		n += 1 + sovStruct(uint64(m.WardId))
	}
	l = len(m.WardName)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.Street)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rating) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != 0 {
		n += 1 + sovStruct(uint64(m.Score))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovStruct(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStruct(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStruct(x uint64) (n int) {
	return sovStruct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListOrdersBySellerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersBySellerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersBySellerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerAccountId", wireType)
			}
			m.SellerAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerAccountId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqParams == nil {
				m.ReqParams = &ReqParams{}
			}
			if err := m.ReqParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrdersBySellerRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersBySellerRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersBySellerRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Order{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrdersByBuyerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersByBuyerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersByBuyerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyerAccountId", wireType)
			}
			m.BuyerAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyerAccountId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqParams == nil {
				m.ReqParams = &ReqParams{}
			}
			if err := m.ReqParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrdersByBuyerRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersByBuyerRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersByBuyerRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Order{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrandTotal", wireType)
			}
			m.GrandTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrandTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTotal", wireType)
			}
			m.SubTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelBy", wireType)
			}
			m.CancelBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelBy |= (CancelBy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			m.PaymentMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentMethod |= (PaymentMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FraudInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FraudInfo == nil {
				m.FraudInfo = &Fraud{}
			}
			if err := m.FraudInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingAddress == nil {
				m.ShippingAddress = &Address{}
			}
			if err := m.ShippingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WarehouseAddress == nil {
				m.WarehouseAddress = &Address{}
			}
			if err := m.WarehouseAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendoShippingDiscount", wireType)
			}
			m.SendoShippingDiscount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendoShippingDiscount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyerAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyerAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyerDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyerDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buyer == nil {
				m.Buyer = &Buyer{}
			}
			if err := m.Buyer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seller == nil {
				m.Seller = &Seller{}
			}
			if err := m.Seller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voucher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voucher == nil {
				m.Voucher = &Voucher{}
			}
			if err := m.Voucher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rating == nil {
				m.Rating = &Rating{}
			}
			if err := m.Rating.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			m.CompletedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarriedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
			}
			m.AffiliateAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendoSupportFee", wireType)
			}
			m.SendoSupportFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendoSupportFee |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenpaySupportFee", wireType)
			}
			m.SenpaySupportFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenpaySupportFee |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoyaltyAmount", wireType)
			}
			m.LoyaltyAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoyaltyAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFreeShipping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFreeShipping = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Products", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Products = append(m.Products, &Product{})
			if err := m.Products[len(m.Products)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Buyer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Buyer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Buyer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBadBuyer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBadBuyer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Seller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopLevel", wireType)
			}
			m.ShopLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopLevel |= (ShopLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopCreatedAt", wireType)
			}
			m.ShopCreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopCreatedAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopUpdatedAt", wireType)
			}
			m.ShopUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopUpdatedAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopTotalOrders", wireType)
			}
			m.ShopTotalOrders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopTotalOrders |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopTotalProducts", wireType)
			}
			m.ShopTotalProducts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopTotalProducts |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContactAddress == nil {
				m.ContactAddress = &Address{}
			}
			if err := m.ContactAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gerne", wireType)
			}
			m.Gerne = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gerne |= (ProductGerne(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Voucher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voucher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voucher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoucherCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoucherCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoucherCampaign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoucherCampaign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVoucherShop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVoucherShop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fraud) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fraud: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fraud: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFraud", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFraud = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FraudType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOverrided", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOverrided = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			m.DistrictId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistrictId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WardId", wireType)
			}
			m.WardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WardName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WardName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rating) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rating: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rating: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStruct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStruct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStruct
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStruct
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStruct(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStruct = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStruct   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fdms/struct.proto", fileDescriptor_struct_692415c35026ebf0) }

var fileDescriptor_struct_692415c35026ebf0 = []byte{
	// 1807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x5f, 0x6f, 0x1b, 0x4b,
	0x15, 0xbf, 0xeb, 0xc6, 0xff, 0x4e, 0x62, 0xc7, 0x99, 0xe6, 0xcf, 0x26, 0xed, 0xed, 0x0d, 0x06,
	0x4a, 0x88, 0x5a, 0x87, 0x1b, 0xb8, 0x17, 0x24, 0x78, 0xb1, 0x1d, 0x27, 0xb1, 0x9a, 0xd8, 0xd6,
	0xda, 0x29, 0xea, 0x45, 0x68, 0x35, 0xf1, 0x8e, 0xed, 0x45, 0xf6, 0xee, 0x76, 0x66, 0x9c, 0x62,
	0x55, 0x95, 0x10, 0xe2, 0x9d, 0x07, 0x24, 0x78, 0xe0, 0x83, 0xf0, 0xca, 0x03, 0x42, 0x3c, 0x22,
	0xf1, 0x05, 0x50, 0xc5, 0x17, 0xe0, 0x1b, 0xa0, 0x39, 0x33, 0xbb, 0xb1, 0x53, 0x47, 0xbd, 0x42,
	0xf7, 0x6d, 0xe7, 0x77, 0x7e, 0x67, 0xce, 0xcc, 0xf9, 0x3b, 0x0b, 0x1b, 0x03, 0x6f, 0x22, 0x8e,
	0x84, 0xe4, 0xd3, 0xbe, 0xac, 0x44, 0x3c, 0x94, 0x21, 0xd9, 0x10, 0x2c, 0xf0, 0xc2, 0xca, 0xcd,
	0xe7, 0x15, 0x1a, 0xf9, 0x15, 0x25, 0xdf, 0x7b, 0x3c, 0x0c, 0xc3, 0xe1, 0x98, 0x1d, 0xd1, 0xc8,
	0x3f, 0xa2, 0x41, 0x10, 0x4a, 0x2a, 0xfd, 0x30, 0x10, 0x5a, 0xa1, 0xfc, 0x1b, 0x0b, 0xb6, 0x2e,
	0x7c, 0x21, 0xdb, 0xdc, 0x63, 0x5c, 0xd4, 0x66, 0x5d, 0x36, 0x1e, 0x33, 0xee, 0xb0, 0xd7, 0xe4,
	0x10, 0x36, 0x04, 0x2e, 0x5c, 0xda, 0xef, 0x87, 0xd3, 0x40, 0xba, 0xbe, 0x67, 0x5b, 0xfb, 0xd6,
	0xc1, 0x8a, 0xb3, 0xae, 0x05, 0x55, 0x8d, 0x37, 0x3d, 0xf2, 0x53, 0x00, 0xce, 0x5e, 0xbb, 0x11,
	0xe5, 0x74, 0x22, 0xec, 0xd4, 0xbe, 0x75, 0xb0, 0x7a, 0xfc, 0xb8, 0xf2, 0xc1, 0x59, 0x2a, 0x0e,
	0x7b, 0xdd, 0x41, 0x8e, 0x93, 0xe7, 0xf1, 0x67, 0xf9, 0x17, 0xcb, 0x4f, 0x20, 0xc8, 0x33, 0x58,
	0xf1, 0xa8, 0xa4, 0xb6, 0xb5, 0xff, 0xe0, 0x60, 0xf5, 0xd8, 0x5e, 0xb2, 0x1f, 0xea, 0x38, 0xc8,
	0x22, 0x9b, 0x90, 0x96, 0xa1, 0xa4, 0x63, 0x34, 0x5f, 0x70, 0xf4, 0xa2, 0xfc, 0x0e, 0x36, 0xe7,
	0x37, 0xaf, 0x4d, 0x67, 0xfa, 0x76, 0x07, 0x50, 0xba, 0x56, 0xdf, 0x1f, 0x5e, 0xae, 0x88, 0xf8,
	0x37, 0x74, 0xb7, 0xaf, 0x96, 0x9a, 0xff, 0x66, 0xae, 0xc6, 0x21, 0x9f, 0xd8, 0x24, 0x04, 0x56,
	0x22, 0x3a, 0x64, 0x78, 0x87, 0x82, 0x83, 0xdf, 0x4a, 0x6d, 0xec, 0x4f, 0x7c, 0x19, 0xab, 0xe1,
	0x42, 0x31, 0x07, 0x3c, 0x9c, 0xd8, 0x0f, 0x34, 0x53, 0x7d, 0x93, 0x22, 0xa4, 0x64, 0x68, 0xaf,
	0x20, 0x92, 0x92, 0x21, 0xd9, 0x81, 0xac, 0x08, 0xb9, 0x74, 0xaf, 0x67, 0x76, 0x7a, 0xdf, 0x3a,
	0xc8, 0x3b, 0x19, 0xb5, 0xac, 0xcd, 0xca, 0x7f, 0xc9, 0x43, 0x1a, 0x4f, 0x46, 0x76, 0x21, 0x17,
	0xaa, 0x8f, 0xd8, 0x71, 0x79, 0x27, 0x8b, 0xeb, 0xa6, 0x47, 0x1e, 0x41, 0x9e, 0xb3, 0x49, 0x28,
	0x99, 0xeb, 0x47, 0x68, 0x3b, 0xef, 0xe4, 0x34, 0xd0, 0x8c, 0xc8, 0xa7, 0x00, 0x7d, 0xce, 0xa8,
	0x64, 0x9e, 0x4b, 0xa5, 0x39, 0x44, 0xde, 0x20, 0x55, 0xa9, 0xc4, 0xd3, 0xc8, 0x8b, 0xc5, 0xfa,
	0x44, 0x79, 0x83, 0x54, 0x25, 0xf9, 0x0c, 0x56, 0x87, 0x9c, 0x06, 0x9e, 0xab, 0xfd, 0x91, 0xc6,
	0x88, 0x01, 0x42, 0x3d, 0x85, 0x28, 0xdb, 0x62, 0x7a, 0x6d, 0xc4, 0x19, 0x14, 0xe7, 0xc4, 0xf4,
	0x5a, 0x0b, 0x7f, 0x02, 0xf9, 0x3e, 0x0d, 0xfa, 0x6c, 0xac, 0x2e, 0x96, 0xdd, 0xb7, 0x0e, 0x8a,
	0xc7, 0x8f, 0x96, 0xb8, 0xbe, 0x8e, 0x9c, 0xda, 0xcc, 0xc9, 0xf5, 0xcd, 0x17, 0x39, 0x83, 0x62,
	0x44, 0x67, 0x13, 0x16, 0x48, 0x77, 0xc2, 0xe4, 0x28, 0xf4, 0xec, 0x1c, 0xaa, 0xef, 0x2f, 0x51,
	0xef, 0x68, 0xe2, 0x25, 0xf2, 0x9c, 0x42, 0x34, 0xbf, 0x24, 0x3f, 0x06, 0x18, 0x70, 0x3a, 0xf5,
	0x5c, 0x3f, 0x18, 0x84, 0x76, 0x1e, 0xb3, 0x69, 0x59, 0xf8, 0x4f, 0x15, 0xc9, 0xc9, 0x23, 0xb7,
	0x19, 0x0c, 0x42, 0xd2, 0x80, 0x92, 0x18, 0xf9, 0x51, 0xe4, 0x07, 0x43, 0x97, 0x7a, 0x1e, 0x67,
	0x42, 0xd8, 0x80, 0xea, 0x7b, 0x4b, 0xd4, 0xab, 0x9a, 0xe1, 0xac, 0xc7, 0x3a, 0x06, 0x20, 0x67,
	0xb0, 0xf1, 0x86, 0x72, 0x36, 0x0a, 0xa7, 0x82, 0x25, 0xfb, 0xac, 0x7e, 0x74, 0x9f, 0x52, 0xa2,
	0x14, 0x6f, 0xf4, 0x25, 0xec, 0x20, 0xdd, 0x4d, 0x4e, 0xe5, 0xf9, 0x02, 0x6b, 0xc6, 0x5e, 0x43,
	0xb7, 0x6f, 0xa1, 0xb8, 0x6b, 0xa4, 0x27, 0x46, 0xa8, 0x22, 0x68, 0x0a, 0x6f, 0xc8, 0x02, 0x69,
	0x17, 0x30, 0x3d, 0x40, 0xd7, 0x9c, 0x42, 0xc8, 0xb7, 0x60, 0x4d, 0x13, 0x3c, 0x76, 0xe3, 0xf7,
	0x99, 0x5d, 0x44, 0x86, 0x56, 0x3a, 0x41, 0x88, 0x54, 0x20, 0x8d, 0x4b, 0x7b, 0xfd, 0x5e, 0xff,
	0xe9, 0x4a, 0xd3, 0x34, 0xf2, 0x39, 0x64, 0x74, 0xc7, 0xb2, 0x4b, 0xa8, 0xb0, 0xbb, 0x44, 0xc1,
	0xb4, 0x1d, 0x43, 0x24, 0x3f, 0x82, 0xec, 0x4d, 0x38, 0xed, 0x8f, 0x18, 0xb7, 0x37, 0xee, 0xf5,
	0xce, 0x4b, 0xcd, 0x70, 0x62, 0xaa, 0x32, 0xc4, 0xa9, 0xf4, 0x83, 0xa1, 0x4d, 0xee, 0x35, 0xe4,
	0x20, 0xc1, 0x31, 0x44, 0x75, 0xdd, 0x7e, 0x38, 0x89, 0xc6, 0xcc, 0xa4, 0xfc, 0x43, 0x4c, 0xf9,
	0xd5, 0x04, 0xd3, 0x35, 0xd1, 0xa7, 0x9c, 0xfb, 0xcc, 0x53, 0xc5, 0xb6, 0x89, 0xfe, 0xc8, 0x1b,
	0xa4, 0xe9, 0x91, 0xef, 0x43, 0x89, 0x0e, 0x06, 0xfe, 0xd8, 0xa7, 0x92, 0xb9, 0x74, 0x82, 0x21,
	0xd8, 0xd2, 0x7d, 0x3a, 0xc1, 0xab, 0x08, 0xeb, 0x9e, 0x8e, 0x41, 0x9b, 0x46, 0x91, 0x2a, 0xf0,
	0x01, 0x63, 0xf6, 0x76, 0xdc, 0xd3, 0x55, 0xb8, 0x34, 0x7e, 0xca, 0x18, 0x79, 0x06, 0x44, 0xb0,
	0x20, 0xa2, 0xb3, 0x05, 0xf2, 0x0e, 0x92, 0x4b, 0x5a, 0x32, 0xc7, 0xfe, 0x2e, 0x14, 0xc7, 0xe1,
	0x8c, 0x8e, 0xe5, 0x2c, 0x3e, 0x82, 0x8d, 0xcc, 0x82, 0x41, 0xcd, 0x01, 0xb6, 0x21, 0xf3, 0x86,
	0xf9, 0xc3, 0x91, 0xb4, 0x77, 0xf1, 0x9e, 0x66, 0xa5, 0xda, 0xb1, 0x2f, 0xdc, 0x01, 0x67, 0x2c,
	0xc9, 0x27, 0x7b, 0x6f, 0xdf, 0x3a, 0xc8, 0x39, 0x45, 0x5f, 0x9c, 0x72, 0xc6, 0xe2, 0x3c, 0x22,
	0x5f, 0x42, 0x2e, 0xe2, 0xa1, 0x37, 0xed, 0x4b, 0x61, 0x3f, 0xc1, 0xee, 0xb9, 0x2c, 0x32, 0x1d,
	0x4d, 0x71, 0x12, 0x6e, 0xd9, 0x85, 0x34, 0xe6, 0x84, 0x8a, 0xac, 0xe9, 0xf9, 0xd8, 0xb7, 0xee,
	0xc9, 0x7b, 0xcd, 0x70, 0x62, 0x2a, 0xd9, 0x87, 0x35, 0x5f, 0xb8, 0xd7, 0xd4, 0x73, 0x75, 0xe6,
	0xa5, 0xf0, 0x70, 0xe0, 0x8b, 0x1a, 0xf5, 0x70, 0xdf, 0xf2, 0x5f, 0x53, 0x90, 0xe9, 0x26, 0xc9,
	0xf3, 0x7f, 0x98, 0x50, 0x4d, 0x77, 0x14, 0x46, 0x2a, 0xc6, 0x80, 0xbe, 0xcb, 0xa8, 0xa5, 0x9e,
	0x40, 0x28, 0x18, 0xb3, 0x1b, 0x36, 0xc6, 0x62, 0x2d, 0x2e, 0x9d, 0x40, 0xdd, 0x51, 0x18, 0x5d,
	0x28, 0x8e, 0x93, 0x17, 0xf1, 0x27, 0x79, 0x0a, 0xeb, 0xa8, 0x3c, 0xd7, 0x74, 0x75, 0x7d, 0x16,
	0x14, 0x5c, 0x4f, 0x1a, 0x6f, 0xcc, 0x9b, 0xeb, 0xbe, 0x85, 0x5b, 0xde, 0x55, 0xd2, 0x81, 0x55,
	0x0a, 0x29, 0x1e, 0x76, 0x58, 0x17, 0x5b, 0xbe, 0xc0, 0x1a, 0x55, 0x29, 0x34, 0x0a, 0x23, 0xec,
	0xb4, 0x7a, 0xde, 0x91, 0x0a, 0x3c, 0x9c, 0xe3, 0x26, 0x61, 0x5b, 0x47, 0xf6, 0x46, 0xc2, 0xee,
	0xc4, 0x31, 0xfa, 0xbb, 0x05, 0x59, 0xe3, 0x16, 0x35, 0x92, 0x92, 0x91, 0x9c, 0xf2, 0x3d, 0x35,
	0xcc, 0xa2, 0x51, 0x18, 0x30, 0x33, 0x50, 0xf4, 0x42, 0xa1, 0x6c, 0x42, 0xfd, 0x31, 0x0e, 0x92,
	0xbc, 0xa3, 0x17, 0x8b, 0x03, 0x68, 0xe5, 0xce, 0x00, 0xaa, 0xc3, 0x7a, 0x3f, 0x0c, 0x24, 0xed,
	0xcb, 0xa4, 0xff, 0xa5, 0x3f, 0xda, 0xff, 0x8a, 0x46, 0x25, 0xee, 0x7e, 0x8b, 0x53, 0x2c, 0x73,
	0x67, 0x8a, 0x95, 0x7f, 0x67, 0x41, 0xd6, 0xdc, 0x4a, 0x51, 0xcd, 0xcd, 0xe3, 0x51, 0x59, 0x70,
	0xf2, 0x06, 0x69, 0x7a, 0xe4, 0xdb, 0x50, 0xe8, 0x53, 0xc9, 0x86, 0x21, 0x9f, 0xb9, 0x11, 0x95,
	0x23, 0x73, 0xbf, 0xb5, 0x18, 0xec, 0x50, 0x39, 0x22, 0x5f, 0x40, 0x7a, 0xc8, 0x78, 0xc0, 0xf0,
	0x9a, 0xc5, 0xe3, 0xcf, 0xee, 0xcf, 0xf8, 0x33, 0x45, 0x73, 0x34, 0xbb, 0xfc, 0x27, 0x0b, 0xb2,
	0xa6, 0x47, 0xa9, 0x3e, 0x63, 0xba, 0x94, 0xdb, 0x0f, 0x3d, 0x66, 0x66, 0xf6, 0xaa, 0xc1, 0xea,
	0xa1, 0xc7, 0x54, 0x71, 0x9a, 0xda, 0x4d, 0xe9, 0xfc, 0xd3, 0x2b, 0xd5, 0x60, 0x12, 0x55, 0x3a,
	0x89, 0xa8, 0x3f, 0x0c, 0x8c, 0xbf, 0xd7, 0x63, 0x75, 0x03, 0xab, 0x2c, 0xf2, 0x85, 0x1b, 0xb3,
	0x55, 0x84, 0xd1, 0xff, 0x39, 0xa7, 0xe0, 0x0b, 0x73, 0x12, 0x95, 0xa5, 0xe5, 0xdf, 0x5b, 0x90,
	0xc6, 0x11, 0xa7, 0xde, 0x11, 0x58, 0xf9, 0x74, 0xaa, 0x9d, 0x93, 0x73, 0xb2, 0xaa, 0xe2, 0x95,
	0xe8, 0xb6, 0x59, 0xa8, 0xf3, 0xa4, 0x92, 0x66, 0xf1, 0x03, 0x58, 0x91, 0xb3, 0x28, 0x76, 0xc6,
	0xe3, 0xfb, 0xa6, 0x67, 0x6f, 0x16, 0x31, 0x07, 0x99, 0xea, 0xf2, 0xbe, 0x70, 0xc3, 0x1b, 0xc6,
	0xb9, 0xef, 0x31, 0xcf, 0x9c, 0x69, 0xd5, 0x17, 0xed, 0x18, 0x2a, 0xff, 0x57, 0xe5, 0x9e, 0x89,
	0x2e, 0xe6, 0xcf, 0xd0, 0x0f, 0x83, 0xdb, 0x88, 0xe5, 0x34, 0xd0, 0xf4, 0xd4, 0x00, 0x33, 0xc2,
	0x80, 0x4e, 0xe2, 0x74, 0x04, 0x0d, 0xb5, 0xe8, 0x84, 0x29, 0x82, 0xe7, 0x0b, 0xc9, 0x7d, 0x1d,
	0x71, 0xfd, 0xc4, 0x81, 0x18, 0xd2, 0x21, 0x4f, 0x08, 0xb8, 0x87, 0x4e, 0xd1, 0xb5, 0x18, 0xc4,
	0x5d, 0x76, 0x20, 0xfb, 0x86, 0x72, 0xec, 0xf8, 0x69, 0xd3, 0x2a, 0x29, 0xf7, 0xf4, 0xeb, 0x0a,
	0x05, 0xa8, 0x99, 0xd1, 0xc9, 0xad, 0x00, 0xd4, 0xda, 0x86, 0x8c, 0x90, 0x9c, 0x31, 0x89, 0xcf,
	0x1b, 0xf5, 0x6e, 0xc3, 0xd5, 0x6d, 0xf5, 0xc0, 0x5c, 0xf5, 0x94, 0x8f, 0x21, 0xa3, 0xa7, 0x91,
	0x92, 0x8b, 0x7e, 0xc8, 0xe3, 0xf7, 0xa3, 0x5e, 0xa8, 0xa7, 0xa2, 0x64, 0xbf, 0x96, 0xe6, 0x8e,
	0xf8, 0x5d, 0xfe, 0x02, 0xd2, 0x0d, 0xce, 0x43, 0xae, 0x84, 0x49, 0x22, 0x15, 0x1c, 0xfc, 0x26,
	0x36, 0x64, 0x27, 0x4c, 0x08, 0xf5, 0x10, 0xd5, 0x3a, 0xf1, 0xf2, 0xf0, 0x57, 0xb0, 0x36, 0x9f,
	0xa1, 0x64, 0x17, 0xb6, 0x3a, 0x4e, 0xfb, 0xe4, 0xaa, 0xde, 0x73, 0xcf, 0x1a, 0x4e, 0xab, 0xe1,
	0x5e, 0xb5, 0x5e, 0xb4, 0xda, 0x3f, 0x6f, 0x95, 0x3e, 0x21, 0x9f, 0xc2, 0xee, 0xa2, 0xa8, 0x56,
	0xed, 0x36, 0xeb, 0xee, 0x59, 0xbb, 0x7d, 0xd2, 0x2d, 0x59, 0x64, 0x1f, 0x1e, 0x2f, 0x8a, 0xeb,
	0xed, 0x56, 0xf7, 0xea, 0xb2, 0xe1, 0x18, 0x46, 0xea, 0xf0, 0x35, 0xe4, 0x93, 0x04, 0x20, 0xdb,
	0x40, 0x4e, 0x9d, 0xea, 0xd5, 0x89, 0xdb, 0x7b, 0xd5, 0x99, 0xb7, 0xb2, 0x88, 0xbf, 0x6c, 0x5f,
	0xd5, 0xcf, 0x1b, 0x4e, 0xc9, 0x22, 0x8f, 0x60, 0x67, 0x0e, 0xef, 0x9e, 0x37, 0x3b, 0x9d, 0x66,
	0xeb, 0xcc, 0x3d, 0x6d, 0x34, 0x4a, 0x29, 0xb2, 0x03, 0x0f, 0xe7, 0x84, 0xf5, 0x6a, 0xf7, 0xbc,
	0x56, 0xad, 0xbf, 0x28, 0x3d, 0x38, 0x7c, 0x0b, 0x85, 0x85, 0x67, 0x1f, 0xd9, 0x83, 0xed, 0x4e,
	0xf5, 0xd5, 0x65, 0xa3, 0xd5, 0x73, 0x2f, 0x1b, 0xbd, 0xf3, 0xf6, 0xc9, 0xa2, 0xe9, 0x3b, 0xb2,
	0x7a, 0xfb, 0x44, 0x9b, 0xbe, 0x83, 0x37, 0x5b, 0xdd, 0x5e, 0xb5, 0x55, 0x57, 0xa6, 0x95, 0xc3,
	0x16, 0x85, 0xed, 0xd6, 0x45, 0xb3, 0xd5, 0x28, 0x3d, 0x38, 0x7c, 0x01, 0xf9, 0xa4, 0xf5, 0xab,
	0xcd, 0xbb, 0xe7, 0xed, 0x8e, 0x7b, 0xd1, 0x78, 0xd9, 0xb8, 0x98, 0x33, 0x4a, 0xa0, 0x38, 0x87,
	0x77, 0xaf, 0x7a, 0x25, 0xeb, 0x2e, 0xd6, 0xab, 0x97, 0x52, 0x87, 0xbf, 0x84, 0x5c, 0xfc, 0xfe,
	0x25, 0x1b, 0x50, 0xa8, 0x2b, 0xf3, 0x17, 0x6e, 0xed, 0x95, 0xdb, 0x3e, 0x3d, 0x2d, 0x7d, 0x42,
	0x1e, 0xc2, 0xfa, 0x2d, 0x54, 0xbb, 0x7a, 0x85, 0x3e, 0xdb, 0x84, 0xd2, 0x2d, 0xd8, 0x6d, 0x5c,
	0x5c, 0x34, 0x9c, 0x52, 0x6a, 0x91, 0xda, 0xee, 0x29, 0xf7, 0x3e, 0x38, 0xfe, 0x5b, 0x0a, 0x56,
	0x4f, 0x4f, 0x2e, 0xbb, 0x5d, 0xc6, 0xf1, 0x29, 0xf7, 0x67, 0x0b, 0xb6, 0xce, 0x98, 0xfc, 0xf0,
	0x07, 0x90, 0x1c, 0x2c, 0xa9, 0xeb, 0xa5, 0x7f, 0xaa, 0x7b, 0x5f, 0x97, 0x29, 0xca, 0x95, 0xdf,
	0xfe, 0xeb, 0x3f, 0x7f, 0x48, 0x1d, 0x90, 0xa7, 0x47, 0xf8, 0xeb, 0x8c, 0xd3, 0xeb, 0xb9, 0x7e,
	0xf1, 0x1d, 0xbd, 0xfd, 0xe0, 0x6f, 0xf7, 0x1d, 0xf9, 0xa3, 0x05, 0x9b, 0x77, 0x4e, 0xa7, 0x1f,
	0x11, 0xdf, 0xfb, 0x88, 0xc9, 0xf8, 0x3f, 0x73, 0xef, 0x6b, 0x12, 0x45, 0xf9, 0x19, 0x1e, 0xed,
	0x29, 0xf9, 0xce, 0xfc, 0xd1, 0xf0, 0xad, 0x71, 0xf4, 0xf6, 0xee, 0x9f, 0xea, 0xbb, 0xda, 0xcf,
	0xfe, 0xf1, 0xfe, 0x89, 0xf5, 0xcf, 0xf7, 0x4f, 0xac, 0x7f, 0xbf, 0x7f, 0x62, 0x7d, 0x55, 0x19,
	0xfa, 0x72, 0x4c, 0xaf, 0x63, 0x53, 0xc1, 0x11, 0xfe, 0xdb, 0x5f, 0x4f, 0x07, 0x47, 0x7e, 0x20,
	0x19, 0x0f, 0xe8, 0xf8, 0x39, 0x8d, 0x7c, 0xf1, 0x7c, 0x18, 0xe2, 0xe6, 0xd7, 0x19, 0x94, 0xff,
	0xf0, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x9e, 0xbc, 0xb2, 0x41, 0x10, 0x00, 0x00,
}
